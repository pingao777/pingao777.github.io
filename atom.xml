<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>扯淡有理</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pingao777.github.io/"/>
  <updated>2020-10-18T09:58:00.410Z</updated>
  <id>https://pingao777.github.io/</id>
  
  <author>
    <name>bearfly</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Loom项目的进展：第一部分（State of Loom）</title>
    <link href="https://pingao777.github.io/2020/10/11/Loom%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9B%E5%B1%95%EF%BC%9A%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%88State%20of%20Loom%EF%BC%89/"/>
    <id>https://pingao777.github.io/2020/10/11/Loom项目的进展：第一部分（State of Loom）/</id>
    <published>2020-10-11T05:27:24.000Z</published>
    <updated>2020-10-18T09:58:00.410Z</updated>
    
    <content type="html"><![CDATA[<p>本文是<a href="https://cr.openjdk.java.net/~rpressler/loom/loom/sol1_part1.html">State of Loom</a>的翻译。</p><p>Loom 项目旨在大大减少编写、维护和观察高吞吐量并发应用程序的工作量，从而最大限度地利用可用硬件。</p><p>Loom项目的工作于2017年开始。本文档解释了项目的动机和所采取的方法，并总结了我们迄今为止的工作。像所有OpenJDK项目一样，它将分阶段交付，不同的组件在不同的时间到达GA(通用可用性) ，可能首先利用预览（ <a href="https://openjdk.java.net/jeps/12">Preview</a>）机制。</p><p>您可以在它的<a href="https://wiki.openjdk.java.net/display/loom/">wiki</a>上找到更多关于Loom项目的资料，并在<a href="http://jdk.java.net/loom/">Loom EA binaries</a> 文件(Early Access)中尝试下面描述的大部分内容。非常感激如果你能够将使用Loom的意见反馈到<a href="https://mail.openjdk.java.net/pipermail/loom-dev/">loom-dev</a>邮件列表。</p><pre><code class="java">Thread.startVirtualThread(() -&gt; &#123;    System.out.println(&quot;Hello, Loom!&quot;);&#125;);</code></pre><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><ul><li>虚拟线程是一个Thread——在代码层面、运行时、调试阶段以及分析阶段都如此。</li><li>虚拟线程并不是OS线程的包装，而是一个Java对象。</li><li>创建一个虚拟线程的代价非常低廉——你可以创建数百万的虚拟线程，不用池化它们。</li><li>阻塞一个虚拟线程的代价非常低廉。</li><li>不需要改变语言。</li><li>可插拔式调度器提供了异步编程的灵活性。</li></ul><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><ul><li><p>为什么</p><ul><li>线程就是一切</li><li>支撑线程失去了它们的重点</li></ul></li><li><p>大小合适的线程</p><ul><li>从线程到虚拟线程</li><li>如何使用虚拟线程编程（你已经知道）</li><li>调度</li><li>性能和足迹</li><li>自旋</li><li>所有阻塞由我们来负责</li><li>调试和分析</li></ul></li><li>为什么“虚拟”</li><li>第二部分：进一步的工作</li></ul><h1 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h1><h2 id="线程就是一切"><a href="#线程就是一切" class="headerlink" title="线程就是一切"></a>线程就是一切</h2><p>Java 用于编写一些世界上最大、最具可伸缩性的应用程序。可伸缩性是程序优雅地处理不断增长的工作负载的能力。实现可伸缩性的一种方式是并行（<em>parallelism</em>）：我们想要处理一大块可能相当大的数据，我们将它转换为lambda流水线，通过将它设置为并行，我们要求多个处理核心一起处理流水线上的任务，就像一群食人鱼吞食一条大鱼一样; 一条食人鱼也可以完成任务—- 只是前面的方式更快。这种机制是在 java8中实现的。但是有一种不同的、更难的、更普遍的扩展方式，即在同一时间处理应用程序中相对独立的任务。它们必须同时得到服务，这不是一种实现选择，而是一种要求。我们称之为并发性（<em>concurrency</em>），它是当代软件的基础，这就是Loom的意义所在。</p><p>考虑一下web服务器。它所服务的每个请求在很大程度上都是独立于其他请求的。对于每个服务，我们进行一些解析、查询数据库或向服务发出请求，然后等待结果，再进行一些处理并发送响应。这个过程不仅在完成某项工作时不与其他同时发生的HTTP请求合作，而且大多数时候它根本不关心其他请求在做什么，但它仍然在处理数据和I/O资源方面与它们竞争。不是食人鱼，而是出租车，每一条都有自己的路线和目的地。在同一条道路上行驶的其他出租车并不会让任何一辆出租车更早到达目的地ーー如果非要说有什么影响的话，也许会减慢速度ーー但是如果在城市道路上的任何时间只有一辆出租车，那就不仅仅是一个缓慢的交通系统，而是一个功能失调的系统。越多的出租车可以共用道路同时又不会造成市中心的交通拥堵，这个系统就越好。从早期开始，Java 就支持这种工作。Servlet 允许我们编写在屏幕上看起来简单直观的代码。一个简单的过程为ーー解析、数据库查询、处理、响应ーー不管服务器现在只处理这一个请求还是处理其他一千个请求。</p><p>每个并发应用程序都有一些天然属于其领域的并发单元，这些工作是可以独立于其他工作同时完成的。对于web服务器，这可能是HTTP请求或用户会话; 对于数据库服务器，这可能是事务。并发性有着比Java早得多的悠久而丰富的历史，但就Java的设计思想而言，其实很简单: 用一个按顺序运行的并发软件单元来表示这个领域并发单元，就像一辆出租车沿着其简单的路线前进，而不考虑其他任何出租车一样。这种软件构造就是线程。它对从处理器到I/O设备的资源进行虚拟化，并对其使用进行调度ーー利用每个线程可能在不同时间使用不同硬件单元的事实ーー对外暴露出来就好象一个顺序的过程。线程的拥有属性在于，它们不仅对处理操作进行排序，而且还对阻塞进行排序—- 等待某些外部事件的发生，不管是I/O还是某些事件，或者由另一个线程触发，只有在这些事件发生之后才继续执行。线程应该如何最好地相互通信的问题ーー共享数据结构和消息传递的合适的组合应该是什么ーー对于线程的概念来说并不是必不可少的，而且不管Java应用程序当前的组合是什么，它都有可能随着新特性的出现而改变。</p><p>无论您是直接使用它们，还是在JAX-RS框架内使用它们，并发在Java中意味着线程。事实上，整个Java平台——从虚拟机，到语言和库，到调试器和分析器——都是围绕线程构建的，作为运行程序的核心组成部分:</p><ul><li>I/O API是同步的，I/O操作初始化并通过阻塞线程等待一系列语句的顺序结果；</li><li>内存副作用(如果为无竞争的)按照线程的操作顺序排序，就好像没有其他线程竞争使用该内存;</li><li>异常通过将失败操作放在当前线程的调用堆栈的上下文中提供有用的信息;</li><li>调试器中的单步执行按照顺序执行，无论是需要进行某种处理还是 I/O，因为单步执行与线程相关联;</li><li>分析器使用线程来展示操作、I/O等待或同步所耗费的时间；</li></ul><p>问题在于，作为并发性的软件单元，线程的规模无法与应用领域的并发性单元(会话、 HTTP 请求或单个数据库操作)相匹配，也无法与现代硬件所能支持的并发性规模相匹配。一台服务器可以处理超过100万个并发打开的套接字，但是操作系统不能有效地处理超过几千个活动(非空闲)线程。随着servlet容器的工作负载增加，越来越多的请求处于运行状态，它的伸缩能力受到操作系统能够支持的线程数量相对较少的限制，因为<a href="https://en.wikipedia.org/wiki/Little&#39;s_law">Little定律</a>告诉我们，服务请求的平均持续时间与我们能够并发执行的请求数量成正比。因此，如果我们用一个线程来表示一个并发领域单元，那么线程的稀缺性早在硬件实现之前就成为了我们的可伸缩性瓶颈。servlet 读起来好伸缩性不好。</p><p>这不是线程概念的基本限制，而是它们在JDK中作为操作系统线程的简单包装器实现的一个偶然特性。操作系统线程的占用空间很大，创建它们需要分配操作系统资源，而调度它们(即为它们分配硬件资源)是次优的。他们与其说是出租车，不如说是火车。</p><p>这就造成了线程本来要做的事情与它们能够有效地做的事情之间的巨大不匹配。几个数量级的不匹配可能会产生很大的影响。</p><h2 id="支撑线程失去了它们的重点"><a href="#支撑线程失去了它们的重点" class="headerlink" title="支撑线程失去了它们的重点"></a>支撑线程失去了它们的重点</h2><p>上述实现产生了巨大的影响。具有讽刺意味的是，线程发明出来是为了透明地共享虚拟化的稀缺计算资源，而线程本身已经成为稀缺资源，以至于我们不得不建立复杂的脚手架来共享它们。</p><p>因为线程的创建成本很高，所以我们将它们集中起来。创建一个新线程的成本是如此之高，以至于为了重用它们，我们很乐意为<a href="http://cr.openjdk.java.net/~rpressler/loom/loom/sol1_part2.html#scope-variables">泄漏的线程局部变量</a>和<a href="http://cr.openjdk.java.net/~rpressler/loom/loom/sol1_part2.html#more-on-interruption-and-cancellation">复杂的取消协议</a>买单。</p><p>但是线程池本身提供的线程共享机制过于粗粒度。即使在一个时间点上运行的所有并发任务线程池中都没有足够的线程来表示。在任务的整个持续时间都会占用从线程池中借用到的线程，即使在等待某个外部事件(如来自数据库或服务的响应，或任何其他可能阻止它的活动)时。当任务正在等待时，操作系统线程挂起的代价实在是太高了。为了更好和更有效地共享线程，我们可以在每次任务必须等待某个结果时将线程返回池。这意味着任务在整个执行过程中不再绑定到单个线程。这也意味着我们必须避免阻塞线程，因为阻塞的线程不能用于其他任何工作。</p><p>其结果是异步api的大行其道，从JDK中的异步NIO，到异步servlet，再到许多所谓的“反应”库，这些库正是这样做的——在任务等待时将线程返回到池中，并尽最大努力不阻塞线程。将任务分解并异步构造最后再将它们组合在一起，结果形成了侵入式的、全局的和约束性的框架。即使是基本的控制流，比如循环和try/catch，也需要在“反应式”dsl中重新构造一遍，有些sporting类拥有数百个方法。</p><p>因为，如上所述，大多数Java平台都假设执行上下文包含在一个线程中，一旦我们将任务与线程分离，所有上下文都将丢失: 异常堆栈跟踪不再提供有用的上下文，当单步调试时，我们发现自己处于调度程序代码中，从一个任务跳转到另一个任务，分析器在I/O负载下可能会向我们显示空闲线程池，因为等待I/O的任务不会通过阻塞占有线程，而是返回到池中。</p><p>这种风格现在被一些人使用，并不是因为它更容易理解——许多程序员报告说，对他们来说，这种风格更难理解; 不是因为它更容易调试或分析——而是更难; 不是因为它与语言的其他部分很好地契合，或者与现有代码很好地集成，或者可以隐藏在“专家专用代码”中——恰恰相反，<a href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">它具有病毒侵入性，使得与普通同步代码的干净集成几乎成为不可能</a>，而只是因为Java中线程在占用空间和性能上的实现都不足。异步编程风格时刻与Java平台的设计作斗争，并且在可维护性和可观察性方面付出了高昂的代价。但它这样做有一个很好的理由: 满足可伸缩性和吞吐量要求，并充分利用昂贵的硬件资源。</p><p>一些编程语言试图通过在线程之上构建一个新概念来解决棘手的异步代码问题: <a href="https://en.wikipedia.org/wiki/Async/await">async/await</a>。它的工作方式类似于线程，但是协作调度点显式地标记为await。这使得编写可伸缩的同步代码成为可能，并通过引入一种新的上下文来解决上下文问题，这种线程是一种除了名称以外与线程都不兼容的“新线程”。如果同步代码和异步代码不能混在一起——一个阻塞和另一个却返回某种类型的 Future或Flow —— async/await则创建了两个不同的“彩色”世界，即使它们都是同步的，也不能混合在一起。为了使问题更加复杂，异步的调用同步代码，尽管它们是同步的，但没有线程被阻塞。因此，<a href="https://social.technet.microsoft.com/wiki/contents/articles/21177.visual-c-thread-sleep-vs-task-delay.aspx">在C#中暂停当前正在执行的代码的一段时间需要两个不同的api</a>，<a href="https://medium.com/@mohak1712/kotlin-coroutines-thread-sleep-vs-delay-63171fe8a24">Kotlin也是这样做的</a>，一个用来暂停线程，另一个用来暂停类似于线程但不是线程的新线程。同样的道理也适用于所有新创建的同步api，从同步API到I/O。不仅仅是同一个概念的两个实现没有一个统一的抽象，而且这两个世界在语法上是分离的，要求程序员标记他的代码单元适合以一种模式或另一种模式运行，而不是两种模式都适合。</p><p>此外，显式的协作调度点在Java平台上几乎没有提供什么好处。VM是针对峰值性能进行优化的，而不是像实时操作系统那样具有确定性的最坏情况延迟，因此它可能会在程序的任意点引入各种暂停，更不用说操作系统的任意、不确定和不加限制的抢占。阻塞操作的持续时间可能比那些不确定的暂停时间长几个数量级，也可能短几个数量级，因此明确标记它们帮助不大。在更适当的粒度上控制延迟的一种更好的方法是<a href="http://cr.openjdk.java.net/~rpressler/loom/loom/sol1_part2.html#structured-interruption">deadlines</a>。</p><p>将线程作为稀缺资源进行管理的机制是一个很不幸的案例，因为实现的运行时性能特征而放弃了一个很好的抽象，取而代之的是另一个在大多数情况下更糟糕的方案。这种状态对Java生态系统产生了巨大的不利影响。</p><p>程序员被迫在直接将域并发单元建模为线程和浪费其硬件可以支持的相当大的吞吐量之间做出选择，或者使用其他方法在非常细粒度的级别上实现并发，但放弃Java平台的优势。无论是在硬件方面，还是在开发和维护工作方面，这两种选择都有相当大的财务成本。</p><p>我们可以做得更好。</p><p>Loom项目旨在消除高效运行并发程序与高效编写、维护和观察程序之间令人沮丧的权衡。它利用了平台的优势，而不是与之斗争，同时也利用了异步编程的高效组件的优势。它可以让你以熟悉的风格编写程序，使用熟悉的api，并与平台及其工具——以及硬件——保持一致，以便在写入时间和运行时成本之间达到平衡，我们希望这将具有广泛的吸引力。它在不改变语言的情况下做到了这一点，并且只对核心库api做了很小的改动。一个简单的同步web服务器将能够处理更多的请求，而不需要更多的硬件。</p><h1 id="大小合适的线程"><a href="#大小合适的线程" class="headerlink" title="大小合适的线程"></a>大小合适的线程</h1><p>如果我们可以让线程更轻，我们可以有更多的线程。如果我们有更多这样的资源，它们就可以按预期的那样使用: 通过虚拟化稀缺的计算资源和隐藏管理这些资源的复杂性，直接表示并发的领域单元。这并不是一个新的想法，或许最为人所熟悉的就是Erlang和Go所采用的方法。</p><p>我们的基础是虚拟线程。虚拟线程是线程，但创建和阻塞它们的代价很低。它们由Java运行时管理，与现有的平台线程不同，它们不是OS线程的一对一包装，而是在JDK的用户空间中实现的。</p><p>OS线程是重量级的，因为它们必须支持所有语言和所有工作负载。线程要求具有暂停和恢复执行的能力。这需要保持它的状态，包括指令指针或程序计数器，它包含当前指令的索引，以及存储在堆栈上的所有本地计算数据。因为操作系统不知道一种语言如何管理它的堆栈，所以它必须分配一个足够大的堆栈。然后，我们必须通过将执行分配给某个空闲的CPU核心来安排它们何时可以运行(启动或未停放)。由于操作系统内核必须调度各种各样的线程，这些线程在处理和阻塞的混合过程中表现得非常不同ーー有些是处理HTTP请求，有些是播放视频ーー它的调度程序必须是一个充分的全方位妥协。</p><p>Loom增加了控制执行，挂起和恢复它的能力，通过具体化它的状态不是作为一个操作系统资源，而是作为一个虚拟机了解的Java对象，并由 Java Runtime直接控制。Java 对象安全有效地为各种状态机和数据结构建模，因此也非常适合于建模执行。Java Runtime知道Java代码如何使用堆栈，因此它可以更紧凑地表示执行状态。对执行的直接控制还可以让我们选择更适合我们工作负载的调度程序(普通的Java调度程序) ; 实际上，我们可以使用可插拔的自定义调度程序。因此，Java Runtime对Java代码的卓越洞察力使我们能够减少线程的成本。</p><p>尽管操作系统可以支持多达几千个活动线程，但 Java Runtime可以支持数百万个虚拟线程。应用程序域中的每个并发单元都可以由其自己的线程来表示，从而使并发应用程序的编程更加容易。忘记线程池吧，只需要生成一个新线程，每个任务一个线程。您已经产生了一个新的虚拟线程来处理传入的HTTP请求，但是现在，在处理请求的过程中，您希望同时查询数据库并向其他三个服务发出传出请求？没问题—- 创建更多的线程。你需要等待一些事情发生而不浪费宝贵的资源？忘记回调或反应式流ーー直接阻塞就好了。编写简单、无聊的代码。线程给我们带来的所有好处——控制流、异常上下文、调试流、分析组织——都被虚拟线程保留下来; 只有运行时占用空间和性能的成本没有了。与异步编程相比，灵活性没有损失，因为正如我们将看到的，我们还没有放弃对调度的细粒度控制。</p><h2 id="迁移：从线程到虚拟线程"><a href="#迁移：从线程到虚拟线程" class="headerlink" title="迁移：从线程到虚拟线程"></a>迁移：从线程到虚拟线程</h2><p>有了新的功能，我们知道如何实现虚拟线程; 如何向程序员展示这些线程就不那么清楚了。</p><p>每一个新的Java特性都在保守和创新之间创造了一种张力。前向兼容性使现有代码可以享受新特性(一个很好的例子是使用单一抽象方法类型的旧代码如何与lambdas一起工作)。但我们也希望纠正过去的设计错误，重新开始。</p><p><code>java.lang.Thread</code>可以追溯到Java 1.0，多年来积累了方法和内部字段。它包含的方法有<code>suspend</code>、<code>resume</code>、 <code>stop</code>和<code>countStackFrames</code>，这些方法已经被废弃了20多年; 还有<code>getAllStackTraces</code>这样的方法，它假定线程数量很小，是一些过时的概念，比如上下文类加载器(context-classloader) ，添加这些概念是为了支持某些应用程序容器的使用; 甚至还有一些更老的方法，比如<code>ThreadGroup</code>，它的原始用途似乎已经被历史遗忘，但仍然充斥着许多处理线程的内部代码和工具，包括一些过时的方法，比如<code>Thread.enumerate</code>。</p><p>实际上，Loom的早期原型是在一个新的<code>Fiber</code>类中表示我们的用户模式线程，它帮助我们检查现有代码对线程API的依赖性。实验中的几个观察结果帮助我们确定了我们的立场:</p><ul><li>线程API的某些部分被广泛使用，特别是<code>Thread.currentThread()</code>和<code>ThreadLocal</code>。没有它们，几乎没有现有代码可以运行。我们尝试使<code>ThreadLocal</code>的意思是thread-or-fiber-local，并且让 <code>Thread.currentThread()</code>返回一些fiber的线程视图，但是这些都增加了复杂性。</li><li>Thread API 的其他部分不仅很少使用，而且很少向程序员公开。从 Java 5开始，程序员就被鼓励通过 <code>ExecutorServices</code>间接地创建和启动线程，这样<code>Thread</code>类中的混乱就不会带来极大的危害; 新的Java开发人员不需要接触到它的大部分，也不需要接触到它过时的残余。因此，保持 Thread API 的教学成本很小。</li><li>我们可以通过将<code>Thread</code>类中的元数据移动到一个“sidecar”对象来减少元数据的占用空间，只根据需要分配元数据。</li><li>新的弃用和删除策略将逐渐允许我们清理 Thread API。</li><li>我们想不出比<code>Thread</code>更好的东西来证明一个全新的API的合理性。</li></ul><p>尽管仍然存在一些不便之处，比如不恰当的返回类型和<a href="http://cr.openjdk.java.net/~rpressler/loom/loom/sol1_part2.html#more-on-interruption-and-cancellation">中断机制</a>，但是我们在实验中学到的——我们可以保留Thread API的一部分，而忽略另一部分——为了保留现有的API，我们移动了指针，并用现有<code>Thread</code>类来表示我们的用户模式线程。现在我们来看看: 虚拟线程就是线程，任何知道线程的库都已经知道虚拟线程。调试器和分析器使用它们的方式与当前的线程一样。与async/await不同，它们没有引入“语义鸿沟” : 程序员在屏幕上看到的代码行为在运行时被保留，并且对所有工具来说都是一样的。</p><h2 id="如何使用虚拟线程编程（你已经知道）"><a href="#如何使用虚拟线程编程（你已经知道）" class="headerlink" title="如何使用虚拟线程编程（你已经知道）"></a>如何使用虚拟线程编程（你已经知道）</h2><p>创建和启动一个虚拟线程可以这样做:</p><pre><code class="java">Thread t = Thread.startVirtualThread(() -&gt; &#123; ... &#125;);</code></pre><p>为了获得更大的灵活性，有一个新的 Thread. Builder，它可以做上面提到的同样的事情:</p><pre><code class="java">Thread t = Thread.builder().virtual().task(() -&gt; &#123; ... &#125;).start();</code></pre><p>或创建一个未启动的虚拟线程:</p><pre><code class="java">Thread t = Thread.builder().virtual().task(() -&gt; ...).build();</code></pre><p>没有公共或受保护的Thread构造函数来创建虚拟线程，这意味着Thread的子类不能是虚拟的。因为子类化平台类限制了我们发展它们的能力，这是我们想要阻止的。</p><p>构造器还可以创建一个 ThreadFactory,</p><pre><code class="java">ThreadFactory tf = Thread.builder().virtual().factory();</code></pre><p>可以传递给<code>java.util.concurrent</code>。执行器来创建使用虚拟线程并照常使用的<code>ExecutorServices</code>。但是，由于我们不需要也不想集中虚拟线程，所以我们向执行器添加了一个新方法<code>newUnboundedExecutor</code>。它构造了一个<code>ExecutorService</code>，为每个提交的任务创建并启动一个新线程，而不需要进行池操作ーー当任务终止时，它的线程终止:</p><pre><code class="java">ThreadFactory tf = Thread.builder().virtual().factory();ExecutorService e = Executors.newUnboundedExecutor(tf);Future&lt;Result&gt; f = e.submit(() -&gt; &#123; ... return result; &#125;); // spawns a new virtual thread...Result y = f.get(); // joins the virtual thread</code></pre><p>thread API 的包袱并不困扰我们，因为我们不直接使用它。</p><p>除了构造Thread对象之外，一切和之前一样，只是所有虚拟线程的残留<code>ThreadGroup</code>是固定的，不能枚举它的成员。<code>ThreadLocals</code>对虚拟线程的处理方式与对平台线程的处理方式一样，但是由于它们可能仅仅因为存在大量的虚拟线程而大大增加内存占用，<code>Thread.Builder</code>允许线程的创建者禁止在该线程中使用它们。我们正在探索<code>ThreadLocal</code> 的一个替代方案，在 Scope Variables 部分中有所描述。</p><p>引入虚拟线程并不移除操作系统支持的现有线程实现。虚拟线程只是线程的一种新的实现，它的占用空间和调度是不同的。两种类型都可以锁定相同的锁，通过相同的阻塞队列交换数据等等。可以使用一个新的方法<code>Thread.isVirtual</code>来区分两种实现，但只有低级别的同步或I/O代码可能会关心这种区分。</p><p>然而，与我们习惯使用的线程相比，线程的存在是如此轻量级，这确实需要一些心理调整。首先，我们不再需要避免阻塞，因为阻塞一个(虚拟)线程并不昂贵。我们可以使用所有熟悉的同步api，而不用为吞吐量付出高昂的代价。其次，创建这些线程是廉价的。在合理的范围内，每个任务都可以有完全属于自己的线程;永远不需要将它们组合在一起。如果我们不将它们集中起来，我们如何限制对某些服务的并发访问？我们没有将任务分解并在一个单独的、受限的池子中运行服务调用子任务，而是让整个任务在自己的线程中从头到尾运行，并在服务调用代码中使用信号量来限制并发性ーー应该这样做。</p><p>很好地使用虚拟线程并不需要学习新的概念，而是要求我们抛弃多年来形成的旧习惯，之前我们自动的将高成本与线程联系起来，仅仅因为我们只有一个实现。</p><p>在本文的其余部分，我们将讨论虚拟线程如何超越传统线程的行为，指出一些新的API点和有趣的用例，并观察一些实现挑战。但是，成功使用虚拟线程所需的所有内容都已经解释过了。</p><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>与必须非常通用的内核调度器不同，虚拟线程调度器可以为手头的任务定制化。虚拟线程也可以使用类似异步编程的灵活调度，不过由于线程和调度的细节被很好的隐藏起来了，你不需要了解它的工作原理，就像你不需要研究内核调度程序一样，除非你打算自己使用或编写一个定制的调度程序。这一部分完全是可选的。</p><p>在内核之外，我们不能直接访问CPU内核，所以我们使用内核线程作为接近它的一种方式:我们的调度器将虚拟线程调度到“物理”平台工作线程上。我们称调度器的工作线程为载体线程，因为它们上面承载着虚拟线程。像异步框架一样，我们最终会调度内核线程，只是我们将结果抽象为一个线程，而不是让调度的细节泄露到应用程序代码中。</p><p>当一个虚拟线程变得可运行时，调度程序将(最终)把它挂载到一个工作平台线程上，这个线程将在一段时间内成为虚拟线程的载体，并将一直运行它，直到它被取消调度——通常是在它阻塞时。然后，调度程序将从其载体中卸载该虚拟线程，并选择另一个线程进行挂载(如果有可运行的线程的话)。在虚拟线程上运行的代码无法观察其载体;<code>Thread.currentThread</code> 将始终返回当前(虚拟)线程。</p><p>默认情况下，虚拟线程由一个全局调度程序进行调度，其工作线程的数量与CPU内核的数量相同(或者显式地使用<code>-djdk.defaultscheduler = n</code> 进行设置)。大量的虚拟线程被安排在少量的平台线程上。这被称为 m: n 调度(m 用户模式线程被调度到n个内核线程上，其中 m &gt;&gt; n)。<a href="https://docs.oracle.com/cd/E19455-01/806-3461/6jck06gqe/index.html">JDK 的早期版本</a>也是在用户空间使用绿色线程实现的<code>Thread</code>; 然而，它们使用 m: 1调度，只使用一个内核线程。</p><p>工作窃取调度程序可以很好地工作于事务处理和消息传递中涉及的线程，这些线程通常以短时间爆发并经常阻塞为特点，就像我们在Java服务器应用程序中可能发现的那样。所以最初，默认的全局调度程序是具有工作窃取功能的<code>ForkJoinPool</code>。</p><p>虚拟线程是<a href="https://en.wikipedia.org/wiki/Preemption_(computing">抢占式</a>#PREEMPTIVE)的，而不是<a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">协作式</a>的ー它们在调度(任务切换)点上没有明确的等待操作。相反，当它们阻塞I/O或线程同步时，它们会被抢占。如果平台线程占用CPU的时间超过了某个分配的时间片，那么它们会被内核抢占。当活动线程的数量不超过内核数量，并且只有极少数线程处理量很大时，分时作为一种调度策略很有效。如果一个线程占用CPU太长时间，它会被抢占以使其他线程做出响应，然后它会被再次调度到另一个时间片。当我们有数百万个线程时，这种策略就不那么有效了：如果其中许多线程对CPU的需求如此之大，以至于它们需要时间共享，那么我们的资源就有几个数量级的短缺，没有任何调度策略可以拯救我们。在所有其他情况下，要么工作窃取调度器会自动消除零星的CPU占用，要么我们可以将有问题的线程作为平台线程运行，并依赖内核调度器。出于这个原因，JDK的调度器目前都没有采用基于时间片的虚拟线程抢占，但这并不是说将来不会采用——参见<a href="https://cr.openjdk.java.net/~rpressler/loom/loom/sol1_part2.html#forced-preemption">强制抢占</a>。</p><p>与今天的线程相比，您不能对调度点的位置做任何假设。即使没有强制抢占，您调用的任何JDK或库方法都可能引入阻塞，从而引入任务切换点。</p><p>虚拟线程可以使用任意的、可插拔的调度程序。一个自定义的调度程序可以在每个线程的基础上设置，例如:</p><pre><code class="java">Thread t = Thread.builder().virtual(scheduler).build();</code></pre><p>或者每个工厂，就像这样:</p><pre><code class="java">ThreadFactory tf = Thread.builder().virtual(scheduler).factory();</code></pre><p>线程从出生到消亡都被分配给调度程序。</p><p>自定义调度程序可以使用各种调度算法，甚至可以选择将其虚拟线程调度到特定的单个载体线程或一组载体线程上(尽管如果调度程序只使用一个工作线程，则更容易被<a href="https://cr.openjdk.java.net/~rpressler/loom/loom/sol1_part1.html#pinning">锁定</a>)。</p><p>定制调度器不需要知道它是用来调度虚拟线程的。它可以是实现<code>java.util.concurrent.Executor</code>的任何类型，只需要实现一个方法:<code>execute</code>。这个方法将在线程可运行时被调用，也就是说，在线程启动(started)或未停泊(unparked)时请求调度。但是传递给<code>execute</code>的可运行实例是什么呢？它是<a href="https://download.java.net/java/early_access/loom/docs/api/java.base/java/lang/Thread.VirtualThreadTask.html"><code>Thread.VirtualThreadTask</code></a>。<code>VirtualThreadTask</code>允许调度程序查询虚拟线程的身份，并将虚拟线程执行的内部保留状态包装起来。当调度器将这个<code>Runnable</code>分配给某个工作线程，然后该工作线程调用<code>run</code>方法时，该方法将装载虚拟线程并成为它的载体，虚拟线程的挂起(suspended)将被神奇地恢复，它会在载体上继续恢复执行。对于调度程序来说，<code>run</code>方法的行为看起来和其他方法一样——它看起来在同一个线程中执行(事实上，它确实在同一个内核线程中运行)，表面上是在任务终止时返回，但“内部”运行的代码会观察到它在虚拟线程中运行，当虚拟线程阻塞时，<code>run</code>会返回调度程序，使<code>VirtualThreadTask</code>处于挂起状态。你可以把VirtualThreadTask当成一种可恢复的可运行的线程包装。这就是神奇的地方。这一过程将在关于这一新的虚拟机功能的单独文档中详细解释。</p><p>调度程序绝不能在多个载体线程上并发执行 <code>VirtualThreadTask</code>。实际上，在调用同一个<code>VirtualThreadTask</code><a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-17.html#jls-17.4.5">之前</a>，必须先从<code>run</code>返回。</p><p>不管是哪种调度器，虚拟线程都具有与平台线程相同的内存一致性(由<a href="https://www.jcp.org/en/jsr/detail?id=133">Java内存模型</a>指定) ，但是定制调度器可以选择提供更强的保证。例如，使用单个工作平台线程的调度程序将使所有内存操作完全有序，不需要使用锁，并且允许使用<code>HashMap</code>代替 <code>ConcurrentHashMap</code>。然而，根据 JMM ，无竞争的线程在任何调度程序上都是无竞争的，但是依赖特定调度程序的保证可能导致该调度程序中的线程是无竞争的，而在其他调度程序中则不是。</p><h2 id="性能和占用空间"><a href="#性能和占用空间" class="headerlink" title="性能和占用空间"></a>性能和占用空间</h2><p>虚拟线程的任务切换开销以及它们的内存占用都将随着时间的推移、在第一次发布之前和之后而改善。</p><p>性能由VM挂载和卸载虚拟线程的算法以及调度程序的行为决定。对于那些希望尝试性能的用户，可以使用VM选项 <code>-XX:[-/+ ] UseContinuationChunks</code> 在两个基础算法之间进行选择。此外，缺省调度程序(<code>ForkJoinPool</code>)在线程未充分利用的情况不是最优的(提交的任务比工作线程少，即可运行的虚拟线程少) ，因此您可能需要测试缺省工作者线程池的大小(<code>-djdk.defaultscheduler = n</code>)。</p><p>内存占用主要取决于虚拟线程状态的内部VM表示(尽管比平台线程好得多，但仍不是最优的)以及线程局部变量的使用。</p><p>关于虚拟线程运行时特性的讨论最好在loom的开发邮件列表中进行。</p><h2 id="线程锁定（Pinning）"><a href="#线程锁定（Pinning）" class="headerlink" title="线程锁定（Pinning）"></a>线程锁定（Pinning）</h2><p>我们说，如果一个虚拟线程被挂载，但是处于无法卸载的状态，那么它就会被锁定到到其载体线程上。如果一个虚拟线程在锁定时阻塞，它就会阻塞它的载体线程。此行为仍然正确，但是在虚拟线程被阻塞期间，它将占用一个工作线程，使其他虚拟线程无法使用。</p><p>如果调度程序有多个工作线程，并且可以很好地利用其他工作线程，其中一些工作线程被虚拟线程锁定，偶尔的锁定是无害的。然而，过于频繁的锁定会影响吞吐量。</p><p>在当前的Loom实现中，可以在两种情况下固定一个虚拟线程: 当堆栈上有一个本地框架（native frame）时ーー当Java代码调用本地方法接口(JNI) ，然后再调用回 Java ーー以及当在一个同步块或方法中时。在这些情况下，阻塞虚拟线程将阻塞携带虚拟线程的物理线程。一旦本地方法调用完成或监视器释放(同步块/方法退出) ，线程将被取消锁定。</p><p>如果有一个普通的I/O操作由一个synchronized保护，那么将监视器替换为 <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/locks/ReentrantLock.html"><code>ReentrantLock</code></a>，即使在我们修复因监视器导致的线程锁定之前也可以让您的应用程序充分受益于Loom的可扩展性提升，(或者，如果可以的话，使用性能更高的 <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/locks/StampedLock.html"><code>StampedLock</code></a>)。</p><p>JDK 中两个常用的方法引入了一个锁定虚拟线程的本地框架: <code>AccessController.doPrivileged</code> 和 <code>Method.invoke</code> (+ 其构造函数的副本<code>Constructor.newInstance</code>)。用纯Java语言重写了<code>doPrivileged</code>。<code>Method.invoke</code>在某些迭代中使用本地调用，在预热后生成Java字节码;在Loom原型中，我们使用<code>MethodHandles</code>在Java中重新实现了它。静态类初始化器也被本机方法代码调用，但是它们运行得很少，所以我们不用担心它们。</p><p>此外，在进入<code>synchronized</code>或调用<code>Object.wait</code>时阻塞本地方法代码或试图获取不可用的监视器也会阻塞本地载体线程。</p><p><code>synchronized</code> 的局限性最终会消失，但本地框架锁定仍然存在。我们认为它不会产生任何重大的负面影响，因为这种情况在Java中很少出现，但是Loom将添加一些诊断来检测锁定线程。</p><h2 id="所有阻塞由我们来负责"><a href="#所有阻塞由我们来负责" class="headerlink" title="所有阻塞由我们来负责"></a>所有阻塞由我们来负责</h2><p>将线程表示为“纯” Java 对象是第一步。第二是让所有的代码和库都使用新的机制; 否则它们将阻塞OS线程而不是虚拟线程。幸运的是，我们不需要改变所有的库和应用程序。无论何时在Spring或Hibernate中运行阻塞操作，它最终都会使用JDK中的核心库 API ー<code>java.*</code> 包裹。JDK 控制了应用程序与操作系统或外部世界之间的所有交互点，因此我们所需要做的就是使它们适配虚拟线程。构建在JDK之上的所有内容现在都可以使用虚拟线程。具体地说，我们需要调整JDK中阻塞发生的所有点; 这些点有两种类型: 同步(想象一下锁或阻塞队列)和 I/O。特别是，当在虚拟线程上调用同步I/O操作时，我们希望阻塞虚拟线程，在底层执行异步文件文件操作，并设置它，当操作完成时，它将解除对虚拟线程的阻塞。</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><ul><li><code>synchronized/Object.wait</code>的局限见<a href="https://cr.openjdk.java.net/~rpressler/loom/loom/sol1_part1.html#pinning">线程锁定</a>。</li><li>所有其他形式的同步，通常在<code>java.util.concurrent</code>以及调用它的程序库中，使用<code>LockSupport.park/unpark</code>方法阻止和取消阻止线程。我们已经做了适配，所以<code>java.util.concurrent</code>是虚拟线程友好的。</li><li>仍然需要进一步调优<code>java.util.concurrent</code>中的策略，以获得最佳的虚拟线程性能。</li></ul><h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><ul><li><code>java.nio.channels</code> 类—— <code>SocketChannel</code>、 <code>ServerSocketChannel</code>和 <code>DatagramChannel</code> ——被改造为虚拟线程友好型。当它们的同步操作，比如<code>read</code>和<code>write</code>，在一个虚拟线程上执行时，在底层只会使用异步I/O。</li><li>“老式” I/O 网络接口ー <code>java.net.Socket</code>、 <code>ServerSocket</code> 和<code>DatagramSocket</code>已经在NIO之上的Java中重新实现，因此它立即可以从NIO 的虚拟线程友好特性中受益。</li><li>用户DNS查找的<code>java.net.InetAddress</code>的方法：<code>getHostName</code>, <code>getCanonicalHostName</code>, <code>getByName</code>仍然会委托给操作系统。因为它只提供一个操作系统线程阻塞的API。替代方案正在探索中。</li><li>进程管道也将类似地实现虚拟线程友好，除了在Windows上，这需要更大的努力。</li><li>控制台I/O也已经改装。</li><li>对<code>Http(s)URLConnection</code>以及TLS/SSL的实现进行了更改，以使其依赖于<code>j.u.c</code>锁而避免锁定。</li><li>文件I/O有问题。在内部，JDK 对文件使用缓冲 I/O，即使读取将被阻塞，它也总是报告可用。在Linux上，我们计划对异步文件I/O使用 io _ uring，同时我们正在使用  <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/ForkJoinPool.ManagedBlocker.html"><code>ForkJoinPool.ManagedBlocker</code></a>机制，通过在工作线程被阻塞时向工作线程池添加更多的操作系统线程来缓和阻塞文件I/O操作。</li></ul><p>因此，使用JDK的网络原语的库(无论是在JDK核心库中还是在其外部)也会自动变成非(OS-thread -)阻塞; 这包括JDBC驱动程序，以及HTTP客户机和服务器。</p><h2 id="调试和分析"><a href="#调试和分析" class="headerlink" title="调试和分析"></a>调试和分析</h2><p>可服务性和可观察性一直是Java平台的高优先级关注点，也是其显著特性之一。对我们来说，在第一天就拥有良好的虚拟线程调试和分析经验是很重要的，尤其是在这些方面，虚拟线程可以比异步编程提供更多的好处，而异步编程的调试和分析体验尤其糟糕，这正是它自己的显著特征。</p><p>为Java调试器使用的<a href="https://docs.oracle.com/en/java/javase/14/docs/specs/jdwp/jdwp-spec.html">Java调试器连线协议</a>(JDWP)和<a href="https://docs.oracle.com/en/java/javase/14/docs/api/jdk.jdi/com/sun/jdi/package-summary.html">Java调试器接口</a>(JDI)提供动力的调试器代理程序，支持断点、单步执行、变量检查等普通调试操作。单步执行阻塞操作的行为与预期的一样，而且单步执行不会像调试异步代码那样从一个任务跳到另一个任务，或跳到调度程序代码。在<a href="https://docs.oracle.com/en/java/javase/14/docs/specs/jvmti.html">JVM TI</a> 级别支持虚拟线程的更改为此提供了便利。我们还与IntelliJ IDEA 和NetBeans调试器团队进行合作测试在这些ide中调试虚拟线程。</p><p>在当前的EA中，并非所有的调试器操作都支持虚拟线程。一些操作带来了特殊的挑战。例如，调试器通常列出所有活动线程。如果您有一百万个线程，那么这既缓慢又无用。实际上，我们没有提供任何机制来枚举所有虚拟线程。正在探讨一些想法，比如仅列出在调试会话期间遇到某些调试器事件(如命中断点)的虚拟线程。</p><p>异步代码最大的问题之一是几乎不可能很好地分析。对于分析器来说，没有一种好的通用方法可以根据上下文对异步操作进行分组，即整理同步管道中处理传入请求的所有子任务。因此，当您尝试分析异步代码时，您经常会看到空闲线程池，即使应用程序处于负载状态，因为没有办法跟踪等待异步I/O的操作。</p><p>虚拟线程解决了这个问题，因为同步操作与它们阻塞的线程相关联(即使在底层使用异步I/O)。我们已经修改了<a href="https://blogs.oracle.com/javamagazine/java-flight-recorder-and-jfr-event-streaming-in-java-14">JDK Flight Recorder</a> (JFR)—— JDK 中分析和结构化日志的基础——以支持虚拟线程。阻塞的虚拟线程可以显示在分析器中，并且可以度量和计算在I/O上花费的时间。</p><p>另一方面，虚线程给可观测性带来了一些挑战。例如，如何理解一个100万线程的线程转储（thread dump）？我们相信<a href="https://cr.openjdk.java.net/~rpressler/loom/loom/sol1_part2.html#structure-for-serviceability-and-observability">结构化的并发</a>可以帮助解决这个问题。</p><h1 id="为什么是“虚拟”-？"><a href="#为什么是“虚拟”-？" class="headerlink" title="为什么是“虚拟” ？"></a>为什么是“虚拟” ？</h1><p>在该项目的前几次迭代中，我们将我们的轻量级用户模式线程称为“纤程” ，但发现自己反复解释说，它们不是一个新概念，而是一个熟悉的线程的不同实现。此外，这个术语已经被用于那些相似但又足够不同以至于引起混淆的结构。“绿线程”也同样受到其他实现的污染。我们考虑了非特定的“轻量级线程” ，但“轻量级”是相对的，我们设想未来的jdk拥有“微线程” ，因此我们决定采用 Brian Goetz 的建议，称它们为“虚拟线程” ，这在会议上也得到了很好的测试。这个名字是为了唤起与虚拟内存的联系: 通过将虚拟结构映射到具体结构(物理内存、 OS 线程)上，我们得到了更多的东西(地址空间、线程)。</p><h1 id="第二部分：进一步的工作"><a href="#第二部分：进一步的工作" class="headerlink" title="第二部分：进一步的工作"></a>第二部分：进一步的工作</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文是&lt;a href=&quot;https://cr.openjdk.java.net/~rpressler/loom/loom/sol1_part1.html&quot;&gt;State of Loom&lt;/a&gt;的翻译。&lt;/p&gt;
&lt;p&gt;Loom 项目旨在大大减少编写、维护和观察高吞吐量并发应用程
      
    
    </summary>
    
      <category term="技术人生" scheme="https://pingao777.github.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="Java" scheme="https://pingao777.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>简明Java反射教程1：类（Classes）</title>
    <link href="https://pingao777.github.io/2020/03/07/%E7%AE%80%E6%98%8EJava%E5%8F%8D%E5%B0%84%E6%95%99%E7%A8%8B1%EF%BC%9A%E7%B1%BB%EF%BC%88Classes/"/>
    <id>https://pingao777.github.io/2020/03/07/简明Java反射教程1：类（Classes/</id>
    <published>2020-03-07T03:44:19.000Z</published>
    <updated>2020-09-12T03:14:00.591Z</updated>
    
    <content type="html"><![CDATA[<p>Java反射历来是迈入高级Java开发者的必备科目，网上教程是五花八门，有的失于不够全面，有的失于谬误百出。看过之后不懂的更不懂了，懂得也有点蒙了，偶然看到Oracle的官方教程页面，仿佛打开了新的世界，里面的教程不仅简明易懂而且非常权威，毕竟是官方出品，里面有篇<a href="https://docs.oracle.com/javase/tutorial/reflect/index.html">反射</a>教程，非常不错，翻译一下，推荐给大家。由于篇幅相对于一篇博客来说还是有点长了，我将其分为三个部分：类､成员以及数组和枚举类型。本篇是第一篇，类的反射。</p><h2 id="反射用途"><a href="#反射用途" class="headerlink" title="反射用途"></a>反射用途</h2><p>反射通常用来修改Java虚拟机应用程序的运行时行为。这是一个相对高级的功能，只应由对语言基础有很深了解的开发人员使用。考虑到这一点，反射是一种强大的技术，可以使应用程序执行原本不可能的操作。</p><h3 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h3><p>应用程序可以通过使用其完全限定名创建外部用户定义类的实例。</p><h3 id="类浏览器和可视化开发环境"><a href="#类浏览器和可视化开发环境" class="headerlink" title="类浏览器和可视化开发环境"></a>类浏览器和可视化开发环境</h3><p>类浏览器需要枚举类的成员。可视化开发环境可以利用反射中可用的类型信息来帮助开发人员编写正确的代码。</p><h3 id="调试和测试工具"><a href="#调试和测试工具" class="headerlink" title="调试和测试工具"></a>调试和测试工具</h3><p>调试工具需要检查类的私有成员。测试工具可以利用反射来系统地调用在类上定义的可发现的API集合，以确保代码的高覆盖率。</p><h2 id="反射弊端"><a href="#反射弊端" class="headerlink" title="反射弊端"></a>反射弊端</h2><p>反射功能强大，但不应任意使用。如果可以在不使用反射的情况下实现需要的操作，那么最好避免使用它。通过反射访问代码时应牢记以下问题。</p><h3 id="性能开销"><a href="#性能开销" class="headerlink" title="性能开销"></a>性能开销</h3><p>由于反射涉及动态解析的类型，因此无法执行某些Java虚拟机优化。因此，反射操作的性能要比非反射操作慢，因此，在性能敏感的应用程序中经常调用的代码段中，应避免使用反射。</p><h3 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h3><p>反射需要运行时许可，而在安全管理器下运行时可能不存在这种许可。对于必须在受限的安全上下文（例如Applet）中运行的代码，这是一个重要的考虑因素。</p><h3 id="内部暴露"><a href="#内部暴露" class="headerlink" title="内部暴露"></a>内部暴露</h3><p>由于反射允许执行在非反射代码中非法的操作，例如访问私有字段和方法，因此使用反射可能会导致意外的副作用，这可能会使代码无法正常工作并可能破坏可移植性。反射代码破坏了抽象，因此可能会随着平台的升级而改变行为。</p><h2 id="教程章节"><a href="#教程章节" class="headerlink" title="教程章节"></a>教程章节</h2><p>本教程涵盖了反射在访问和操作类、字段、方法和构造函数方面的常见用法。每节课均包含代码示例，技巧和故障排除信息。</p><p>主要章节为：</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/reflect/class/index.html"><strong>类</strong></a></li><li><a href="https://docs.oracle.com/javase/tutorial/reflect/member/index.html"><strong>成员</strong></a></li><li><a href="https://docs.oracle.com/javase/tutorial/reflect/special/index.html"><strong>数组和枚举类型</strong></a></li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>本课说明了获取<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>对象并使用它检查类的属性的各种方法，包括其声明和内容。</p><p>类型要么是引用类型，要么是原始类型。类，枚举和数组（都继承自<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html"><code>java.lang.Object</code></a>）以及接口都是引用类型。引用类型包括<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html"><code>java.lang.String</code></a>，原始类型的所有包装器类，例如<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html"><code>java.lang.Double</code></a>，接口 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html"><code>java.io.Serializable</code></a>和枚举<a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/SortOrder.html"><code>javax.swing.SortOrder</code></a>。原始类型有：布尔值(<code>boolean</code>)，字节(<code>byte</code>)，短型(<code>short</code>)，整数(<code>int</code>)，长型(<code>long</code>)，字符(<code>char</code>)，浮点型(<code>float</code>)和双精度型(<code>double</code>)。</p><p>对于每种类型的对象，Java虚拟机都会实例化一个不可变的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>java.lang.Class</code></a>实例，该实例提供检查对象的运行时属性（包括其成员和类型信息）的方法。<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>还提供了创建类和对象的能力。最重要的是，它是所有反射API的入口点。本课涵盖了涉及类的最常见的反射操作：</p><ul><li>获取类对象描述了获取类的方式。</li><li>检查类修饰符和类型显示如何访问类声明信息。</li><li>发现类成员说明了如何在类中列出构造函数，字段，方法和嵌套类。</li><li>故障排除描述了使用类时遇到的常见错误。</li></ul><h4 id="获取类对象"><a href="#获取类对象" class="headerlink" title="获取类对象"></a>获取类对象</h4><p>所有反射操作的入口点是<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>java.lang.Class</code></a>。除了<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/ReflectPermission.html"><code>java.lang.reflect.ReflectPermission</code></a>之外，<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html"><code>java.lang.reflect</code></a>包下的所有类都没有公共构造函数。要获得这些类，必须在<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>上调用相应的方法。根据代码是否可以访问对象，类的名称，类型或现有的类，有几种获取类的方法。</p><h5 id="Object-getClass"><a href="#Object-getClass" class="headerlink" title="Object.getClass()"></a><code>Object.getClass()</code></h5><p>如果对象的实例可用，则获取其类的最简单方法是调用<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass--"><code>Object.getClass()</code></a>。当然，这仅适用于全部继承自<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html"><code>Object</code></a>的引用类型。以下是一些示例。</p><pre><code class="java">Class c = &quot;foo&quot;.getClass();</code></pre><p>返回字符串(<code>String</code>)的类(<code>Class</code>)</p><pre><code class="java">Class c = System.console().getClass();</code></pre><p>与虚拟机关联的唯一控制台由静态方法<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#console--"><code>System.console()</code></a>返回。<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass--"><code>getClass()</code></a>返回的值是与<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass--"><code>getClass()</code></a>对应的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>。</p><pre><code class="java">enum E &#123; A, B &#125;Class c = A.getClass();</code></pre><p><code>A</code>是枚举<code>E</code>的实例；因此，<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass--"><code>getClass()</code></a>返回与枚举类型<code>E</code>相对应的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>。</p><pre><code class="java">byte[] bytes = new byte[1024];Class c = bytes.getClass();</code></pre><p>由于数组是对象(<code>Object</code>)，因此也可以在数组的实例上调用<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass--"><code>getClass()</code></a>。返回的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>对应于组件类型为<code>byte</code>的数组。</p><pre><code class="java">import java.util.HashSet;import java.util.Set;Set&lt;String&gt; s = new HashSet&lt;String&gt;();Class c = s.getClass();</code></pre><p>在这种情况下，<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html"><code>java.util.Set</code></a>是类型为<a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html"><code>java.util.HashSet</code></a>的对象的接口。<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass--"><code>getClass()</code></a>返回的值是对应于<a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html"><code>java.util.HashSet</code></a>的类。</p><h5 id="class"><a href="#class" class="headerlink" title=".class"></a><code>.class</code></h5><p>如果类的实例不可用，那么可以使用<code>.class</code>的方式获取<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>。这也是基本类型获取<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>最简单的方式。</p><pre><code class="java">boolean b;Class c = b.getClass();   // compile-time errorClass c = boolean.class;  // correct</code></pre><p>请注意，语句<code>boolean.getClass()</code>会产生编译时错误，因为布尔值是基本类型且无法取消引用。<code>.class</code>语法返回与布尔类型相对应的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>。</p><pre><code class="java">Class c = java.io.PrintStream.class;</code></pre><p>变量<code>c</code>是与类型<a href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html"><code>java.io.PrintStream</code></a>对应的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>。</p><pre><code class="java">Class c = int[][][].class;</code></pre><p><code>.class</code>语法可用于获取多维数组相对应的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>。</p><h5 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName()"></a><code>Class.forName()</code></h5><p>如果一个类的完全限定名可用，可以使用静态方法<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#forName-java.lang.String-"><code>Class.forName()</code></a>获取相应的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>。数组的完全限定名不能用于基本类型。数组的限定名可以使用<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getName--"><code>Class.getName()</code></a>获取。<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getName--"><code>Class.getName()</code></a>适用于引用和基本类型。</p><pre><code class="java">Class c = Class.forName(&quot;com.duke.MyLocaleServiceProvider&quot;);</code></pre><p>该语句将从给定的完全限定名称创建一个类。</p><pre><code class="java">Class cDoubleArray = Class.forName(&quot;[D&quot;);Class cStringArray = Class.forName(&quot;[[Ljava.lang.String;&quot;);</code></pre><p>变量<code>cDoubleArray</code>对应于基本类型为<code>double</code>的数组的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>（即与<code>double[].class</code>相同）。变量<code>cStringArray</code>对应<code>String</code>二维数组的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>（和<code>String[][].class</code>一样）。</p><h5 id="基本类型包装类的类型"><a href="#基本类型包装类的类型" class="headerlink" title="基本类型包装类的类型"></a>基本类型包装类的类型</h5><p>对于基本类型，<code>.class</code>是最容易的一种方式，不过还有一种方式可以获取<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>。每个基本类型和<code>void</code>在<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/package-summary.html"><code>java.lang</code></a>中都有一个包装器类，用于将原始类型装箱到引用类型。每个包装器类都包含一个名为<code>TYPE</code>的字段，该字段对应于包装的基本类型的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>。</p><pre><code class="java">Class c = Double.TYPE;</code></pre><p>有一个类<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html"><code>java.lang.Double</code></a>，用于在需要<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html"><code>Object</code></a>时包装基本类型<code>double</code>。 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#TYPE"><code>Double.TYPE</code></a>的值与<code>double.class</code>的值相同。</p><pre><code class="java">Class c = Void.TYPE;</code></pre><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Void.html#TYPE"><code>Void.TYPE</code></a>与<code>void.class</code>相同。</p><h5 id="返回Class的方法"><a href="#返回Class的方法" class="headerlink" title="返回Class的方法"></a>返回<code>Class</code>的方法</h5><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getSuperclass--"><code>Class.getSuperclass()</code></a></p><p>返回给定类的超类。</p><pre><code class="java">Class c = javax.swing.JButton.class.getSuperclass();</code></pre><p><code>javax.swing.JButton</code>的超类是<code>javax.swing.AbstractButton</code>。</p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getClasses--"><code>Class.getClasses()</code></a></p><p>返回属于该类成员的所有公共类，接口和枚举，包括继承的成员。</p><pre><code class="java">Class&lt;?&gt;[] c = Character.class.getClasses();</code></pre><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html"><code>Character</code></a> 包含两个成员类 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.Subset.html"><code>Character.Subset</code></a> 和<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.UnicodeBlock.html"><code>Character.UnicodeBlock</code></a>。</p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredClasses--"><code>Class.getDeclaredClasses()</code></a></p><p>返回所有类接口，以及在该类中显式声明的枚举。</p><pre><code class="java">Class&lt;?&gt;[] c = Character.class.getDeclaredClasses();</code></pre><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html"><code>Character</code></a>包含两个公共成员类： <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.Subset.html"><code>Character.Subset</code></a>和<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.UnicodeBlock.html"><code>Character.UnicodeBlock</code></a>，一个私有类：<code>Character.CharacterCache</code>。</p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaringClass--"><code>Class.getDeclaringClass()</code></a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html#getDeclaringClass--"><code>java.lang.reflect.Field.getDeclaringClass()</code></a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#getDeclaringClass--"><code>java.lang.reflect.Method.getDeclaringClass()</code></a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Constructor.html#getDeclaringClass--"><code>java.lang.reflect.Constructor.getDeclaringClass()</code></a></p><p>返回这些成员的声明类。 匿名类没有声明类但但有封闭类。</p><pre><code class="java">import java.lang.reflect.Field;Field f = System.class.getField(&quot;out&quot;);Class c = f.getDeclaringClass(); // System</code></pre><p>字段 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#out"><code>out</code></a>是在<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html"><code>System</code></a>中声明的。</p><pre><code class="java">public class MyClass &#123;    static Object o = new Object() &#123;        public void m() &#123;&#125;     &#125;;    static Class&lt;c&gt; = o.getClass().getEnclosingClass();&#125;</code></pre><p><code>o</code>代表的匿名类的声明类为<code>null</code>。</p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getEnclosingClass--"><code>Class.getEnclosingClass()</code></a></p><p>返回该类的直接封闭类。</p><pre><code class="java">Class c = Thread.State.class().getEnclosingClass();</code></pre><p>枚举<code>Thread.State</code>的封闭类是<code>Thread</code>。</p><pre><code class="java">public class MyClass &#123;    static Object o = new Object() &#123;         public void m() &#123;&#125;     &#125;;    static Class&lt;c&gt; = o.getClass().getEnclosingClass();&#125;</code></pre><p><code>o</code>定义的匿名类包含在<code>MyClass</code>中。</p><h4 id="检查类的修饰符和类型"><a href="#检查类的修饰符和类型" class="headerlink" title="检查类的修饰符和类型"></a>检查类的修饰符和类型</h4><p>一个类在声明时可能会有一个或多个修饰符影响它的运行时行为：</p><ul><li>访问修饰符：<code>public</code>,<code>protected</code>,<code>private</code></li><li>需要覆盖的修饰符：<code>abstract</code></li><li>仅限一个实例的修饰符：<code>static</code></li><li>禁止修改值的修饰符：<code>final</code></li><li>执行严格浮点行为的修饰符：<code>strictfp</code></li><li>注解</li></ul><p>并非所有类都允许使用所有修饰符，例如，接口不能为<code>final</code>，而枚举不能为<code>abstract</code>。<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Modifier.html"><code>java.lang.reflect.Modifier</code></a>包含所有可能的修饰符的声明。它还包含用于解码<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getModifiers--"><code>Class.getModifiers()</code></a>返回的修饰符集的方法。</p><p><a href="https://docs.oracle.com/javase/tutorial/reflect/class/example/ClassDeclarationSpy.java"><code>ClassDeclarationSpy</code></a>示例演示如何获取类的声明组件，包括修饰符，泛型类型参数，已实现的接口和继承路径。由于<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a> 实现了<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html"><code>java.lang.reflect.AnnotatedElement</code></a>接口，因此也可以查询运行时注解。</p><pre><code class="java">import java.lang.annotation.Annotation;import java.lang.reflect.Modifier;import java.lang.reflect.Type;import java.lang.reflect.TypeVariable;import java.util.Arrays;import java.util.ArrayList;import java.util.List;import static java.lang.System.out;public class ClassDeclarationSpy &#123;    public static void main(String... args) &#123;        try &#123;            Class&lt;?&gt; c = Class.forName(args[0]);            out.format(&quot;Class:%n  %s%n%n&quot;, c.getCanonicalName());            out.format(&quot;Modifiers:%n  %s%n%n&quot;,                   Modifier.toString(c.getModifiers()));            out.format(&quot;Type Parameters:%n&quot;);            TypeVariable[] tv = c.getTypeParameters();            if (tv.length != 0) &#123;            out.format(&quot;  &quot;);            for (TypeVariable t : tv)                out.format(&quot;%s &quot;, t.getName());            out.format(&quot;%n%n&quot;);            &#125; else &#123;            out.format(&quot;  -- No Type Parameters --%n%n&quot;);            &#125;            out.format(&quot;Implemented Interfaces:%n&quot;);            Type[] intfs = c.getGenericInterfaces();            if (intfs.length != 0) &#123;            for (Type intf : intfs)                out.format(&quot;  %s%n&quot;, intf.toString());            out.format(&quot;%n&quot;);            &#125; else &#123;            out.format(&quot;  -- No Implemented Interfaces --%n%n&quot;);            &#125;            out.format(&quot;Inheritance Path:%n&quot;);            List&lt;Class&gt; l = new ArrayList&lt;Class&gt;();            printAncestor(c, l);            if (l.size() != 0) &#123;            for (Class&lt;?&gt; cl : l)                out.format(&quot;  %s%n&quot;, cl.getCanonicalName());            out.format(&quot;%n&quot;);            &#125; else &#123;            out.format(&quot;  -- No Super Classes --%n%n&quot;);            &#125;            out.format(&quot;Annotations:%n&quot;);            Annotation[] ann = c.getAnnotations();            if (ann.length != 0) &#123;            for (Annotation a : ann)                out.format(&quot;  %s%n&quot;, a.toString());            out.format(&quot;%n&quot;);            &#125; else &#123;            out.format(&quot;  -- No Annotations --%n%n&quot;);            &#125;            // production code should handle this exception more gracefully        &#125; catch (ClassNotFoundException x) &#123;            x.printStackTrace();        &#125;    &#125;    private static void printAncestor(Class&lt;?&gt; c, List&lt;Class&gt; l) &#123;        Class&lt;?&gt; ancestor = c.getSuperclass();        if (ancestor != null) &#123;            l.add(ancestor);            printAncestor(ancestor, l);        &#125;    &#125;&#125;</code></pre><p>下面是输出的一些样本。用户输入以斜体显示。</p><p>$ <em><code>java ClassDeclarationSpy java.util.concurrent.ConcurrentNavigableMap</code></em></p><pre><code>Class:  java.util.concurrent.ConcurrentNavigableMapModifiers:  public abstract interfaceType Parameters:  K VImplemented Interfaces:  java.util.concurrent.ConcurrentMap&lt;K, V&gt;  java.util.NavigableMap&lt;K, V&gt;Inheritance Path:  -- No Super Classes --Annotations:  -- No Annotations --</code></pre><p>这是实际的源代码 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentNavigableMap.html"><code>java.util.concurrent.ConcurrentNavigableMap</code></a>中的实际声明：</p><pre><code class="java">public interface ConcurrentNavigableMap&lt;K,V&gt;    extends ConcurrentMap&lt;K,V&gt;, NavigableMap&lt;K,V&gt;</code></pre><p>注意，由于这是一个接口，因此它是隐式<code>abstract</code>的。编译器为每个接口添加此修饰符。另外，此声明包含两个泛型参数K和V。示例代码仅打印这些参数的名称，但是可以使用<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/TypeVariable.html"><code>java.lang.reflect.TypeVariable</code></a>中的方法获取有关它们的其他信息。接口也可以实现其他接口，如上所示。</p><p>$ <em><code>java ClassDeclarationSpy &quot;[Ljava.lang.String;&quot;</code></em></p><pre><code>Class:  java.lang.String[]Modifiers:  public abstract finalType Parameters:  -- No Type Parameters --Implemented Interfaces:  interface java.lang.Cloneable  interface java.io.SerializableInheritance Path:  java.lang.ObjectAnnotations:  -- No Annotations --</code></pre><p>由于数组是运行时对象，因此所有类型信息均由Java虚拟机定义。特别是，数组实现 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Cloneable.html"><code>Cloneable</code></a>和 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html"><code>java.io.Serializable</code></a> ，其直接超类始终是<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html"><code>Object</code></a>。</p><p>$ <em><code>java ClassDeclarationSpy java.io.InterruptedIOException</code></em></p><pre><code>Class:  java.io.InterruptedIOExceptionModifiers:  publicType Parameters:  -- No Type Parameters --Implemented Interfaces:  -- No Implemented Interfaces --Inheritance Path:  java.io.IOException  java.lang.Exception  java.lang.Throwable  java.lang.ObjectAnnotations:  -- No Annotations --</code></pre><p>从继承路径可以推断出<a href="https://docs.oracle.com/javase/8/docs/api/java/io/InterruptedIOException.html"><code>java.io.InterruptedIOException</code></a>是一个检查的异常，因为<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html"><code>RuntimeException</code></a> 没有出现。</p><p>$ <em><code>java ClassDeclarationSpy java.security.Identity</code></em></p><pre><code>Class:  java.security.IdentityModifiers:  public abstractType Parameters:  -- No Type Parameters --Implemented Interfaces:  interface java.security.Principal  interface java.io.SerializableInheritance Path:  java.lang.ObjectAnnotations:  @java.lang.Deprecated()</code></pre><p>输出表明<a href="https://docs.oracle.com/javase/8/docs/api/java/security/Identity.html"><code>java.security.Identity</code></a>拥有注释<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html"><code>java.lang.Deprecated</code></a>是一个不推荐使用的API。反射代码可以使用它来检测已弃用的API。</p><p>注意：并非所有注释都可以通过反射获得。只有具有<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/RetentionPolicy.html#RUNTIME"><code>RUNTIME</code></a>的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/RetentionPolicy.html"><code>java.lang.annotation.RetentionPolicy</code></a>的那些注解才可访问。在 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html"><code>@Deprecated</code></a>，<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Override.html"><code>@Override</code></a>和<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/SuppressWarnings.html"><code>@SuppressWarnings</code></a>语言中预定义的三个注释中，只有<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html"><code>@Deprecated</code></a>在运行时可用。</p><h4 id="发现类成员"><a href="#发现类成员" class="headerlink" title="发现类成员"></a>发现类成员</h4><p>类提供了用于访问字段，方法和构造函数的两类方法：枚举这些成员的方法和搜索特定成员的方法。与在超接口和超类中搜索继承的成员的方法相比，直接在类上访问成员方法不太一样。下表总结了所有成员定位方法及其特点。</p><p>定位字段的类方法</p><table><thead><tr><th>Class API</th><th>是否成员列表？</th><th>是否包含继承成员？</th><th>是否包含私有成员？</th></tr></thead><tbody><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredField-java.lang.String-"><code>getDeclaredField()</code></a></td><td>否</td><td>否</td><td>是</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getField-java.lang.String-"><code>getField()</code></a></td><td>否</td><td>是</td><td>否</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredFields--"><code>getDeclaredFields()</code></a></td><td>是</td><td>否</td><td>是</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getFields--"><code>getFields()</code></a></td><td>是</td><td>是</td><td>否</td></tr></tbody></table><p>定位方法的类方法</p><table><thead><tr><th>Class API</th><th>是否成员列表？</th><th>是否包含继承成员？</th><th>是否包含私有成员？</th></tr></thead><tbody><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredMethod-java.lang.String-java.lang.Class...-"><code>getDeclaredMethod()</code></a></td><td>否</td><td>否</td><td>是</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getMethod-java.lang.String-java.lang.Class...-"><code>getMethod()</code></a></td><td>否</td><td>是</td><td>否</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredMethods--"><code>getDeclaredMethods()</code></a></td><td>是</td><td>否</td><td>是</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getMethods--"><code>getMethods()</code></a></td><td>是</td><td>是</td><td>否</td></tr></tbody></table><p>定位构造方法的类方法</p><table><thead><tr><th>Class API</th><th>是否成员列表？</th><th>是否包含继承成员？</th><th>是否包含私有成员？</th></tr></thead><tbody><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredConstructor-java.lang.Class...-"><code>getDeclaredConstructor()</code></a></td><td>否</td><td>N/A</td><td>是</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getConstructor-java.lang.Class...-"><code>getConstructor()</code></a></td><td>否</td><td>N/A</td><td>否</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredConstructors--"><code>getDeclaredConstructors()</code></a></td><td>是</td><td>N/A</td><td>是</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getConstructors--"><code>getConstructors()</code></a></td><td>是</td><td>N/A</td><td>否</td></tr></tbody></table><blockquote><p>N/A：构造函数不能继承。</p></blockquote><p>给定一个类名并指出感兴趣的成员，<a href="https://docs.oracle.com/javase/tutorial/reflect/class/example/ClassSpy.java"><code>ClassSpy</code></a>示例使用<code>get*s()</code>方法确定所有公共成员的列表，包括任何继承的成员。</p><pre><code class="java">import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Member;import static java.lang.System.out;enum ClassMember &#123; CONSTRUCTOR, FIELD, METHOD, CLASS, ALL &#125;public class ClassSpy &#123;    public static void main(String... args) &#123;    try &#123;        Class&lt;?&gt; c = Class.forName(args[0]);        out.format(&quot;Class:%n  %s%n%n&quot;, c.getCanonicalName());        Package p = c.getPackage();        out.format(&quot;Package:%n  %s%n%n&quot;,               (p != null ? p.getName() : &quot;-- No Package --&quot;));        for (int i = 1; i &lt; args.length; i++) &#123;        switch (ClassMember.valueOf(args[i])) &#123;        case CONSTRUCTOR:            printMembers(c.getConstructors(), &quot;Constructor&quot;);            break;        case FIELD:            printMembers(c.getFields(), &quot;Fields&quot;);            break;        case METHOD:            printMembers(c.getMethods(), &quot;Methods&quot;);            break;        case CLASS:            printClasses(c);            break;        case ALL:            printMembers(c.getConstructors(), &quot;Constuctors&quot;);            printMembers(c.getFields(), &quot;Fields&quot;);            printMembers(c.getMethods(), &quot;Methods&quot;);            printClasses(c);            break;        default:            assert false;        &#125;        &#125;        // production code should handle these exceptions more gracefully    &#125; catch (ClassNotFoundException x) &#123;        x.printStackTrace();    &#125;    &#125;    private static void printMembers(Member[] mbrs, String s) &#123;        out.format(&quot;%s:%n&quot;, s);        for (Member mbr : mbrs) &#123;            if (mbr instanceof Field)            out.format(&quot;  %s%n&quot;, ((Field)mbr).toGenericString());            else if (mbr instanceof Constructor)            out.format(&quot;  %s%n&quot;, ((Constructor)mbr).toGenericString());            else if (mbr instanceof Method)            out.format(&quot;  %s%n&quot;, ((Method)mbr).toGenericString());        &#125;        if (mbrs.length == 0)            out.format(&quot;  -- No %s --%n&quot;, s);        out.format(&quot;%n&quot;);    &#125;    private static void printClasses(Class&lt;?&gt; c) &#123;        out.format(&quot;Classes:%n&quot;);        Class&lt;?&gt;[] clss = c.getClasses();        for (Class&lt;?&gt; cls : clss)            out.format(&quot;  %s%n&quot;, cls.getCanonicalName());        if (clss.length == 0)            out.format(&quot;  -- No member interfaces, classes, or enums --%n&quot;);        out.format(&quot;%n&quot;);    &#125;&#125;</code></pre><p>这个例子比较紧凑。但是<code>printMembers()</code>方法有点尴尬，因为反射最早的实现中就存在<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Member.html"><code>java.lang.reflect.Member</code></a>接口了，所以后来引入泛型时无法对其进行修改以包含更有用的<code>getGenericString()</code>方法。唯一的选择就是如上面那样进行测试和转换，使用独立的方法如<code>printConstructors()</code>、<code>printFields()</code>、<code>printMethods()</code>进行打印。</p><p>输出样本及其解释如下。用户输入以斜体显示。</p><p>$ <em><code>java ClassSpy java.lang.ClassCastException CONSTRUCTOR</code></em></p><pre><code>Class:  java.lang.ClassCastExceptionPackage:  java.langConstructor:  public java.lang.ClassCastException()  public java.lang.ClassCastException(java.lang.String)</code></pre><p>由于构造函数不能继承，因此找不到在直接超类<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html"><code>RuntimeException</code></a>和其他超类中定义的异常链接机制构造函数（具有 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html"><code>Throwable</code></a>参数的那些）。</p><p>$ <em><code>java ClassSpy java.nio.channels.ReadableByteChannel METHOD</code></em></p><pre><code>Class:  java.nio.channels.ReadableByteChannelPackage:  java.nio.channelsMethods:  public abstract int java.nio.channels.ReadableByteChannel.read    (java.nio.ByteBuffer) throws java.io.IOException  public abstract void java.nio.channels.Channel.close() throws    java.io.IOException  public abstract boolean java.nio.channels.Channel.isOpen()</code></pre><p> <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/ReadableByteChannel.html"><code>java.nio.channels.ReadableByteChannel</code></a>定义了<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/ReadableByteChannel.html#read-java.nio.ByteBuffer-"><code>read()</code></a>方法。其余方法是从超接口继承的。通过将<code>get * s()</code>替换为<code>getDeclared * s()</code>，这个代码稍作修改，就可以只列出那些在类中实际声明的方法。</p><p>$ <em><code>java ClassSpy ClassMember FIELD METHOD</code></em></p><pre><code>Class:  ClassMemberPackage:  -- No Package --Fields:  public static final ClassMember ClassMember.CONSTRUCTOR  public static final ClassMember ClassMember.FIELD  public static final ClassMember ClassMember.METHOD  public static final ClassMember ClassMember.CLASS  public static final ClassMember ClassMember.ALLMethods:  public static ClassMember ClassMember.valueOf(java.lang.String)  public static ClassMember[] ClassMember.values()  public final int java.lang.Enum.hashCode()  public final int java.lang.Enum.compareTo(E)  public int java.lang.Enum.compareTo(java.lang.Object)  public final java.lang.String java.lang.Enum.name()  public final boolean java.lang.Enum.equals(java.lang.Object)  public java.lang.String java.lang.Enum.toString()  public static &lt;T&gt; T java.lang.Enum.valueOf    (java.lang.Class&lt;T&gt;,java.lang.String)  public final java.lang.Class&lt;E&gt; java.lang.Enum.getDeclaringClass()  public final int java.lang.Enum.ordinal()  public final native java.lang.Class&lt;?&gt; java.lang.Object.getClass()  public final native void java.lang.Object.wait(long) throws    java.lang.InterruptedException  public final void java.lang.Object.wait(long,int) throws    java.lang.InterruptedException  public final void java.lang.Object.wait() hrows java.lang.InterruptedException  public final native void java.lang.Object.notify()  public final native void java.lang.Object.notifyAll()</code></pre><p>在上面结果的field部分中，枚举的常量值都列了出来。While these are technically fields, it might be useful to distinguish them from other fields.可以使用<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html#isEnumConstant--"><code>java.lang.reflect.Field.isEnumConstant()</code></a>达到这个木得。本教程的后续部分<a href="https://docs.oracle.com/javase/tutorial/reflect/special/enumMembers.html">Examining Enums</a>中示例<a href="https://docs.oracle.com/javase/tutorial/reflect/special/example/EnumSpy.java"><code>EnumSpy</code></a>给出了一个可能的实现。</p><p>在结果的method部分，包含声明类的方法名。因此方法<code>toString()</code>是在<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html#toString--"><code>Enum</code></a>中实现的，而不是继承自<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html"><code>Object</code></a>。通过使用<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html#getDeclaringClass--"><code>Field.getDeclaringClass()</code></a>，可以对代码进行修改以使其更加明显。以下片段说明了潜在解决方案的一部分。</p><pre><code class="java">if (mbr instanceof Field) &#123;    Field f = (Field)mbr;    out.format(&quot;  %s%n&quot;, f.toGenericString());    out.format(&quot;  -- declared in: %s%n&quot;, f.getDeclaringClass());&#125;</code></pre><h4 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h4><p>以下示例显示了在类上使用反射时可能会遇到的典型错误。</p><h5 id="编译器警告：”Note-…-uses-unchecked-or-unsafe-operations”"><a href="#编译器警告：”Note-…-uses-unchecked-or-unsafe-operations”" class="headerlink" title="编译器警告：”Note: … uses unchecked or unsafe operations”"></a>编译器警告：”Note: … uses unchecked or unsafe operations”</h5><p>调用方法时，将检查并可能转换参数值的类型。 <a href="https://docs.oracle.com/javase/tutorial/reflect/class/example/ClassWarning.java"><code>ClassWarning</code></a> 调用<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getMethod-java.lang.String-java.lang.Class...-"><code>getMethod()</code></a>会造成一个未受检异常。</p><pre><code class="java">import java.lang.reflect.Method;public class ClassWarning &#123;    void m() &#123;        try &#123;            Class c = ClassWarning.class;            Method m = c.getMethod(&quot;m&quot;);  // warning            // production code should handle this exception more gracefully        &#125; catch (NoSuchMethodException x) &#123;            x.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>$ <em><code>javac ClassWarning.java</code></em></p><pre><code>Note: ClassWarning.java uses unchecked or unsafe operations.Note: Recompile with -Xlint:unchecked for details.</code></pre><p>$ <em><code>javac -Xlint:unchecked ClassWarning.java</code></em></p><pre><code>ClassWarning.java:6: warning: [unchecked] unchecked call to getMethod  (String,Class&lt;?&gt;...) as a member of the raw type ClassMethod m = c.getMethod(&quot;m&quot;);  // warning                      ^1 warning</code></pre><p>很多库的方法已经使用泛型声明进行了改进。由于<code>c</code>被声明为原始类型（没有类型参数），而<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getMethod-java.lang.String-java.lang.Class...-"><code>getMethod()</code></a>的相应参数是参数化类型，因此发生了未经检查的转换。需要编译器生成警告（参见<a href="https://docs.oracle.com/javase/specs/jls/se7/html/index.html"><em>The Java Language Specification, Java SE 7 Edition</em></a>的<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.9">Unchecked Conversion</a> 和 <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.3">Method Invocation Conversion</a>部分）</p><p>有两种可能的解决方案。最好修改c的声明以包含适当的泛型类型。在这种情况下，声明应为：</p><pre><code class="java">Class&lt;?&gt; c = warn.getClass();</code></pre><p>或者，可以使用预定义的注解<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/SuppressWarnings.html"><code>@SuppressWarnings</code></a>放置在问题语句的前面来明确禁止警告。</p><pre><code class="java">Class c = ClassWarning.class;@SuppressWarnings(&quot;unchecked&quot;)Method m = c.getMethod(&quot;m&quot;);  // warning gone</code></pre><blockquote><p>Tip：作为一般原则，不应忽略警告，因为警告可能表明存在错误。应适当使用参数化的声明。如果这是不可能的（也许是因为应用程序必须与库供应商的代码进行交互），请使用 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/SuppressWarnings.html"><code>@SuppressWarnings</code></a>注释违规行。</p></blockquote><h5 id="构造函数不可访问时的InstantiationException"><a href="#构造函数不可访问时的InstantiationException" class="headerlink" title="构造函数不可访问时的InstantiationException"></a>构造函数不可访问时的InstantiationException</h5><p>如果尝试创建该类的新实例并且零参数构造函数不可见，则<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#newInstance--"><code>Class.newInstance()</code></a>将引发<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/InstantiationException.html"><code>InstantiationException</code></a>。 <a href="https://docs.oracle.com/javase/tutorial/reflect/class/example/ClassTrouble.java"><code>ClassTrouble</code></a>示例说明了生成的堆栈记录。</p><pre><code class="java">class Cls &#123;    private Cls() &#123;&#125;&#125;public class ClassTrouble &#123;    public static void main(String... args) &#123;    try &#123;        Class&lt;?&gt; c = Class.forName(&quot;Cls&quot;);        c.newInstance();  // InstantiationException        // production code should handle these exceptions more gracefully    &#125; catch (InstantiationException x) &#123;        x.printStackTrace();    &#125; catch (IllegalAccessException x) &#123;        x.printStackTrace();    &#125; catch (ClassNotFoundException x) &#123;        x.printStackTrace();    &#125;    &#125;&#125;</code></pre><p>$ <em><code>java ClassTrouble</code></em></p><pre><code>java.lang.IllegalAccessException: Class ClassTrouble can not access a member of  class Cls with modifiers &quot;private&quot;        at sun.reflect.Reflection.ensureMemberAccess(Reflection.java:65)        at java.lang.Class.newInstance0(Class.java:349)        at java.lang.Class.newInstance(Class.java:308)        at ClassTrouble.main(ClassTrouble.java:9)</code></pre><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#newInstance--"><code>Class.newInstance()</code></a>行为非常类似于new关键字，new失败方法也会失败。反射中的典型解决方案是利用<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AccessibleObject.html"><code>java.lang.reflect.AccessibleObject</code></a>类，该类提供了抑制访问控制检查的功能。但是这种方法不适用于本例，因为<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>java.lang.Class</code></a>没有继承<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AccessibleObject.html"><code>AccessibleObject</code></a>。唯一的解决方式就是修改代码使用继承<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AccessibleObject.html"><code>AccessibleObject</code></a>的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Constructor.html#newInstance-java.lang.Object...-"><code>Constructor.newInstance()</code></a>方法。</p><blockquote><p>Tip：由于本教程<a href="https://docs.oracle.com/javase/tutorial/reflect/member/index.html">成员</a>章节<a href="https://docs.oracle.com/javase/tutorial/reflect/member/ctorInstance.html">创建新的类实例</a> 部分所说的原因，一般情况下，使用<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Constructor.html#newInstance-java.lang.Object...-"><code>Constructor.newInstance()</code></a>会好一些。</p></blockquote><p>更多的栗子参见本教程<a href="https://docs.oracle.com/javase/tutorial/reflect/member/index.html">成员</a>章节<a href="https://docs.oracle.com/javase/tutorial/reflect/member/ctorInstance.html">创建新的类实例</a> 部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java反射历来是迈入高级Java开发者的必备科目，网上教程是五花八门，有的失于不够全面，有的失于谬误百出。看过之后不懂的更不懂了，懂得也有点蒙了，偶然看到Oracle的官方教程页面，仿佛打开了新的世界，里面的教程不仅简明易懂而且非常权威，毕竟是官方出品，里面有篇&lt;a hr
      
    
    </summary>
    
      <category term="技术人生" scheme="https://pingao777.github.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="Java" scheme="https://pingao777.github.io/tags/Java/"/>
    
      <category term="反射" scheme="https://pingao777.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>中国真的越来越老了吗</title>
    <link href="https://pingao777.github.io/2020/02/21/%E4%B8%AD%E5%9B%BD%E7%9C%9F%E7%9A%84%E8%B6%8A%E6%9D%A5%E8%B6%8A%E8%80%81%E4%BA%86%E5%90%97/"/>
    <id>https://pingao777.github.io/2020/02/21/中国真的越来越老了吗/</id>
    <published>2020-02-21T13:24:36.000Z</published>
    <updated>2020-09-12T03:14:00.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中国真的老了吗？"><a href="#中国真的老了吗？" class="headerlink" title="中国真的老了吗？"></a>中国真的老了吗？</h2><p>老龄化是今年提得比较多的一个词，中国人真的老龄化了吗？从下图可以直观的看到，从1982年到2010年五次人口普查中，中国人口的年龄分布确实有增大的趋势。</p><p><img src="ages.svg" alt="年龄分布"></p><p>下面的表格给出了精确的数字，可以看到1982年30岁以下人口占到了62.8%，而这一数字到了2010年只有41.2%，而60岁以上的人口却从7.5%增加到了13.3%，由此看来中国的老龄化确实不是耸人听闻，确实是当前的发展趋势。</p><table><thead><tr><th style="text-align:center">时间</th><th style="text-align:center">比例：0-30岁</th><th style="text-align:center">比例：30-60岁</th><th style="text-align:center">比例：60-100岁</th></tr></thead><tbody><tr><td style="text-align:center">1982</td><td style="text-align:center">62.79321</td><td style="text-align:center">29.69685</td><td style="text-align:center">7.509944</td></tr><tr><td style="text-align:center">1987</td><td style="text-align:center">60.05553</td><td style="text-align:center">31.80970</td><td style="text-align:center">8.134770</td></tr><tr><td style="text-align:center">1990</td><td style="text-align:center">58.66278</td><td style="text-align:center">32.75971</td><td style="text-align:center">8.577509</td></tr><tr><td style="text-align:center">2000</td><td style="text-align:center">48.26399</td><td style="text-align:center">41.27596</td><td style="text-align:center">10.460051</td></tr><tr><td style="text-align:center">2010</td><td style="text-align:center">41.23902</td><td style="text-align:center">45.43618</td><td style="text-align:center">13.324804</td></tr></tbody></table><h2 id="男女比例真的失调了吗？"><a href="#男女比例真的失调了吗？" class="headerlink" title="男女比例真的失调了吗？"></a>男女比例真的失调了吗？</h2><p>现在娶媳妇越来越难了，特别是农村，长期以来大家都将原因归结为男女比例失调，农村为了争夺宅基地和从事大量体力劳动，重男轻女更为严重，事实是这样吗？</p><p><img src="sex.svg" alt="男女比例"></p><p>从上图可以看出，随着时间的推移，男女比例确实有增加的趋势，前三次普查男女比例在1.12左右，后两次普查这个比例上涨到1.2左右，而且农村男女比例与城市男女比例相差不大。另外还可以看到一个有意思的现象是男的寿命确实不如女的。1982年62岁以上的人口中女大于男，2010年这一拐点提高到了75岁，也就是到了到了2010年75岁以上的老人中女比男多。图中的数字表示男女比例为1/2的年龄，这一数字随着年代的发展也在提高，可见对于男人来说，社会发展该有多么重要，知道为啥男的喜欢看新闻了吧。</p><h2 id="城里人越来越多了吗？"><a href="#城里人越来越多了吗？" class="headerlink" title="城里人越来越多了吗？"></a>城里人越来越多了吗？</h2><p><img src="area.svg" alt="城市农村人口"></p><p>城里人真的越来越多了，从1982年的2亿到了2010年的接近7亿，农村人口略有减少，从8亿降到了7亿。值得一提的是1987年有一波农村人口增加，城市人口减少的特异值，发生了什么？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;中国真的老了吗？&quot;&gt;&lt;a href=&quot;#中国真的老了吗？&quot; class=&quot;headerlink&quot; title=&quot;中国真的老了吗？&quot;&gt;&lt;/a&gt;中国真的老了吗？&lt;/h2&gt;&lt;p&gt;老龄化是今年提得比较多的一个词，中国人真的老龄化了吗？从下图可以直观的看到，从1982年到2
      
    
    </summary>
    
      <category term="生活生活" scheme="https://pingao777.github.io/categories/%E7%94%9F%E6%B4%BB%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="数据挖掘" scheme="https://pingao777.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="R" scheme="https://pingao777.github.io/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>螃蟹不好吃</title>
    <link href="https://pingao777.github.io/2019/11/16/%E8%9E%83%E8%9F%B9%E4%B8%8D%E5%A5%BD%E5%90%83/"/>
    <id>https://pingao777.github.io/2019/11/16/螃蟹不好吃/</id>
    <published>2019-11-16T03:59:02.000Z</published>
    <updated>2020-09-12T03:14:00.592Z</updated>
    
    <content type="html"><![CDATA[<p>带上这次，我已经尝试了三次，老实讲，螃蟹不好吃。</p><p>作为北方内陆人士，从小没怎么接触过这玩意。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;带上这次，我已经尝试了三次，老实讲，螃蟹不好吃。&lt;/p&gt;
&lt;p&gt;作为北方内陆人士，从小没怎么接触过这玩意。&lt;/p&gt;

      
    
    </summary>
    
      <category term="生活杂记" scheme="https://pingao777.github.io/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="螃蟹" scheme="https://pingao777.github.io/tags/%E8%9E%83%E8%9F%B9/"/>
    
  </entry>
  
  <entry>
    <title>Windows用户Ocaml入坑指南</title>
    <link href="https://pingao777.github.io/2019/11/02/Windows%E7%94%A8%E6%88%B7Ocaml%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>https://pingao777.github.io/2019/11/02/Windows用户Ocaml入坑指南/</id>
    <published>2019-11-02T02:33:32.000Z</published>
    <updated>2020-09-12T03:14:00.584Z</updated>
    
    <content type="html"><![CDATA[<p>第一次听说Ocaml是看到Ocaml写的quicksort算法：</p><pre><code class="ocaml">let rec quicksort = function  | [] -&gt; []  | x::xs -&gt;    let smaller, larger = List.partition (fun y -&gt; y &lt; x) xs    in quicksort smaller @ (x::quicksort larger);;List.iter (fun x -&gt; Printf.printf &quot;%d &quot; x) (quicksort [2; 3; 1; 1; 7; 10])</code></pre><p>Java语言的实现相信大家都看过，这里我把<em>Algorithms 4th</em>中的源码贴一下：</p><pre><code class="java">public class Quick &#123;    public static void sort(Comparable[] a) &#123;        StdRandom.shuffle(a);        sort(a, 0, a.length - 1);    &#125;    private static void sort(Comparable[] a, int lo, int hi) &#123;        if (hi &lt;= lo) return;        int j = partition(a, lo, hi);        sort(a, lo, j-1);        sort(a, j+1, hi);    &#125;    private static int partition(Comparable[] a, int lo, int hi) &#123;        int i = lo;        int j = hi + 1;        Comparable v = a[lo];        while (true) &#123;            while (less(a[++i], v)) &#123;                if (i == hi) break;            &#125;            while (less(v, a[--j])) &#123;                if (j == lo) break;            &#125;            if (i &gt;= j) break;            exch(a, i, j);        &#125;        exch(a, lo, j);        return j;    &#125;    private static boolean less(Comparable v, Comparable w) &#123;        if (v == w) return false;        return v.compareTo(w) &lt; 0;    &#125;    private static void exch(Object[] a, int i, int j) &#123;        Object swap = a[i];        a[i] = a[j];        a[j] = swap;    &#125;&#125;</code></pre><p>两下一对比，被震撼到了。这么说吧，看Ocaml写的快排算法很容易看到算法的本质，而Java的实现则是“一团糟”，算法的本质隐藏到琐碎的细节中了，通篇都是<code>if</code>分支和数组索引。Ocaml强大的模式匹配和immunable数据结构可以让你写出清晰简洁的代码。难能可贵的是，和曲高和寡的Lisp不同，Ocaml虽然崇尚函数式编程，但并不排斥命令式编程。另外，Ocaml是一门非常实用的语言，尤其适合编译方面的工作，所以如果你对DSL感兴趣，相信Ocaml会是你的菜，要知道大名鼎鼎的Rust语言在自举前编译器就是用Ocaml写的。</p><p>怀着激动的心情一通谷歌，发现只支持Linux和OSX，这就蛋疼了。尝试了官网<a href="https://ocaml.org/docs/install.html">安装说明</a>中几种Windows安装方式，效果都不理想，顶多就一个黑框框，毕竟自己不是大神，还是需要代码提示和代码格式化这样的功能的，所以尝试了几次，只好忍痛割爱。一个偶然的机会，接触了Windows上的Wsl系统，感觉不错，又想起心心念念的Ocaml了，自然就想到了结合Wsl是否可以搭建一个理想的Ocaml环境？摸索了一段时间，终于找到一种比较理想的方法。</p><p>首先安装Wsl，在Windows开始中搜索：“程序与功能”，勾选“适用于Linux的Windows子系统”。下载<a href="https://github.com/yuk7/ArchWSL/">Archlinux镜像</a>，解压到文件夹，打开Arch.exe，等待安装完成。</p><p>Archlinux刚开始只有一个root，我习惯先新建一个用户，你也可以直接使用root。新建用户命令如下：</p><pre><code class="shell">useradd -m -G wheel -s /bin/bash  [用户名]passwd [用户名]visudo</code></pre><p>找到这么一行<code>#%wheel ALL=(ALL) ALL</code>，将全面的#去掉，用户就创建好了，然后使用下面的命令切换到此用户的主目录：</p><pre><code class="shell">su [用户名]cd ~</code></pre><p>下面配置pacman，</p><pre><code class="shell">sudo pacman-key --initsudo pacman-key --populatesudo vim /etc/pacman.d/mirrorlist</code></pre><p>找到mirrorlist里China那一组，找几个离你比较近的源，把前面的#去掉，然后用下面的命令更新软件包缓存：</p><pre><code class="shell">sudo pacman -Syy</code></pre><p>下面安装Ocaml必须的软件，</p><pre><code class="shell">sudo pacman -S ocaml# opam是ocaml的包管理工具，类似python的pip，java的mavensudo pacman -S opamsudo pacman -S patchsudo pacman -S m4sudo pacman -S makesudo pacman -S gcc</code></pre><p>接着，初始化opam，</p><pre><code class="shell"># wsl系统需要加上--disable-sandboxing选项opam init --disable-sandboxing# 可以将下面的命令加到.bashrc文件中，不用每次手动执行了eval $(opam env)# 下面是ocaml格式化和代码提示所需的工具opam install merlinopam user-setup installopam install ocp-indentopam user-setup installopam install utop</code></pre><p>这些都成功后下载vscode，在Windows上安装，完成后回到Linux执行下面的命令：</p><pre><code class="shell">code .</code></pre><p>下面推荐一下几个插件：</p><ul><li>OCaml and Reason IDE，注意还有一个插件叫OCaml and Reason IDE For Wsl，选那个不带For Wsl</li><li>Code Runner插件可以方便的运行单文件程序，推荐大家装一下。</li><li>ocaml-reason-format，用来格式化代码，OCaml and Reason IDE本身的格式化不太好。</li></ul><p>最终的settings.json如下：</p><pre><code class="json">&quot;editor.fontSize&quot;: 18,&quot;reason.path.ocamlmerlin&quot;: &quot;/home/user/.opam/default/bin/ocamlmerlin&quot;,&quot;reason.path.ocpindent&quot;: &quot;/home/user/.opam/default/bin/ocp-indent&quot;,&quot;editor.formatOnType&quot;: true,&quot;reason.codelens.enabled&quot;: false,  // 不显示类型提示&quot;ocaml-reason-format.ocamlformat&quot;: &quot;/home/user/.opam/default/bin/ocamlformat&quot;,&quot;[ocaml]&quot;: &#123;    &quot;editor.defaultFormatter&quot;: &quot;rustykey.vscode-ocaml-reason-format&quot;&#125;,</code></pre><p><img src="vscode.png" alt="vscode"></p><p>最后一步了，大家加油！新建一个文件<code>test.ml</code>，将开头的那段Ocaml代码拷进去，新建另一个文件<code>dune</code>，输入下面的内容：</p><pre><code class="ocaml">(executables (names test))</code></pre><p>在vscode的terminal中执行<code>dune exec ./test.bc</code>，如果看到<code>1 1 2 3 7 10</code>，就说明配置成功了，接下来尽情享受Ocaml带给你不一样的感觉吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一次听说Ocaml是看到Ocaml写的quicksort算法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let rec quicksort = function
  | [] -&amp;gt; []
  | x::xs -&amp;gt;
    let smalle
      
    
    </summary>
    
      <category term="技术人生" scheme="https://pingao777.github.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="Ocaml" scheme="https://pingao777.github.io/tags/Ocaml/"/>
    
      <category term="函数式" scheme="https://pingao777.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程交替打印字符</title>
    <link href="https://pingao777.github.io/2019/06/05/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6/"/>
    <id>https://pingao777.github.io/2019/06/05/Java多线程交替打印字符/</id>
    <published>2019-06-05T02:13:15.000Z</published>
    <updated>2020-09-12T03:14:00.583Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有这样一个面试题：多线程打印AB字符</p></blockquote><p>这玩意但凡有点Java基础的人，都会想到这是考察线程<code>wait</code>和<code>notify</code>，那么具体怎么做呢？如果长时间不写多线程程序，冷不丁的来一下，还真写不出。</p><p>先来复习下<code>wait</code>、<code>notify</code>的概念：</p><blockquote><p>wait: Causes the current thread to wait until either another thread invokes the notify() method or the notifyAll() method for this object, or a specified amount of time has elapsed.<br>The current thread must own this object’s monitor.</p></blockquote><blockquote><p>notify: Wakes up a single thread that is waiting on this object’s monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. A thread waits on an object’s monitor by calling one of the wait methods.This method should only be called by a thread that is the owner of this object’s monitor.</p></blockquote><blockquote><p>notifyAll: Wakes up all threads that are waiting on this object’s monitor.</p></blockquote><p>根据Javadoc的注释，可以看出<code>wait</code>将会让出锁，进入<code>WAITING</code>状态，直到其他线程调用<code>notify(All)</code>，进入<code>AWAKENED</code>状态，在<code>wait</code>最终返回之前，需要获取锁。这意味着，<code>AWAKENED</code>的线程将和<code>BLOCKING</code>状态的线程一起竞争锁，如果竞争不过，继续待在<code>WAITING</code>状态。有几点需要注意：</p><ul><li>无论是<code>wait</code>，还是<code>notify(All)</code>，都必须在持有锁的状态下调用</li><li><code>notify(All)</code>调用后不会释放锁，而是在离开<code>syntronized</code>区域后</li><li><code>AWAKENED</code>线程在竞争锁时没有任何优势，和<code>BLOCKING</code>线程优先级一样</li></ul><p><code>wait</code>的使用范式如下：</p><pre><code class="java">synchronized (obj) &#123;   while (&lt;condition does not hold&gt;)       obj.wait();   ... // Perform action appropriate to condition&#125;</code></pre><p>之所以使用循环条件判断，是为了防止线程<strong>过早唤醒</strong>，也就是发出<code>notify(All)</code>时条件谓词为真，到<code>wait</code>返回时，谓词不为真了。另外Javadoc指出，<code>WAITING</code>线程会有一定的几率自己醒来，而不是收到<code>notify(All)</code>的通知，虽然这极少发生。</p><p>回到最初的问题，可以启动两个线程，为他们分配一个名字<code>name</code>，分别为A和B，设置一个变量<code>ticket</code>保存着下一个可运行的线程名，只有<code>name == ticket</code>的线程才有权运行，这样只要改变<code>ticket</code>的值就可以控制线程的运行了，具体代码如下：</p><pre><code class="java">public class Main &#123;    public static void main(String[] args) &#123;        new PrintChar(&#39;A&#39;).start();        new PrintChar(&#39;B&#39;).start();    &#125;    private static class PrintChar extends Thread &#123;        private static final Object lock = new Object();        private static char running = &#39;A&#39;;        private char name;        public PrintChar(char name) &#123;            this.name = name;        &#125;        @Override        public void run() &#123;            for (int i = 0; i&lt;10;i++) &#123;                synchronized (lock) &#123;                    while (name != running) &#123;                        try &#123;                            // System.out.print(&quot; &lt;&quot; + name + &quot; waiting&gt; &quot;);                            lock.wait();                        &#125; catch (InterruptedException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                    System.out.print(name);                    loop();                    lock.notify();                &#125;            &#125;        &#125;        private void loop() &#123;            if (running == &#39;B&#39;) &#123;                running = &#39;A&#39;;            &#125; else &#123;                running += 1;            &#125;        &#125;    &#125;&#125;</code></pre><p>为了观察线程的运行等待状态，我们将注释放开，得到下面的结果，</p><pre><code>A &lt;A waiting&gt; B &lt;B waiting&gt; A &lt;A waiting&gt; B &lt;B waiting&gt; A &lt;A waiting&gt; B ...</code></pre><p>作为一个问题的延伸，考虑下面的问题：</p><blockquote><p>多线程打印ABCDE</p></blockquote><p>小伙伴们，你想到了吗？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;有这样一个面试题：多线程打印AB字符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这玩意但凡有点Java基础的人，都会想到这是考察线程&lt;code&gt;wait&lt;/code&gt;和&lt;code&gt;notify&lt;/code&gt;，那么具体怎么做呢？如果长时间不写多线程程
      
    
    </summary>
    
      <category term="技术人生" scheme="https://pingao777.github.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="Java" scheme="https://pingao777.github.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://pingao777.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java HotSpot虚拟机垃圾收集优化指南</title>
    <link href="https://pingao777.github.io/2019/05/03/Java%20HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/"/>
    <id>https://pingao777.github.io/2019/05/03/Java HotSpot虚拟机垃圾收集优化指南/</id>
    <published>2019-05-03T10:39:07.000Z</published>
    <updated>2020-09-12T03:14:00.582Z</updated>
    
    <content type="html"><![CDATA[<p>现在不懂点虚拟机都不好意思说是Java程序员了，这方面的文章不少，但质量参差不齐。在百度谷歌上看了一圈大部分是你抄我我抄你，要不就是泛泛而谈，看完之后还是一头雾水，看到Oracle官网上有一篇将虚拟机调优的文章<a href="https://www.oracle.com/pls/topic/lookup?ctx=javase12&amp;id=JSGCT-GUID-326EB4CF-8C8C-4267-8355-21AB04F0D304">Garbage Collection Tuning</a>不错，有理论有实操，试着翻译下。</p><h2 id="1-垃圾收集优化介绍"><a href="#1-垃圾收集优化介绍" class="headerlink" title="1 垃圾收集优化介绍"></a>1 垃圾收集优化介绍</h2><p>从桌面上的小应用程序到大型服务器上的网络服务，各种各样的应用都在使用Java SE平台。为了支持多样化的部署，Java HotSpot虚拟机提供了多种垃圾收集器，每个都是为了满足不同的需要而设计的。Java SE根据运行应用程序的计算机的类别选择最合适的垃圾收集器。然而，这种选择并不是对每个应用都是最佳的。具有严格性能或其他要求的用户、开发人员和管理员可能需要显式选择合适的垃圾收集器，并调整某些参数以达到所需的性能水平。本文档提供了帮助完成这些任务的信息。</p><p>首先，垃圾收集器的一般特性和基本的调优选项将在串行stop-the-world收集器一节描述。然后介绍其他收集器的具体特征以及选择收集器时要考虑的因素。</p><p>本节主题：</p><ul><li>什么是垃圾收集器？</li><li>垃圾收集器的选择为什么重要？</li><li>文档中支持的操作系统</li></ul><h3 id="什么是垃圾收集器？"><a href="#什么是垃圾收集器？" class="headerlink" title="什么是垃圾收集器？"></a>什么是垃圾收集器？</h3><p>垃圾收集器用来自动管理应用程序的动态内存分配请求。</p><p>垃圾收集器通过以下操作执行自动动态内存管理:</p><ul><li>从操作系统分配内存和将内存返还给操作系统。</li><li>根据应用程序的请求，将内存分配给它。</li><li>确定哪些内存还在使用。</li><li>回收未使用的内存供应用程序重用。</li></ul><p>Java HotSpot垃圾收集器采用各种技术来提高这些操作的效率:</p><ul><li>将年代清理与老化结合使用，将精力集中在堆中最有可能包含大量可回收内存的区域。</li><li>使用多线程并行操作，或者在应用程序的后台并行执行一些长期运行的操作。</li><li>通过压缩存活对象，尝试恢复更大的连续可用内存。</li></ul><h3 id="垃圾收集器的选择为什么重要？"><a href="#垃圾收集器的选择为什么重要？" class="headerlink" title="垃圾收集器的选择为什么重要？"></a>垃圾收集器的选择为什么重要？</h3><p>垃圾收集器的目的是将应用程序开发人员从手动动态内存管理中解放出来。开发人员无需关心内存的分配与回收，也不用关注分配的动态内存的生存期。这完全消除了一些与内存管理相关的错误，代价是增加了一些运行时开销。Java HotSpot虚拟机提供了一系列垃圾收集算法可供选择。</p><p>垃圾收集器的选择什么时候重要？对于某些应用，答案是永远不会。也就是说，一些应用程序的垃圾收集运行良好，暂停的频率和持续时间适中。然而，对于一大类应用程序，尤其是那些具有大量数据(几十亿字节)、许多线程和高事务率的应用程序，情况并非如此。</p><p>Amdahl定律(给定问题中的并行加速受问题串行部分的限制)意味着大多数工作负载不能完全并行化；有些部分总是串行的，并没有从并行中获益。在Java平台中，目前有四种支持的垃圾收集替换方案，除了其中一种串行垃圾收集器serial GC，其他的都能并行化以提高性能。尽可能降低垃圾收集的开销是非常重要的。这可以在下面的例子中看到。</p><p>图1-1中的图表模拟了一个理想的系统，除了垃圾收集之外，它是完全可伸缩的。红线表示在单处理器系统上只花费1%时间进行垃圾收集的应用程序。这意味着在拥有32个处理器的系统上，吞吐量损失超过20%。洋红色线显示，对于垃圾收集时间为10%的应用程序(在单处理器应用程序中，垃圾收集时间不算太长)，当扩展到32个处理器时，会损失75%以上的吞吐量。</p><p><img src="https://docs.oracle.com/en/java/javase/12/gctuning/img/jsgct_dt_005_gph_pc_vs_tp.png" alt="图1-1 垃圾收集所用时间的百分比对比"></p><p>该图显示，在小型系统上开发时，可以忽略的吞吐量问题可能会成为扩展到大型系统时的主要瓶颈。然而，在减少这种瓶颈方面的微小改进可以带来巨大的性能提升。对于一个足够大的系统，选择合适的垃圾收集器并在必要时对其进行调整变得很有价值。</p><p>串行垃圾收集器对于大多数小型应用已经足够了，尤其是那些堆空间约100兆字节的应用。其他收集器有额外的开销或复杂性，这是高级特性的代价。如果应用程序不需要其他收集器的高级特性，使用串行垃圾收集器就可以了。串行垃圾收集器不是最佳选择的一种情况是运行在具有大量内存和两个或更多处理器的机器上的大型多线程应用程序。当应用程序在这样的服务器级计算机上运行时，默认情况下会选择垃圾优先(G1)收集器；参见<a href="https://docs.oracle.com/en/java/javase/12/gctuning/ergonomics.html#GUID-DB4CAE94-2041-4A16-90EC-6AE3D91EC1F1">工效学</a>。</p><h3 id="文档中支持的操作系统"><a href="#文档中支持的操作系统" class="headerlink" title="文档中支持的操作系统"></a>文档中支持的操作系统</h3><p>本文档及其建议适用于JDK 12支持的所有系统配置，受某些垃圾收集器特定配置实际可用性的限制。请参阅<a href="http://www.oracle.com/pls/topic/lookup?ctx=javase12&amp;id=latest_certified_system_configurations">甲骨文JDK认证系统配置</a>。</p><h2 id="2-工效学"><a href="#2-工效学" class="headerlink" title="2 工效学"></a>2 工效学</h2><p>工效学是指Java虚拟机(JVM)使用启发式垃圾收集方法以(如基于行为的试探法)提高应用程序性能的过程。</p><p>JVM为垃圾收集器、堆大小和运行时编译器提供了依赖于平台的默认选择。这些选择兼顾不同类型应用程序的需求，同时只需要较少的命令行调整。此外，基于行为的动态堆大小优化，以满足应用程序的特定行为。</p><p>本节描述这些默认选择和基于行为的调整。在使用后续章节中描述的更详细控制之前，使用这些默认值。</p><p>本节主题：</p><ul><li>垃圾收集器、堆和运行时编译器默认选择</li><li>基于行为的优化<ul><li>最大暂停时间</li><li>吞吐量</li><li>占用量</li></ul></li><li>调优策略</li></ul><h3 id="垃圾收集器、堆和运行时编译器默认选择"><a href="#垃圾收集器、堆和运行时编译器默认选择" class="headerlink" title="垃圾收集器、堆和运行时编译器默认选择"></a>垃圾收集器、堆和运行时编译器默认选择</h3><p>下面是重要的垃圾收集器、堆大小和运行时编译器默认选择:</p><ul><li>垃圾优先(G1)收集器</li><li>垃圾收集线程的最大数量受堆大小和可用CPU资源的限制</li><li>堆的初始容量为1/64物理内存</li><li>堆的最大容量为1/4物理内存</li><li>分层编译器，使用C1和C2</li></ul><h3 id="基于行为的优化"><a href="#基于行为的优化" class="headerlink" title="基于行为的优化"></a>基于行为的优化</h3><p>Java HotSpot虚拟机垃圾收集器可以配置为优先满足两个目标之一:最大暂停时间和吞吐量。如果达到了首选目标，收集者将尝试最大化另一个目标。当然，这些目标并不总是能够实现的:应用程序需要至少能保存所有存活数据的最小堆，而其他配置可能会阻止实现一些或所有的期望目标。</p><h4 id="最大暂停时间"><a href="#最大暂停时间" class="headerlink" title="最大暂停时间"></a>最大暂停时间</h4><p>暂停时间是指垃圾收集器停止应用程序并回收非使用空间的持续时间。最大暂停时间目的是限制这些暂停的最长时间。</p><p>垃圾收集器维护着暂停时间的平均值和方差。平均值是从应用开始执行时取的，但是它是加权的，所以最近的暂停权重更大。如果暂停时间的平均值加上方差大于最大暂停时间，则垃圾收集器认为目标没有实现。</p><p>最大暂停时间是用命令行选项<code>-XX:MaxGCPauseMillis=&lt;nnn&gt;</code>指定的。这被解释为向垃圾收集器提示需要<code>&lt; nnn &gt;</code>毫秒或更少的暂停时间。垃圾收集器会调整Java堆大小和其他与垃圾收集相关的参数，以使垃圾收集暂停时间短于<code>&lt; nnn &gt;</code>毫秒。最大暂停时间的默认值因垃圾收集器而异。这些调整可能会导致垃圾收集的更加频繁，从而降低应用程序的整体吞吐量。然而，在某些情况下，期望的暂停时间目标可能无法实现。</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>吞吐量目标是以收集垃圾花费的时间来衡量的，垃圾收集之外的时间就是应用程序时间。</p><p>吞吐量通过命令选项<code>-XX:GCTimeRatio=nnn</code>指定。垃圾收集时间与应用时间之比为1/ (1+nnn)。例如，<code>-XX:GCTimeRatio=19</code>设置了垃圾收集时间占总时间的1/20或5%。</p><p>垃圾收集花费的时间是所有垃圾收集暂停的总时间。如果没有达到吞吐量目标，那么垃圾收集器的一个可能的操作是增加堆的大小，以便在垃圾收集之间的应用程序时间可以更长。</p><h4 id="占用量"><a href="#占用量" class="headerlink" title="占用量"></a>占用量</h4><p>如果吞吐量和最大暂停时间目标已经达到，那么垃圾收集器会减小堆的大小，直到其中一个目标(总是吞吐量目标)无法达到为止。垃圾收集器可以分别使用<code>-Xms=&lt;nnn &gt;</code>和<code>-Xmx=&lt;mmm &gt;</code>设置为最小和最大堆大小。</p><h3 id="调优策略"><a href="#调优策略" class="headerlink" title="调优策略"></a>调优策略</h3><p>堆增长或收缩到以支持所选吞吐量。了解堆优化策略，如选择最大堆大小和选择最大暂停时间目标。</p><p>除非您确定需要大于堆大小默认值的堆，否则不要为堆选择最大值。为您的应用选择一个足够的吞吐量即可。</p><p>应用程序行为的改变会导致堆增长或收缩。例如，如果应用程序开始以更高的速率分配内存，那么堆就会增长以保持相同的吞吐量。</p><p>如果堆增长到其最大大小，并且没有达到吞吐量目标，则最大堆大小对于吞吐量目标来说太小。将最大堆大小设置为接近平台上总物理内存但不会导致应用程序交换的值。再次执行应用程序。如果仍然没有达到吞吐量目标，那么应用程序时间的目标对于平台上的可用内存来说太高了。</p><p>如果可以达到吞吐量目标，但暂停时间过长，则选择更小的最大暂停时间。选择更小的最大暂停时间可能意味着您的吞吐量无法实现，因此请选择对应用程序来说可以接受的折衷值。</p><p>垃圾收集器试图满足竞争目标时，堆的大小通常会发生波动。即使应用程序已经达到稳定状态，也是如此。实现吞吐量目标(可能需要更大的堆)的压力与最大暂停时间和最小占用空间(两者都可能需要更小的堆)的目标相竞争。</p><h2 id="3-垃圾收集器实现"><a href="#3-垃圾收集器实现" class="headerlink" title="3 垃圾收集器实现"></a>3 垃圾收集器实现</h2><p>Java SE平台的一个优势是它保护开发人员免受内存分配和垃圾收集复杂性的困扰。</p><p>然而，当垃圾收集成为主要瓶颈时，理解实现的某些方面是有用的。垃圾收集器对应用程序使用对象的方式进行假设，这些假设反映在可调参数中，这些参数可以在不牺牲抽象能力的情况下进行调整以提高性能。</p><p>本节主题：</p><ul><li>分代垃圾收集</li><li>分代</li><li>性能考虑</li><li>吞吐量和占用量考量</li></ul><h3 id="分代垃圾收集"><a href="#分代垃圾收集" class="headerlink" title="分代垃圾收集"></a>分代垃圾收集</h3><p>当运行程序中的任何其他存活对象的任何引用不能再访问一个对象时，它就是一个垃圾，虚拟机可以重用它的内存。</p><p>理论上，最简单的垃圾收集算法每次运行时都会遍历每个可到达的对象。其余的对象都被认为是垃圾。这种方法花费的时间与活动对象的数量成正比，这对维护大量存活数据的大型应用程序来说是禁止的。</p><p>Java HotSpot虚拟机包含许多不同的垃圾收集算法，这些算法都使用一种称为分代收集的技术。虽然简单的垃圾收集每次都会检查堆中的每个存活对象，但是分代收集利用了在大多数应用程序中观察到的几个经验特性来最小化回收未使用(垃圾)对象所需的工作。这些观察到的特性中最重要的是<em>弱分代假说(weak generational hypothesis)</em>，它指出大多数对象只能存活很短的一段时间。</p><p>图3-1中的蓝色区域是对象寿命的典型分布。x轴显示的是对象生命周期。y轴显示的是存活对象的字节数。左边的尖峰代表分配后不久可以回收的对象(换句话说，已经“死亡”)。例如，迭代器对象通常只在单个循环期间有效。</p><p><img src="https://docs.oracle.com/en/java/javase/12/gctuning/img/jsgct_dt_003_alc_vs_srvng.png" alt="图3-1对象生命周期的典型分布"></p><p>有些对象确实寿命更长，所以分布向右侧延伸。例如，通常有一些在初始化时分配的对象会一直存在，直到虚拟机退出。在这两个极端之间是在运算期间的中间值，在这里被视为初始峰值右侧的块。一些应用程序具有非常不同的分布，但令人惊讶的是，大量应用程序具有这种一般性的形状。通过关注大多数对象“朝生夕死”的事实，有效的收集成为可能。</p><h3 id="分代"><a href="#分代" class="headerlink" title="分代"></a>分代</h3><p>为了针对这种情况进行优化，内存分几代进行管理(内存池保存不同年龄的对象)。垃圾收集发生在每一代填满时。</p><p>绝大多数对象被分配到一个专门用于年轻对象(新生代，young generation)的池中，大多数对象死在那里。当新生代填满时，它会导致一个<em>小规模垃圾收集(minor collection)</em>，它只收集新生代；其他分代的垃圾不会被回收。这种收集的成本首先与被收集的存活对象的数量成比例；充满死亡对象的新生代收集的很快。</p><p>通常，在每一次小规模的收集过程中，新生代幸存下来的一些对象会被转移到老年代(old generation)。最后，老年代也会填满并且必须被收集，从而产生一个<em>大规模垃圾收集(major collection)</em>，它将收集整个堆。大规模垃圾收集的持续时间通常比小规模垃圾收集长得多，因为涉及的对象数量要大得多。图3-2显示了串行垃圾收集器(serial garbage collector)中的默认分代排列:</p><p><img src="https://docs.oracle.com/en/java/javase/12/gctuning/img/jsgct_dt_001_armgnt_gn_new.png" alt="图3-2串行垃圾收集器(serial garbage collector)中的默认分代排列"></p><p>启动时，Java HotSpot虚拟机将整个Java堆保留在地址空间中，除非需要，否则不会为其分配任何物理内存。Java堆的整个地址空间在逻辑上分为新生代和老年代。为对象内存保留的完整地址空间也分为新生代和老年代。</p><p>新生代由eden和两个survivor空间组成。大多数对象最初分配在eden中。在任何时候都有一个survivor空间是空的，并且在垃圾收集期间充当eden和另一个survivor空间中存活对象的目标空间；垃圾收集后，eden和源survivor空间是空的。在下一次垃圾收集中，两个survivor空间的角色交换。最近填充的survivor空间将会把存活对象复制到另一个survivor空间。对象以这种方式在两个survivor空间之间来回复制，直到它们被复制了一定次数或者没有足够的空间了。这些对象被复制到老年代。这个过程也被称为<em>老化(aging)</em>。</p><h3 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h3><p>垃圾收集的主要指标是吞吐量和时延。</p><ul><li>吞吐量是指未花费在垃圾收集上的总时间的百分比(即应用程序所占用的时间，译者注)。吞吐量包括分配内存所花费的时间(但通常不需要调整分配速度)。</li><li>时延是应用程序的响应能力。垃圾收集会暂停应用程序进而会影响应用程序的响应能力。</li></ul><p>用户对垃圾收集有不同的要求。例如，有些人认为网络服务器的正确度量是吞吐量，因为垃圾收集期间的暂停可能是可以容忍的，或者会因为网络延迟而变得模糊不清。然而，在交互式图形程序中，即使短暂的暂停也会对用户体验产生负面影响。</p><p>一些用户对其他考虑很敏感。占用空间是一个进程的工作集，以页面和缓存行来衡量。在物理内存有限或进程众多的系统上，占用空间可能决定可伸缩性。<em>及时性(Promptness)</em>是指对象死亡和内存可用之间的时间，对于包括远程方法调用(Remote Method Invocation, RMI)在内的分布式系统来说，这是一个重要的考虑因素。</p><p>一般来说，为特定一代选择大小就是在这些因素之间作权衡。例如，非常大的新生代可能最大化吞吐量，但这样做是以空间占用、及时性和暂停时间为代价的。相反，可以通过减小新生代的空间来换取小的垃圾收集暂停时间，但这会牺牲吞吐量。一代的空间不会影响另一代的收集频率和暂停时间。</p><p>没有一种通用的方法可以选择一代的最优空间大小。最佳选择取决于应用程序使用内存的方式以及用户需求。因此，虚拟机对垃圾收集器的选择并不总是最佳的，可以通过命令行选项修改；请参见<a href="https://docs.oracle.com/en/java/javase/12/gctuning/factors-affecting-garbage-collection-performance.html#GUID-5508674B-F32D-4B02-9002-D0D8C7CDDC75">影响垃圾收集性能的因素</a>。</p><h3 id="吞吐量和占用量考量"><a href="#吞吐量和占用量考量" class="headerlink" title="吞吐量和占用量考量"></a>吞吐量和占用量考量</h3><p>吞吐量和占用量最好使用特定于应用的指标来衡量。</p><p>例如，可以使用客户端负载生成器测试网络服务器的吞吐量，可以使用<code>pmap</code>命令在Solaris操作系统上测量服务器的占用空间。通过检查虚拟机本身的诊断输出，可以轻松估计垃圾收集导致的暂停时间。</p><p>命令行选项<code>-verbose:gc</code>在每次垃圾收集中打印关于堆和垃圾收集的信息。下面是一个例子:</p><pre><code>[15,651s][info ][gc] GC(36) Pause Young (G1 Evacuation Pause) 239M-&gt;57M(307M) (15,646s, 15,651s) 5,048ms[16,162s][info ][gc] GC(37) Pause Young (G1 Evacuation Pause) 238M-&gt;57M(307M) (16,146s, 16,162s) 16,565ms[16,367s][info ][gc] GC(38) Pause Full (System.gc()) 69M-&gt;31M(104M) (16,202s, 16,367s) 164,581ms</code></pre><p>输出显示了两次新生代的垃圾收集，之后是应用程序调用<code>System.gc()</code>启动的完整垃圾收集(Full GC)。这些行以时间戳开始，该时间戳表示应用程序启动的时间。接下来是关于该行的日志级别(信息)和标签(gc)的信息。随后是垃圾收集识别号。在这种情况下，有三个编号为36、37和38的垃圾收集。然后记录的是垃圾收集类型和原因。之后，会记录一些关于内存消耗的信息。该日志使用“在垃圾收集之前使用堆大小”-&gt;“在垃圾收集之后使用堆大小”的格式。</p><p>在示例的第一行中，是239兆-&gt;57M(307兆)，这意味着在垃圾收集清除大部分内存之前使用了239兆字节，但是收集之后保留了57兆字节。堆大小为307兆字节。请注意，在此示例中，完整的垃圾收集将堆从307兆字节缩减到104兆字节。在内存使用信息之后，将记录垃圾收集的开始和结束时间以及持续时间(结束-开始)。</p><p><code>-verbose:gc</code>命令是<code>-Xlog:gc</code>的别名。<code>-Xlog</code>是用于HotSpot JVM的通用日志配置选项。这是一个基于标签的系统，其中gc是标签之一。要获得更多关于垃圾收集正在做什么的信息，您可以配置日志来打印任何带有垃圾收集标签和任何其他标签的消息。该命令的命令行选项是<code>-Xlog:gc*</code>。</p><p>下面是一个用<code>-Xlog:gc*</code>配置的G1收集器新生代垃圾收集的例子:</p><pre><code>[10.178s][info][gc,start ] GC(36) Pause Young (G1 Evacuation Pause)[10.178s][info][gc,task ] GC(36) Using 28 workers of 28 for evacuation[10.191s][info][gc,phases ] GC(36) Pre Evacuate Collection Set: 0.0ms[10.191s][info][gc,phases ] GC(36) Evacuate Collection Set: 6.9ms[10.191s][info][gc,phases ] GC(36) Post Evacuate Collection Set: 5.9ms[10.191s][info][gc,phases ] GC(36) Other: 0.2ms[10.191s][info][gc,heap ] GC(36) Eden regions: 286-&gt;0(276)[10.191s][info][gc,heap ] GC(36) Survivor regions: 15-&gt;26(38)[10.191s][info][gc,heap ] GC(36) Old regions: 88-&gt;88[10.191s][info][gc,heap ] GC(36) Humongous regions: 3-&gt;1[10.191s][info][gc,metaspace ] GC(36) Metaspace: 8152K-&gt;8152K(1056768K)[10.191s][info][gc ] GC(36) Pause Young (G1 Evacuation Pause) 391M-&gt;114M(508M) 13.075ms[10.191s][info][gc,cpu ] GC(36) User=0.20s Sys=0.00s Real=0.01s</code></pre><blockquote><p>注意：由-Xlog:gc*生成的输出格式可能会在未来版本中发生变化。</p></blockquote><h2 id="4-影响垃圾收集性能的因素"><a href="#4-影响垃圾收集性能的因素" class="headerlink" title="4 影响垃圾收集性能的因素"></a>4 影响垃圾收集性能的因素</h2><p>影响垃圾收集性能的两个最重要的因素是总的可用内存和新生代的比例。</p><p>本节内容：</p><ul><li>总的可用内存<ul><li>影响分代大小的选项</li><li>堆的默认大小</li><li>通过最小化Java堆大小来节省动态占用空间</li></ul></li><li>新生代<ul><li>新生代大小选项</li><li>survivor空间大小</li></ul></li></ul><h3 id="总的可用内存"><a href="#总的可用内存" class="headerlink" title="总的可用内存"></a>总的可用内存</h3><p>影响垃圾收集性能的最重要因素是总可用内存。因为收集发生在分代空间占满时，吞吐量与可用内存量成反比。</p><blockquote><p>注意：以下关于堆的增长和收缩、堆布局和默认值的讨论以串行垃圾收集器为例。虽然其他收集器使用类似的机制，但这里提供的细节可能不适用于其他收集器。有关其他收集器的类似信息，请参考各自的主题。</p></blockquote><h4 id="影响分代大小的选项"><a href="#影响分代大小的选项" class="headerlink" title="影响分代大小的选项"></a>影响分代大小的选项</h4><p>许多选项会影响分代大小。图4-1展示了堆中提交空间和虚拟空间之间的区别。虚拟机初始化时，堆的整个空间都会被保留。保留空间的大小可以用<code>-Xmx</code>选项指定。如果<code>-Xms</code>参数的值小于<code>-Xmx</code>参数的值，则不是所有保留的空间都会立即提交给虚拟机。在此图中，未提交的空间标记为“虚拟”。堆的不同部分，即新生代和老年代，可以根据需要增加到虚拟空间的极限。</p><p>一些参数可以设置堆的一部分与另一部分的比率。例如，参数<code>–XX:NewRatio</code>表示老年代与新生代的相对大小。</p><p><img src="https://docs.oracle.com/en/java/javase/12/gctuning/img/jsgct_dt_006_prm_gn_sz_new.png" alt="堆空间"></p><h4 id="堆的默认大小"><a href="#堆的默认大小" class="headerlink" title="堆的默认大小"></a>堆的默认大小</h4><p>默认情况下，虚拟机会在每次垃圾收集时增大或缩小堆，以尝试将每次收集中存活对象的可用空间比例维持在特定范围内。</p><p>该范围为选项<code>-XX:MinHeapFreeRatio= &lt;最小值&gt;</code>和<code>-XX:MaxHeapFreeRatio= &lt;最大值&gt;</code>设置的百分比，堆的总大小以<code>–Xms &lt;最小值&gt;</code>为界，以<code>–Xmx &lt;最大值&gt;</code>为界。64位Solaris操作系统(SPARC平台版)的默认选项如表4-1所示。</p><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left">-XX:MinHeapFreeRatio</td><td style="text-align:left">40</td></tr><tr><td style="text-align:left">-XX:MaxHeapFreeRatio</td><td style="text-align:left">70</td></tr><tr><td style="text-align:left">-Xms</td><td style="text-align:left">6656 KB</td></tr><tr><td style="text-align:left">-Xmx</td><td style="text-align:left">计算得到</td></tr></tbody></table><p>有了这些选项，如果某一代的可用空间低于40%，则会扩展堆空间以保持40%的可用空间，一直到这一代的最大允许大小。类似地，如果空闲空间超过70%，那么这一代空间将收缩，使得只有70%的空间是空闲的，这取决于这一代空间的最小尺寸。</p><p>如表4-1所示，默认的最大堆大小是由JVM计算的值。Java SE中用于并行收集器(Parallel collector)的计算现在被用于所有垃圾收集器。计算的一部分是64位平台的最大堆大小上限。请参见大小<a href="https://docs.oracle.com/en/java/javase/12/gctuning/parallel-collector1.html#GUID-74BE3BC9-C7ED-4AF8-A202-793255C864C4">并行垃圾收集器默认堆</a>。客户端模式的JVM也有类似的计算，只不过最大堆大小小于服务器模式的JVM。</p><p>以下是关于服务器应用程序堆大小的一般准则:</p><ul><li>除非暂停有问题，否则请尝试向虚拟机授予尽可能多的内存。默认大小通常太小。</li><li>将<code>-Xms</code>和<code>-Xmx</code>设置为相同的值可以通过从虚拟机中删除最重要的规模调整策略来提高可预测性。但是，如果您做出错误的选择，虚拟机将无法进行补偿。</li><li>通常，增加处理器数量同时也要增加内存，因为内存分配可以并行进行。</li></ul><h4 id="通过最小化Java堆大小来节省动态占用空间"><a href="#通过最小化Java堆大小来节省动态占用空间" class="headerlink" title="通过最小化Java堆大小来节省动态占用空间"></a>通过最小化Java堆大小来节省动态占用空间</h4><p>如果您需要最小化应用程序的动态内存占用(执行期间消耗的最大内存)，那么您可以通过最小化Java堆大小来实现这一点。Java SE嵌入式应用程序可能需要这一点。</p><p>通过降低命令行选项<code>-XX:MinHeapFreeRatio</code>(默认值为40%)和<code>-XX:MaxHeapFreeRatio</code>(默认值为70%)的值，从而最小化Java堆大小。将<code>-XX:MaxHeapFreeRatio</code>降低到低至10%，<code>-XX:MinHeapFreeRatio</code>已证明能够成功地减小堆大小，而且不会造成太大的性能降低；但是，最终的结果可能取决于你的应用。</p><p>此外，您可以指定<code>-XX:-ShrinkHeapInSteps</code>，它会立即将Java堆减小到目标大小(由参数<code>-XX:MaxHeapFreeRatio</code>指定)。此设置可能会导致性能下降。默认情况下，Java运行时会逐渐将Java堆减小到目标大小；这个过程需要多个垃圾收集周期。</p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>在总可用内存之后，影响垃圾收集性能的第二个最大影响因素是专用于新生代的比例。</p><p>新生代越大，小规模收集就越少。然而，对于给定的堆大小，较大的新生代意味着较小的老年代，这将增加大规模收集的频率。最佳选择取决于应用程序对象的生命周期分布。</p><h4 id="新生代大小选项"><a href="#新生代大小选项" class="headerlink" title="新生代大小选项"></a>新生代大小选项</h4><p>默认情况下，新生代的大小由选项<code>-XX:NewRatio</code>控制。</p><p>例如，设置<code>-XX:NewRatio=3</code>意味着新生代和老年代之间的比率是1:3。换句话说，eden和survivor空间总的大小将是总堆大小的四分之一。</p><p>选项<code>-XX:NewSize</code>和<code>-XX:MaxNewSize</code>指定了新生代的大小下界和上界。将它们设置为相同的值新生代就是固定值，正如将<code>-Xms</code>和<code>-Xmx</code>设置为相同的值可以固定总的堆大小一样。这有助于以比<code>-XX:NewRatio</code>更精细的粒度调整新生代。</p><h4 id="survivor空间大小"><a href="#survivor空间大小" class="headerlink" title="survivor空间大小"></a>survivor空间大小</h4><p>您可以使用选项<code>-XX:SurvivorRatio</code>来调整survivor空间的大小，但这通常对性能并不重要。</p><p>例如，<code>-XX:SurvivorRatio=6</code>将eden和survivor空间之间的比率设置为1:6。换句话说，每个survivor空间将是eden大小的六分之一，也就是新生代大小的八分之一(不是七分之一，因为有两个survivor空间)。</p><p>如果survivor空间太小，那么将会直接复制到老年代。如果幸存者空间太大，那么将会有很多空间永远不会使用。在每次垃圾收集时，虚拟机都会选择一个阈值，即一个对象在其转移到老年代之前可以复制的次数。选择这个阈值是为了让survivor保持半饱和状态。您可以使用日志配置<code>-Xlog:gc</code>，<code>age</code>可以用来显示这个阈值和新生代对象的年龄。它对于观察应用程序的生命周期分布也很有用。</p><p>表4-2提供了64位Solaris的默认值。</p><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left">-XX:NewRatio</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">-XX:NewSize</td><td style="text-align:left">1310 MB</td></tr><tr><td style="text-align:left">-XX:MaxNewSize</td><td style="text-align:left">not limited</td></tr><tr><td style="text-align:left">-XX:SurvivorRatio</td><td style="text-align:left">8</td></tr></tbody></table><p>新生代的最大大小是根据总堆的最大大小和<code>-XX:NewRatio</code>参数的值计算的。<code>-XX:MaxNewSize</code>参数的“无限制”意味着计算不限制，除非命令行上指定了<code>-XX:MaxNewSize</code>的值。</p><p>以下是服务器应用程序的一般指南:</p><ul><li>首先决定您可以为虚拟机提供的最大堆大小。然后，根据新生代的规模制定您的性能指标，以找到最佳设置。<ul><li>请注意，最大堆大小应始终小于机器上安装的内存量，以避免过多的页面错误和抖动。</li></ul></li><li>如果总堆大小是固定的，那么增加新生代的大小需要减少老年代的大小。保持老一代足够大，以容纳应用程序在任何给定时间使用的所有存活数据，加上一定量的富余空间(10%到20%或更多)。</li><li>根据前面提到的对老年代的限制:<ul><li>给予新生代足够的内存。</li><li>增加处理器数量的同时增加新生代的规模，因为分配可以并行化。</li></ul></li></ul><h2 id="5-可用收集器"><a href="#5-可用收集器" class="headerlink" title="5 可用收集器"></a>5 可用收集器</h2><p>本节主题：</p><ul><li>串行收集器(Serial Collector)</li><li>并行收集器(Parallel Collector)</li><li>主要并发收集器(The Mostly Concurrent Collectors)</li><li>选择收集器</li></ul><h3 id="串行收集器-Serial-Collector"><a href="#串行收集器-Serial-Collector" class="headerlink" title="串行收集器(Serial Collector)"></a>串行收集器(Serial Collector)</h3><p>串行收集器使用单个线程来执行所有垃圾收集工作，这使得它相对高效，因为线程之间没有通信开销。</p><p>它最适合单处理器机器，尽管它对于具有小数据集(大约100兆字节)的应用程序在多处理器上很有用，但它不能利用多处理器硬件的优势。默认情况下，串行收集器是在某些硬件和操作系统配置上的默认选择，或者通过选项<code>-XX:+UseSerialGC</code>显式启用。</p><h3 id="并行收集器-Parallel-Collector"><a href="#并行收集器-Parallel-Collector" class="headerlink" title="并行收集器(Parallel Collector)"></a>并行收集器(Parallel Collector)</h3><p>并行收集器也称为<em>吞吐量收集器</em>，它是与串行收集器相似的一代收集器。串行收集器和并行收集器之间的主要区别是并行收集器有多个线程用于加快垃圾收集。</p><p>并行收集器适用于运行在多处理器或多线程硬件上具有大中型数据集的应用程序。您可以通过使用<code>-XX:+UseParallelGC</code>选项来启用它。</p><p>并行压缩是一项使并行收集器能够并行执行大规模垃圾收集的功能。如果没有并行压缩，大规模垃圾收集是使用单个线程来执行的，这可能会极大地限制可伸缩性。如果指定了选项<code>-XX:+UseParallelGC</code>，则默认情况下启用并行压缩。您可以通过使用<code>-XX:-UseParallelOldGC</code>选项来禁用它。</p><h3 id="主要并发收集器-The-Mostly-Concurrent-Collectors"><a href="#主要并发收集器-The-Mostly-Concurrent-Collectors" class="headerlink" title="主要并发收集器(The Mostly Concurrent Collectors)"></a>主要并发收集器(The Mostly Concurrent Collectors)</h3><p>并发标记清除(CMS)收集器和垃圾优先(G1)垃圾收集器是两个主要并发收集器。大多数并发收集器并发执行一些代价较高应用程序工作。</p><ul><li>G1垃圾收集器:这种服务器风格的收集器是为具有大内存、多处理器机器设计的。为了满足垃圾收集暂停时间目标的同时实现高吞吐量。 在某些硬件和操作系统配置上默认选择G1，或者可以使用<code>-XX:+UseG1GC</code>显式启用。</li><li>CMS收集器:这个收集器是为那些更喜欢较短垃圾收集暂停时间的应用程序设计的，并且能够与垃圾收集共享处理器资源。使用<code>-XX:+UseConcMarkSweepGC</code>启用CMS收集器。</li></ul><p>CMS收集器在JDK 9中被标记为弃用。</p><h3 id="Z收集器"><a href="#Z收集器" class="headerlink" title="Z收集器"></a>Z收集器</h3><p>Z垃圾收集器(ZGC)是一个可扩展的低延迟垃圾收集器。ZGC同时执行所有代价高昂的工作，同时不停止应用程序线程的执行。</p><p>ZGC适用于需要低时延(暂停时间不到10 ms)和/或特大堆(几T字节)的应用。您可以通过使用<code>-XX:+UseZGC</code>选项来启用。</p><p>从JDK 11开始，ZGC作为一个实验的特性的出现。</p><h3 id="选择收集器"><a href="#选择收集器" class="headerlink" title="选择收集器"></a>选择收集器</h3><p>除非您的应用程序有相当严格的暂停时间要求，否则首先运行您的应用程序，并允许虚拟机选择收集器。</p><p>如有必要，调整堆大小以提高性能。如果性能仍然达不到您的目标，请使用以下准则作为选择收集器的出发点:</p><ul><li>如果应用程序有一个小数据集(高达大约100兆字节)，则使用选项<code>-XX:+UseSerialGC</code>选择串行收集器。</li><li>如果应用程序将在单个处理器上运行，并且没有暂停时间要求，则选择带有选项<code>-XX:+UseSerialGC</code>的串行采集器。</li><li>如果(a)应用程序性能峰值是第一优先事项，并且(b)没有暂停时间要求，或者一秒钟或更长的暂停时间是可接受的，则让虚拟机选择收集器或使用<code>-XX:+UseParallelGC</code>选择并行收集器。</li><li>如果响应时间比总吞吐量更重要，并且垃圾收集暂停时间必须保持在大约一秒钟以内，则选择一个具有<code>-XX:+UseG1GC</code>或<code>-XX:+UseConcMarkSweepGC</code>的主要并发收集器。</li><li>如果响应时间是一个高优先级，和/或您正在使用一个非常大的堆，那么选择一个具有<code>-XX:UseZGC</code>的完全并发收集器。</li></ul><p>这些准则只是选择收集器的出发点，因为性能取决于堆的大小、应用程序维护的存活数据量以及可用处理器的数量和速度。</p><p>如果推荐的收集器没有达到期望的性能，那么首先尝试调整堆和各个分代的大小以满足期望的目标。如果性能仍然不足，请尝试不同的收集器:使用并发收集器减少暂停时间，使用并行收集器增加多处理器硬件上的总吞吐量。</p><h2 id="6-并行收集器-The-Parallel-Collector"><a href="#6-并行收集器-The-Parallel-Collector" class="headerlink" title="6 并行收集器(The Parallel Collector)"></a>6 并行收集器(The Parallel Collector)</h2><p>并行收集器(这里也称为吞吐量收集器)是一个类似于串行收集器的分代收集器。串行收集器和并行收集器之间的主要区别是并行收集器有多个线程用于加快垃圾收集。</p><p>并行收集器通过命令行选项<code>-XX:+UseParallelGC</code>启用。默认情况下，使用此选项，大规模收集和小规模收集并行运行，以进一步减少垃圾收集开销。</p><p>本节主题：</p><ul><li>并行收集器垃圾收集器线程的数量</li><li>并行收集器中的分代排列</li><li>并行收集器工效学<ul><li>指定并行收集器行为选项</li><li>并行收集器指标的优先级</li><li>并行收集器各个分代空间调整</li><li>并行收集器默认堆大小<ul><li>并行收集器初始和最大堆大小的规范</li></ul></li></ul></li><li>过多的并行收集器时间和内存不足错误</li><li>并行收集器度量</li></ul><h3 id="并行收集器垃圾收集器线程的数量"><a href="#并行收集器垃圾收集器线程的数量" class="headerlink" title="并行收集器垃圾收集器线程的数量"></a>并行收集器垃圾收集器线程的数量</h3><p>在硬件线程数N大于8(感觉这里应该说的是CPU的个数，译者加)的机器上，并行收集器使用硬件线程数的固定比例作为垃圾收集器线程数。</p><p>对于较大的N值，比例为5/8。当小于8时，线程等于N。在特定的平台上，这一比例降至5/16。垃圾收集器线程的具体数量可以通过命令行选项进行调整(将在后面描述)。在只有一个处理器的主机上，由于并行执行(例如同步)所需的开销，并行收集器的性能可能不如串行收集器。但是，当具有中型到大型堆的应用程序时，运行在具有两个处理器的计算机上，它通常比串行收集器性能略好，并且当有两个以上的处理器可用时，它通常比串行收集器性能好得多。</p><p>垃圾收集器线程的数量可以通过命令行选项<code>-XX:ParallelGCThreads=&lt;N&gt;</code>来控制。如果使用命令行选项调整堆，那么并行收集器获得良好性能所需的堆大小与串行收集器所需的大小相同。但是，启用并行收集器应该会缩短收集暂停时间。因为多个垃圾收集线程同时参与一个小规模收集，所以在收集过程中，从新生代到老年代的升级可能会导致一些碎片。大规模收集中涉及的每个垃圾收集线程都会保留老年代的一部分用于升级，将可用空间划分到这些“升级缓冲区”会导致碎片效应。减少垃圾收集器线程的数量和增加老年代的大小将减少这种碎片效应。</p><h3 id="并行收集器中的分代排列"><a href="#并行收集器中的分代排列" class="headerlink" title="并行收集器中的分代排列"></a>并行收集器中的分代排列</h3><p>在并行收集器中，分代的排列是不同的。</p><p>这种布置如图6-1所示:</p><p><img src="https://docs.oracle.com/en/java/javase/12/gctuning/img/jsgct_dt_002_armgnt_gn_pl_new.png" alt="并行收集器中的分代排列"></p><h3 id="并行收集器人机工程学"><a href="#并行收集器人机工程学" class="headerlink" title="并行收集器人机工程学"></a>并行收集器人机工程学</h3><p>当使用<code>-XX:+UseParallelGC</code>选择并行收集器时，它启用了一种自动优化方法，允许您指定行为，而不是分代大小和其他低级优化细节。</p><h4 id="指定并行收集器行为的选项"><a href="#指定并行收集器行为的选项" class="headerlink" title="指定并行收集器行为的选项"></a>指定并行收集器行为的选项</h4><p>您可以指定最大垃圾收集暂停时间、吞吐量和占用空间(堆大小)。</p><ul><li>最大垃圾收集暂停时间:最大暂停时间是用命令行选项<code>-XX:MaxGCPauseMillis=&lt;N&gt;</code>指定的。这被解释为需要N毫秒或更少的暂停时间；默认情况下，没有最大暂停时间。如果指定了暂停时间，将调整堆大小和其他与垃圾收集相关的参数，以使垃圾收集暂停时间短于指定值；然而，期望的暂停时间目标可能并不总能实现。这些调整可能会导致垃圾收集器降低应用程序的总吞吐量。</li><li>吞吐量:吞吐量目标是根据垃圾收集花费的时间与垃圾收集之外花费的时间(称为<em>应用程序时间</em>)来衡量的。目标由命令行选项<code>-XX:GCTimeRatio=&lt;N&gt;</code>指定，该选项将垃圾收集时间与应用程序时间的比率设置为1 / (1 + N)(感觉应该是垃圾收集与总时间的比率，译者注)。例如，<code>-XX:GCTimeRatio=19</code>设置了垃圾收集总时间的1/20或5%的目标。默认值为99，因此垃圾收集的时间目标为1%。</li><li>占用空间:最大堆占用空间是使用选项<code>-Xmx</code>指定的。此外，收集器有一个隐含的目标，只要满足其他目标，就要最小化堆的大小。</li></ul><h4 id="并行收集器指标的优先级"><a href="#并行收集器指标的优先级" class="headerlink" title="并行收集器指标的优先级"></a>并行收集器指标的优先级</h4><p>目标按最大暂停时间指标、吞吐量指标和最小占用空间指标顺序排列：首先要满足最大暂停时间指标，只有当最大暂停时间指标达到后才会去实现吞吐量的指标，同样只有前两个指标满足后才会考虑占用空间的指标。</p><h4 id="并行收集器各个分代空间调整"><a href="#并行收集器各个分代空间调整" class="headerlink" title="并行收集器各个分代空间调整"></a>并行收集器各个分代空间调整</h4><p>收集器保存的平均暂停时间等统计信息会在每次收集结束时更新。</p><p>进行测试以确定目标是否已经实现，并对一代的空间进行任何必要的调整。例外情况是显式垃圾收集，例如，在保存统计信息和调整代的大小方面，将会忽略<code>System.gc()</code>调用的影响。</p><p>各代大小的增加和缩小是通过各代大小的固定百分比的增量来完成的，以便各个分代朝着其期望的大小递增或递减。默认情况下，一代以20%的增量增长，以5%的增量收缩。新生代和老年代的增长比例分别可以通过<code>-XX:YoungGenerationSizeIncrement=&lt;Y&gt;</code>和<code>-XX:TenuredGenerationSizeIncrement=&lt;T&gt;</code>指定。收缩比例通过<code>-XX:AdaptiveSizeDecrementScaleFactor=&lt;D&gt;</code>进行调整，如果增长比例是X%，那么收缩比例为X/D%。</p><p>如果收集器在启动时增加一代的大小，那么增量中会添加一个额外的百分比。这个百分比将会随着垃圾收集次数的增加而衰减，并不会长期存在。补充的目的是提高启动性能。收缩的百分比没有补充。</p><p>如果没有达到最大暂停时间目标，那么一次只能缩小一代的规模。如果两代的暂停时间都超过了目标，那么暂停时间较长的一代的规模将首先缩小。</p><p>如果吞吐量目标没有实现，那么两代的规模都会增加。每一个都按其对总垃圾收集时间的贡献比例增加。例如，如果新生代的垃圾收集时间是总收集时间的25%，如果新生代的完整增量是20%，那么新生代将增加5%。</p><h4 id="并行收集器默认堆大小"><a href="#并行收集器默认堆大小" class="headerlink" title="并行收集器默认堆大小"></a>并行收集器默认堆大小</h4><p>除非命令行中指定了初始堆大小和最大堆大小，否则它们是根据计算机上的内存量计算的。默认的最大堆大小是物理内存的四分之一，而初始堆大小是物理内存的六分之一。分配给新生代的最大空间量是总堆大小的三分之一。</p><h5 id="并行收集器初始和最大堆大小的规范"><a href="#并行收集器初始和最大堆大小的规范" class="headerlink" title="并行收集器初始和最大堆大小的规范"></a>并行收集器初始和最大堆大小的规范</h5><p>您可以使用选项<code>-Xms</code>(初始堆大小)和<code>-Xmx</code>(最大堆大小)指定初始和最大堆大小。</p><p>如果您知道您的应用程序需要多少堆才能正常工作，那么您可以将<code>-Xms</code>和<code>-Xmx</code>设置为相同的值。如果您不知道，那么JVM将从使用初始堆大小开始，然后增加Java堆，直到找到堆使用和性能之间的平衡。</p><p>其他参数和选项会影响这些默认值。要验证默认值，请使用<code>-XX:+PrintFlagsFinal</code>选项，并在输出中查找<code>-XX:MaxHeapSize</code>。例如，在Linux或Solaris上，您可以运行以下程序:</p><pre><code>java -XX:+PrintFlagsFinal &lt;GC options&gt; -version | grep MaxHeapSize</code></pre><h3 id="过多的并行收集器时间和内存不足错误"><a href="#过多的并行收集器时间和内存不足错误" class="headerlink" title="过多的并行收集器时间和内存不足错误"></a>过多的并行收集器时间和内存不足错误</h3><p>如果在垃圾收集中花费了太多时间，并行收集器将抛出OutOfMemoryError。</p><p>如果总时间的98%以上花在垃圾收集上，并且回收的堆少于2%，则抛出OutOfMemoryError。此功能旨在防止应用程序长时间运行，同时由于堆太小而几乎没有进展。如有必要，可以通过向命令行添加选项<code>-XX:-UseGCOverheadLimit</code>来禁用此功能。</p><h3 id="并行收集器度量"><a href="#并行收集器度量" class="headerlink" title="并行收集器度量"></a>并行收集器度量</h3><p>并行收集器的详细垃圾收集器输出与串行收集器的输出基本相同。</p><h2 id="7-主要并发收集器"><a href="#7-主要并发收集器" class="headerlink" title="7 主要并发收集器"></a>7 主要并发收集器</h2><p>主要并发收集器对应用程序并发执行收集工作，因此得名。Java HotSpot虚拟机包括两个主要并发的收集器:</p><ul><li>并发标记清除(CMS)收集器:该收集器适用于那些更喜欢较短垃圾收集暂停时间并且能够与垃圾收集共享处理器资源的应用程序。</li><li>垃圾优先(G1)垃圾收集器:这种服务器风格的收集器适用于具有大量内存的多处理器机器。它旨在满足垃圾收集暂停时间目标，同时实现高吞吐量。</li></ul><h3 id="主要并发收集器的开销"><a href="#主要并发收集器的开销" class="headerlink" title="主要并发收集器的开销"></a>主要并发收集器的开销</h3><p>主要并发收集器会占用处理器资源(原本应用程序可以使用这些资源)，以缩短主要收集暂停时间。</p><p>最明显的开销是在收集的并发部分使用一个或多个处理器。在N处理器系统中，垃圾收集的并发部分可用处理器个数为K/N，其中<code>1 &lt;= K &lt;=&#123;N/4&#125;</code>。除了在并发阶段使用处理器之外，启用并发还会产生额外的开销。因此，虽然并发收集器的垃圾收集暂停时间通常要短得多，但应用程序吞吐量也往往比其他收集器略低。</p><p>在具有多个处理核心的机器上，处理器在收集的并发部分也可用于应用程序线程，因此并发垃圾收集器线程不会暂停应用程序。这通常会导致更短的暂停时间，但是应用程序可用的处理器资源也更少，而且会有一些减速，尤其是在应用程序最大限度地使用所有处理核心的情况下。随着N的增加，由于并发垃圾收集导致的处理器资源减少变得更小，并发收集的好处也增加了。请参阅<a href="https://docs.oracle.com/en/java/javase/12/gctuning/concurrent-mark-sweep-cms-collector.html#GUID-700D5A4A-75EE-4CDC-9A43-5DF8FEBE24DD">并发模式故障</a>，其中讨论了这种模式的潜在限制。</p><p>因为在并发阶段至少有一个处理器用于垃圾收集，所以并发收集器通常在单处理器(单核)机器上不会提供任何好处。</p><h2 id="8-并发标记清除收集器"><a href="#8-并发标记清除收集器" class="headerlink" title="8 并发标记清除收集器"></a>8 并发标记清除收集器</h2><p>并发标记清除(CMS)收集器是为那些喜欢较短垃圾收集暂停时间的应用程序设计的，并且能够在应用程序运行时与垃圾收集器共享处理器资源。</p><p>典型地，具有相对较大的长寿命数据集(大的老年代)并且运行在具有两个或更多处理器的机器上的应用程序倾向于受益于该收集器的使用。CMS收集器使用<code>-XX:+UseConcMarkSweepGC</code>启用。</p><p>不推荐使用CMS收集器。强烈考虑改用垃圾优先收集器。</p><p>本节主题：</p><ul><li>并发标记清除收集器的性能和结构</li><li>并发模式故障</li><li>过多的垃圾收集时间过长和内存不足错误</li><li>并发标记清除收集器和浮动垃圾</li><li>并发标记清除收集器暂停</li><li>并发标记清除收集器并发阶段</li><li>启动并发收集周期</li><li>计划暂停</li><li>并发标记清除收集器度量</li></ul><h3 id="并发标记清除收集器的性能和结构"><a href="#并发标记清除收集器的性能和结构" class="headerlink" title="并发标记清除收集器的性能和结构"></a>并发标记清除收集器的性能和结构</h3><p>与其他可用的收集器相似，CMS收集器是分代的；因此，小规模收集和大规模收集都会发生。CMS收集器试图通过使用单独的垃圾收集线程，在执行应用程序线程的同时，跟踪可到达的对象来减少大规模收集的暂停时间。</p><p>在每次大规模收集中，CMS收集器会在收集开始时暂停所有应用程序线程一段时间，在收集期间再次暂停。第二次暂停往往比第一次长。多个线程在两次暂停期间执行收集工作。一个或多个垃圾收集线程完成剩余的收集工作(包括大部分对存活对象的跟踪和对不可达对象的清除)。小规模收集可以与正在进行的大规模收集交叉进行，并且以类似于并行收集的方式完成(特别是小规模收集暂停期间)。</p><h3 id="并发模式故障"><a href="#并发模式故障" class="headerlink" title="并发模式故障"></a>并发模式故障</h3><p>CMS收集器使用一个或多个垃圾收集器线程，这些线程与应用程序线程同时运行，目的是在老年代变满之前完成老年代的收集。</p><p>如前所述，在正常操作中，CMS收集器在应用程序线程仍在运行的情况下执行大部分跟踪和扫描工作，因此应用程序线程只能看到短暂的暂停。但是，如果CMS收集器无法在老年代填满之前回收不可访问的对象，或者如果内存分配不能满足老年代中的可用空闲空间，则应用程序会暂停，并且收集会在所有应用程序线程停止的情况下完成。无法并发完成收集被称为<em>并发模式故障(concurrent mode failure)</em>，意味着需要调整CMS收集器参数。如果并发收集被显式垃圾收集(System.gc())或为诊断工具的垃圾收集中断，则报告一个并发模式中断。</p><h3 id="过多的垃圾收集时间过长和内存不足错误"><a href="#过多的垃圾收集时间过长和内存不足错误" class="headerlink" title="过多的垃圾收集时间过长和内存不足错误"></a>过多的垃圾收集时间过长和内存不足错误</h3><p>如果在垃圾收集中花费了太多时间，如果总时间的98%以上花费在垃圾收集中，并且恢复的堆少于2%，则抛出OutOfMemoryError。</p><p>此功能旨在防止应用程序长时间运行，同时由于堆太小而几乎没有进展。如有必要，可以通过向命令行添加选项<code>-XX:-UseGCOverheadLimit</code>来禁用此功能。</p><p>该策略与并行收集器中的策略相同，只是执行并发收集所花费的时间不计入98%的时间限制。换句话说，只有在应用程序停止时执行的收集才会计入过多的垃圾收集时间。这种收集通常是由于并发模式故障或显式收集请求(例如，对System.gc()的调用)。</p><h3 id="并发标记清除收集器和浮动垃圾"><a href="#并发标记清除收集器和浮动垃圾" class="headerlink" title="并发标记清除收集器和浮动垃圾"></a>并发标记清除收集器和浮动垃圾</h3><p>同Java HotSpot虚拟机中的所有其他收集器一样，CMS收集器是一个跟踪收集器，它需要标识堆中所有可到达的对象。</p><p>理查德·琼斯和拉斐尔·林在他们的出版物《垃圾收集:自动动态内存算法》中说，这是一个增量更新收集器。因为应用程序线程和垃圾收集器线程在主要收集过程中同时运行，垃圾收集器线程跟踪的对象可能随后在收集过程结束时变得不可访问。这种尚未被回收的不可达对象被称为<em>浮动垃圾</em>。浮动垃圾的数量取决于并发收集周期的持续时间和应用程序引用更新的频率，也称为<em>突变(mutations)</em>。此外，因为新生代和老年代是独立收集的，彼此互为可达性分析的根(root)。作为一个粗略的指导方针，试着将老年代的空间增加20%，以解决漂浮垃圾的问题。一个并发收集周期结束时堆中的浮动垃圾将在下一个收集周期中收集。</p><h3 id="并发标记清除收集器暂停"><a href="#并发标记清除收集器暂停" class="headerlink" title="并发标记清除收集器暂停"></a>并发标记清除收集器暂停</h3><p>CMS收集器在并发收集周期内暂停应用程序两次。第一个暂停是将从根(例如，来自应用程序线程堆栈和寄存器的对象引用、静态对象等)和堆中其他地方(例如，新生代)直接可达对象标记为存活对象。</p><p>第一次暂停称为<em>初始标记暂停(initial mark pause)</em>。第二次暂停发生在并发跟踪阶段的末尾，并在CMS收集器完成对对象的跟踪后，查找由于应用程序线程更新对象中的引用而被并发跟踪遗漏的对象。第二次暂停称为<em>备注暂停(remark pause)</em>。</p><h3 id="并发标记清除收集器并发阶段"><a href="#并发标记清除收集器并发阶段" class="headerlink" title="并发标记清除收集器并发阶段"></a>并发标记清除收集器并发阶段</h3><p>可达对象图的并发跟踪发生在初始标记暂停和备注暂停之间。</p><p>在这个并发跟踪阶段，一个或多个并发垃圾收集器线程可能在使用处理器，原本这些资源对于应用程序是可用的。因此，即使应用程序线程没有暂停，在此阶段和其他并发阶段，应用程序的吞吐量也会相应降低。备注暂停后，并发清理阶段收集不可达的对象。收集周期完成后，CMS收集器等待，几乎不消耗计算资源，直到下一个主要收集周期开始。</p><h3 id="启动并发收集周期"><a href="#启动并发收集周期" class="headerlink" title="启动并发收集周期"></a>启动并发收集周期</h3><p>对于串行收集器，每当老年代变满，所有应用程序线程都停止，开始一次大规模收集。相比之下，CMS收集器中并发收集的开始时间必须确保收集能够在老年代变满之前完成；否则，由于并发模式故障，应用程序会观察到较长的暂停时间。有几种方法可以开始并发收集。</p><p>根据最近的历史记录，CMS收集器会对老年代耗尽之前剩余的时间以及并发收集周期所需的时间进行估计。使用这些动态估计，开始并发收集周期，目的是在老年代耗尽之前完成收集周期。为了安全起见，对这些估计留有余量，因为并发模式故障的代价可能非常高。</p><p>如果老年代的占用率超过初始占用率(老年代的百分比)，并发收集也会开始。启动并发周期的默认值约为92%，但该值会随版本的不同而变化。该值可以使用命令行选项<code>-XX:CMSInitiatingOccupancyFraction=&lt;N&gt;</code>手动调整，其中N是老年代大小的整数百分比(0到100)。</p><h3 id="计划暂停"><a href="#计划暂停" class="headerlink" title="计划暂停"></a>计划暂停</h3><p>新生代和老年代的暂停是独立发生的。</p><p>它们不会重叠，但可能会快速连续发生，一次收集的暂停，紧接着另一次收集的暂停，看起来可能是一个更长的暂停。为了避免这种情况，CMS收集器试图将备注暂停安排在上一次和下一次新生代代暂停的中间。当前没有为初始标记暂停进行这种调度，初始标记暂停通常比备注暂停短得多。</p><h3 id="并发标记清除收集器度量"><a href="#并发标记清除收集器度量" class="headerlink" title="并发标记清除收集器度量"></a>并发标记清除收集器度量</h3><p>以下是带有选项<code>-Xlog:gc</code>的CMS收集器的输出:</p><pre><code>[121,834s][info][gc] GC(657) Pause Initial Mark 191M-&gt;191M(485M) (121,831s, 121,834s) 3,433ms[121,835s][info][gc] GC(657) Concurrent Mark (121,835s)[121,889s][info][gc] GC(657) Concurrent Mark (121,835s, 121,889s) 54,330ms[121,889s][info][gc] GC(657) Concurrent Preclean (121,889s)[121,892s][info][gc] GC(657) Concurrent Preclean (121,889s, 121,892s) 2,781ms[121,892s][info][gc] GC(657) Concurrent Abortable Preclean (121,892s)[121,949s][info][gc] GC(658) Pause Young (Allocation Failure) 324M-&gt;199M(485M) (121,929s, 121,949s) 19,705ms[122,068s][info][gc] GC(659) Pause Young (Allocation Failure) 333M-&gt;200M(485M) (122,043s, 122,068s) 24,892ms[122,075s][info][gc] GC(657) Concurrent Abortable Preclean (121,892s, 122,075s) 182,989ms[122,087s][info][gc] GC(657) Pause Remark 209M-&gt;209M(485M) (122,076s, 122,087s) 11,373ms[122,087s][info][gc] GC(657) Concurrent Sweep (122,087s)[122,193s][info][gc] GC(660) Pause Young (Allocation Failure) 301M-&gt;165M(485M) (122,181s, 122,193s) 12,151ms[122,254s][info][gc] GC(657) Concurrent Sweep (122,087s, 122,254s) 166,758ms[122,254s][info][gc] GC(657) Concurrent Reset (122,254s)[122,255s][info][gc] GC(657) Concurrent Reset (122,254s, 122,255s) 0,952ms[122,297s][info][gc] GC(661) Pause Young (Allocation Failure) 259M-&gt;128M(485M) (122,291s, 122,297s) 5,797ms</code></pre><blockquote><p>注意：CMS收集器的输出(GC标识657)与小规模收集的输出(GC标识658、659和660)穿插在一起；通常，会有多次小规模收集发生在并发收集周期中。初始标记暂停(Pause Initial Mark)表示并发收集周期的开始。以Concurrent为开头的行表示并发阶段的开始和结束。Pause Remark是备注暂停。前面没有讨论预清洗阶段。预清洗是指在准备备注暂停阶段可以同时完成的工作。最后阶段由并发重置指示(Concurrent Reset)，并为下一个并发收集做准备。</p></blockquote><p>初始标记暂停通常相对于小规模收集暂停时间较短。并发阶段(并发标记、并发预清洗和并发清除)通常持续的时间比小规模收集暂停时间长得多，如CMS收集器输出示例所示。但是，请注意，在这些并发阶段，应用程序不会暂停。备注暂停的长度通常相当于一次小规模收集。备注暂停受某些应用程序特征(例如，对象修改率提高会增加暂停)和自上次小规模收集以来的时间(例如，新生代中的更多对象可能会增加暂停)的影响。</p><h2 id="9-垃圾优先收集器"><a href="#9-垃圾优先收集器" class="headerlink" title="9 垃圾优先收集器"></a>9 垃圾优先收集器</h2><p>本节介绍垃圾优先(G1)收集器。</p><p>本节主题：</p><ul><li>垃圾优先收集器简介</li><li>启用垃圾优先收集器</li><li>基本概念<ul><li>堆布局</li><li>垃圾收集周期</li></ul></li><li>深入垃圾优先收集器内部<ul><li>确定初始堆占用率</li><li>标记</li><li>堆资源紧张下的行为</li><li>大对象</li><li>纯新生代收集阶段规模</li><li>空间回收阶段收集规模</li></ul></li><li>G1的工程学默认值</li><li>与其他收集器的对比</li></ul><h3 id="垃圾优先收集器简介"><a href="#垃圾优先收集器简介" class="headerlink" title="垃圾优先收集器简介"></a>垃圾优先收集器简介</h3><p>垃圾优先(G1)收集器针对具有大量内存的多处理器机器。它试图高概率地达到垃圾收集暂停时间目标，同时无需配置就能实现高吞吐量。G1旨在利用应用程序和环境在延迟和吞吐量之间实现最佳平衡，这些应用程序和环境的功能包括:</p><ul><li>堆大小高达几十GB或更大，超过50%的Java堆被存活数据占据。</li><li>随着时间的推移，对象分配和升级的速率可能会有很大变化。</li><li>堆中有大量碎片。</li><li>可预测的暂停时间，不超过几百毫秒，避免长时间的垃圾收集暂停。</li></ul><p>G1取代了并发标记清除(CMS)收集器。它也是默认的收集器。</p><p>G1采集器实现了高性能，并试图通过以下几节中描述的几种方式来实现暂停时间目标。</p><h3 id="启用垃圾优先收集器"><a href="#启用垃圾优先收集器" class="headerlink" title="启用垃圾优先收集器"></a>启用垃圾优先收集器</h3><p>垃圾优先垃圾收集器是默认收集器，因此通常您不必执行任何额外的操作。您可以通过在命令行上提供<code>-XX:+UseG1GC</code>来显式启用它。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>G1是一个分代的、渐进的、并发的、疏散垃圾收集器，它监控每次stop-the-world暂停中的暂停时间目标。与其他收集器一样，G1将这堆分成(虚拟的)新生代和老年代。空间回收工作集中在最有效的新生代，而老年代偶尔才会进行空间回收。</p><p>为了提高吞吐量，有些操作总是在stop-the-world时执行。其他操作(如<em>全局标记</em>等整体堆操作)可能需要更多时间将与应用程序并行执行。为了让空间回收时stop-the-world的时间更短，G1逐步并行地进行空间回收。G1通过跟踪关于先前应用程序行为和垃圾收集暂停的信息来建立相关成本的模型，从而实现可预测性。它使用这些信息来调整暂停中完成的工作。例如，G1首先回收最高效区域的空间(即大部分被垃圾填满的区域，因此得名)。</p><p>G1主要通过疏散来回收空间:将选定存储区域中的存活对象复制到新的存储区域中，在这个过程中对它们进行压缩。疏散完成后，先前由存活对象占据的空间将重新分配给应用程序。</p><p>垃圾优先收集器不是实时收集器。它试图在更长的时间内高概率地达到设定的暂停时间目标，但对于给定的暂停并不总是能达到的。</p><h4 id="堆布局"><a href="#堆布局" class="headerlink" title="堆布局"></a>堆布局</h4><p>G1将堆分成一组大小相等的堆区域(region)，每个区域都是一个连续的虚拟内存范围，如图9-1所示。区域是内存分配和内存回收的单位。在任何给定的时间，这些区域中的每一个都可以是空的(浅灰色)，或者分配给特定的一代，新生的或老年的。当内存请求进来时，内存管理器会分配空闲区域。内存管理器将它们分配给一代，然后将它们作为空闲空间返给应用程序，应用程序可以将它们分配给自己。</p><p><img src="https://docs.oracle.com/en/java/javase/12/gctuning/img/jsgct_dt_004_grbg_frst_hp.png" alt="G1堆布局"></p><p>新生代包含eden区域(红色)和survivor区域(红色带“S”)。这些区域提供了与其他收集器中连续空间相同的功能，不同之处在于，在G1，这些区域通常在内存中以不连续的模式排列。(浅蓝色)组成了老年代。对于跨越多个区域的对象，老年代区域可能非常大(浅蓝色，带“H”)。</p><p>一个应用程序总是先分配给新生代，也就是eden区域，除了那些被直接分配给老年代的巨大对象。</p><h4 id="垃圾收集周期"><a href="#垃圾收集周期" class="headerlink" title="垃圾收集周期"></a>垃圾收集周期</h4><p>在高层次上，G1收集器在两个阶段之间交替。纯年轻阶段(young-only)包含垃圾收集，这些垃圾收集逐渐用老年代中的对象填充当前可用的内存。空间回收阶段(space-reclamation)，G1除了处理新生代的事务外，还逐步回收老年代的空间。然后，循环从一个纯新生代的阶段重新开始。</p><p>图9-2给出了这个循环的概述，并举例说明了可能发生的垃圾收集暂停序列:</p><p><img src="https://docs.oracle.com/en/java/javase/12/gctuning/img/jsgct_dt_001_grbgcltncyl.png" alt="垃圾收集周期"></p><p>下面的列表详细描述了G1垃圾收集周期的各个阶段、它们的暂停以及各个阶段之间的过渡:</p><ol><li>纯年轻阶段:这个阶段从几个普通的收集开始，这些收集将对象升级到老年代。纯年轻阶段和空间回收阶段之间的过渡开始于老年代占用率达到某个阈值(启动堆占用率阈值)时。此时，G1计划启动并发新生代收集(Concurrent Start young collection)，而不是普通新生代收集(Normal young collection)。<ul><li>并发开始(Concurrent Start):这种类型的收集除了执行普通的收集之外，还开始标记过程。并发标记决定了老年代中所有当前可达(活动)的对象将被保留到下一个空间回收阶段。普通的新生代收集可能会出现在标记尚未完成时。标记结束时有两个特殊stop-the-world暂停:备注(Remark)和清理(Cleanup)。</li><li>备注(Remark)：这种暂停完成标记本身，执行全局引用处理和类卸载，回收完全空的区域并清理内部数据结构。在“备注”和“清理”之间，G1计算能够同时回收的选定老年代区域可用空间，这将在“清理”暂停中完成。</li><li>清理(Cleanup)：这一暂停决定了空间回收阶段是否会真正到来。如果随后是空间回收阶段，则纯年轻阶段将以一个有准备的混合新生代收集来完成。</li></ul></li><li>空间回收阶段：该阶段包括多个混合收集，除新生代区域外，还疏散老年代区域集合中的活动对象。当G1确定疏散更多的老年代空间性价比不高时，空间回收阶段就结束了。</li></ol><p>空间回收后，收集周期从另一个纯年轻阶段重新开始。作为备份，如果应用程序在收集活动信息时耗尽内存，G1会像其他收集器一样执行一次就地完整堆压缩(完整垃圾收集, Full GC)。</p><h4 id="垃圾收集暂停和收集集合"><a href="#垃圾收集暂停和收集集合" class="headerlink" title="垃圾收集暂停和收集集合"></a>垃圾收集暂停和收集集合</h4><p>G1在stop-the-world暂停时进行垃圾收集和空间回收。存活对象通常从源区域复制到堆中的一个或多个目标区域，并调整对这些移动对象的现有引用。</p><p>对于非大型区域，对象的目标区域由该对象的源区域确定:</p><ul><li>新生代的对象(eden和survivor区域)被复制到survivor或老年代，这取决于他们的年龄。</li><li>老年代区域的对象被复制到其他老年代区域。</li></ul><p>巨大区域中的对象被区别对待。G1只决定他们的活跃度，如果它们死掉，收回它们占据的空间。大区域内的物体不会被G1移动。</p><p>收集集合是要从中回收空间的源区域集。根据垃圾收集的类型，收集集合由不同类型的区域组成:</p><ul><li>在纯年轻阶段，集合仅由新生代中的区域和具有潜在可回收对象的巨大区域组成。</li><li>在空间回收阶段，由新生代的区域、具有潜在可回收对象的巨大区域以及收集组候选区域中的一些老年代区域组成。</li></ul><p>G1在并发周期中准备垃圾收集的候选区域。在备注暂停期间，G1选择占用空间占用低的区域，这些区域包含大量可用空间。然后，在“备注”和“清理”暂停之间同时准备这些区域，以便以后收集。清理暂停会根据效率对其进行排序。在随后的混合收集中，优先选择包含更多空闲空间的高效区域，这些区域收集时间更少。</p><h3 id="深入垃圾优先收集器内部"><a href="#深入垃圾优先收集器内部" class="headerlink" title="深入垃圾优先收集器内部"></a>深入垃圾优先收集器内部</h3><p>本节描述了垃圾优先(G1)垃圾收集器的一些重要细节。</p><h4 id="确定初始堆占用率"><a href="#确定初始堆占用率" class="headerlink" title="确定初始堆占用率"></a>确定初始堆占用率</h4><p>G1在调整Java堆的大小时遵守标准规则，使用<code>-XX:InitialHeapSize</code>作为最小Java堆大小，<code>-XX:MaxHeapSize</code>作为最大Java堆大小，<code>-XX:MinHeapFreeRatio</code>代表最小可用内存比率，<code>-XX:MaxHeapFreeRatio</code>用于确定调整大小后最大可用内存百分比。G1收集器在备注暂停和完整收集中调整Java堆的大小。此过程可能会向操作系统返还内存或从操作系统分配内存。</p><h4 id="纯新生代收集规模"><a href="#纯新生代收集规模" class="headerlink" title="纯新生代收集规模"></a>纯新生代收集规模</h4><p>G1总是在下一个突变阶段的普通新生代收集结束时对新生代进行评估。通过对实际暂停时间长时间的观察，G1可以达到<code>-XX:MaxGCPauseTimeMillis</code>和<code>-XX:PauseTimeIntervalMillis</code>设置的暂停时间目标。它会考虑相似大小的新生代疏散需要多长时间。这包括在收集过程中需要复制多少对象，以及这些对象之间的关联程度等信息。</p><p>如果没有其他约束，那么G1自适应地将年轻一代的大小调整在<code>-XX:G1NewSizePercent</code>和<code>-XX:G1MaxNewSizePercent</code>设定的暂停时间之间。有关如何修复长暂停的更多信息，请参见<a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A">垃圾优先垃圾收集器优化</a>。</p><p>或者，<code>-XX:NewSize</code>与<code>-XX:MaxNewSize</code>的组合可以分别用于设置最小和最大新生代大小。</p><h4 id="空间回收阶段收集规模"><a href="#空间回收阶段收集规模" class="headerlink" title="空间回收阶段收集规模"></a>空间回收阶段收集规模</h4><p>在空间回收阶段，G1试图在一次垃圾收集暂停中最大化老年代回收的空间量。新生代的大小被设置为允许的最小值，通常由<code>-XX:G1NewSizePercent</code>决定。</p><p>在此阶段的每个混合收集开始时，G1从候选收集集合中选择一组区域。这组额外的老年代区域由三部分组成:</p><ul><li>老年代区域的最小集合，以确保疏散进度。这组老年代区域由候选区域的数量除以空间回收阶段的长度决定，空间回收阶段的长度由<code>-XX:G1MixedGCCountTarget</code>决定。</li><li>如果G1预测在收集完上述最小集合后还会有时间，则收集集合中的其他老年代区域将成为候选区域。添加老年代区域，直到预计将使用80%的剩余时间。</li><li>一组可选的收集集合区域，在上面两个部分被疏散后，G1会逐渐疏散这些集合区域，如果在此暂停中还有时间。</li></ul><p>前两组区域在初始收集过程中收集，如有剩余的暂停时间再收集可选区域。由于可选集合的管理，这种方法确保了空间回收的进展，同时提高了达到暂停时间的概率，并且使开销最小。</p><p>当候选区域中的剩余可回收空间小于<code>-XX:G1HeapWastePercent</code>设定的值，空间回收阶段结束。</p><p>有关G1将使用多少老年代区域以及如何避免长时间混合收集暂停的更多信息，请参见<a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A">垃圾优先垃圾收集器优化</a>。</p><h4 id="定期垃圾收集"><a href="#定期垃圾收集" class="headerlink" title="定期垃圾收集"></a>定期垃圾收集</h4><p>如果由于应用程序不活动而长时间没有垃圾收集，虚拟机可能会长时间保留大量未使用的内存，这些内存可能在其他地方使用。为了避免这种情况，G1可能会被迫使用<code>-XX:G1PeriodicGCInterval</code>选项进行常规垃圾收集。此选项确定G1考虑执行垃圾收集的最小时间间隔(毫秒)。如果自上次垃圾收集暂停后经过了这段时间，并且没有正在进行的并发循环，G1会触发额外的垃圾收集，可能会产生以下影响:</p><ul><li>在纯年轻阶段:G1使用并发开始暂停(Concurrent Start)来开始并发标记，或者，如果指定了<code>-XX:-G1PeriodicGCInvokesConcurrent</code>，则为完整GC。</li><li>在空间回收阶段:G1会触发适合当前进度的垃圾收集暂停类型来继续空间回收阶段。</li></ul><p><code>-XX:G1PeriodicGCSystemLoadThreshold</code>选项可用于优化垃圾收集是否被触发:如果JVM主机系统(例如，容器)上的<code>getloadavg()</code>调用返回的平均一分钟系统负载值高于该值，则不会运行定期垃圾收集。</p><p>有关定期垃圾收集的更多信息，请参见<a href="https://openjdk.java.net/jeps/346">JEP 346:立即从G1返回未使用的已提交内存</a>。</p><h4 id="确定初始堆占用率-1"><a href="#确定初始堆占用率-1" class="headerlink" title="确定初始堆占用率"></a>确定初始堆占用率</h4><p>初始堆占用率(IHOP，Initiating Heap Occupancy Percent)是触发初始标记收集(Initial Mark)的阈值，定义为老年代大小的百分比。默认情况下，G1通过观察标记需要多长时间以及在标记周期中老年代通常分配多少内存来自动确定最佳IHOP。这一特性被称为自适应IHOP。如果此功能被激活，在没有足够的观察结果来对启动堆占用率阈值进行良好的预测时，选项<code>-XX:InitiatingHeapOccupancyPercent</code>将作为老年代大小的百分比的初始值。使用选项<code>-XX:-G1UseAdaptiveIHOP</code>关闭G1的此行为。在这种情况下，值<code>-XX:InitiatingHeapOccupancyPercent</code>决定这个阈值。</p><p>在内部，自适应IHOP尝试设置初始堆占用，以便当老年代占用处于当前最大老年代大小减去作为额外缓冲区的<code>-XX:G1HeapReservePercent</code>值时，开始空间回收阶段的第一次混合垃圾收集。</p><h4 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h4><p>G1标记使用了一种叫做<em>开始快照(Snapshot-At-The-Beginning，SATB)</em>的算法。它在初始标记暂停时获取堆的虚拟快照，只要标记开始时活动的对象在标记的剩余时间都被认为是存活的。这意味着，为了空间回收的目的(除了一些例外)，在标记过程中变死(不可到达)的物体仍然被认为是活的。与其他收集器相比，这可能会导致一些额外的内存被错误地保留。然而，这可能会让SATB在备注暂停期间提供更好的时延。在该标记过程中过于保守考虑的活动对象将在下一个标记过程中被回收。有关标记问题的更多信息，请参见主题<a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A">垃圾优先垃圾收集器优化</a>。</p><h4 id="堆资源紧张下的行为"><a href="#堆资源紧张下的行为" class="headerlink" title="堆资源紧张下的行为"></a>堆资源紧张下的行为</h4><p>当应用程序占据如此多的内存以至于疏散无法找到足够的空间来复制时，就会发生疏散失败。疏散失败意味着G1只复制已经移动的对象到新位置来完成当前的垃圾收集，而不复制任何尚未移动的对象，只调整它们之间的引用。疏散失败可能会产生一些额外的开销，但通常和其他新生代收集一样快。在这次垃圾收集和疏散失败后，G1将恢复正常应用，没有任何其他措施。G1会假设疏散失败发生在垃圾收集接近结束时；也就是说，大多数对象已经被移动，并且还有足够的空间继续运行应用程序，直到标记完成和空间回收开始。</p><p>如果这个假设不成立，那么G1最终将安排一个完整垃圾收集。这种类型的收集对整个堆执行就地压缩。这可能很慢。</p><p>请参阅<a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A">垃圾优先垃圾收集器优化</a>，了解有关分配失败或在发出内存不足信号之前发生完全垃圾收集器故障的更多信息。</p><h4 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h4><p>大对象是大于或等于半个区域大小的对象。除非使用<code>-XX:G1HeapRegionSize</code>选项进行设置，否则当前区域大小是按照G1工效学默认值部分中所述进行的。</p><p>这些大对象有时会被特殊对待:</p><ul><li>在老年代中，每个大对象都被分配为一系列连续的区域。对象本身的起点总是位于序列中第一个区域的起点。在整个对象被回收之前，序列最后一个区域中的任何剩余空间都不会被分配。</li><li>一般来说，只有在清理暂停(Cleanup)期间标记结束时，或者在完整垃圾收集期间大对象无法访问的情况下，才会回收大对象。然而，对于原始类型数组(例如bool、各种整数和浮点值)的大对象有一个特殊的规定。如果在任何垃圾收集暂停期间，这样的大对象没有被多个对象引用，G1将会回收它。这种行为默认是启用的，你可以使用<code>-XX:G1EagerReclaimHumongousObjects</code>禁用它。</li><li>大对象的分配可能会导致垃圾收集过早发生。G1在每个大对象分配中检查初始堆占用率阈值，如果当前占用率超过该阈值，可能会立即强制进行初始的新生代垃圾收集标记。</li><li>大对象从不移动，即使在完整的垃圾收集也是如此。这可能会导致过早的慢速完整垃圾收集或大量区域空间碎片而导致的内存不足情况。</li></ul><h3 id="G1的工程学默认值"><a href="#G1的工程学默认值" class="headerlink" title="G1的工程学默认值"></a>G1的工程学默认值</h3><p>本主题概述了G1特有的最重要的设置及其默认值。他们给出了没有附加选项G1的预期行为和资源使用的粗略概述。</p><table><thead><tr><th style="text-align:left">选项和默认值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>-XX:MaxGCPauseMillis=200</code></td><td style="text-align:left">最大暂停时间</td></tr><tr><td style="text-align:left"><code>-XX:GCPauseTimeInterval=&lt;ergo&gt;</code></td><td style="text-align:left">最大暂停时间间隔。默认情况下，G1没有设定任何值，允许G1在极端情况下连续收集垃圾。</td></tr><tr><td style="text-align:left"><code>-XX:ParallelGCThreads=&lt;ergo&gt;</code></td><td style="text-align:left">垃圾收集期间用于并行工作的最大线程数。规则如下:如果进程可用的CPU线程数少于或等于8，使用相等的线程数。否则，为线程数的5/8。在每次暂停开始时，使用的最大线程数还会受到总的堆大小的限制:每个<code>-XX:HeapSizePerGCThread</code>不会多于一个线程。</td></tr><tr><td style="text-align:left"><code>-XX:ConcGCThreads=&lt;ergo&gt;</code></td><td style="text-align:left">用于并发工作的最大线程数。默认情况下，该值为<code>-XX:ParallelGCThreads</code>除以4。</td></tr><tr><td style="text-align:left"><code>-XX:+G1UseAdaptiveIHOP</code><br> <code>-XX:InitiatingHeapOccupancyPercent=45</code></td><td style="text-align:left">控制初始堆占用率的默认值，表示自适应IHOP已打开，并且在最初的几个收集周期中，G1将使用45%作为老年代标记开始的阈值。</td></tr><tr><td style="text-align:left"><code>-XX:G1HeapRegionSize=&lt;ergo&gt;</code></td><td style="text-align:left">堆区域大小。堆包含大约2048个堆区域。堆区域的大小可以从1到32 MB不等，必须是2的幂。</td></tr><tr><td style="text-align:left"><code>-XX:G1NewSizePercent=5</code><br><code>-XX:G1MaxNewSizePercent=60</code></td><td style="text-align:left">新生代总的大小，在这两个值之间，总的堆空间的百分比。</td></tr><tr><td style="text-align:left"><code>-XX:G1HeapWastePercent=5</code></td><td style="text-align:left">候选收集集合未回收空间的百分比。如果候选集合中的可用空间低于该值，G1将停止空间回收阶段。</td></tr><tr><td style="text-align:left"><code>-XX:G1MixedGCCountTarget=8</code></td><td style="text-align:left">空间回收阶段的预期长度。</td></tr><tr><td style="text-align:left"><code>-XX:G1MixedGCLiveThresholdPercent=85</code></td><td style="text-align:left">在空间回收阶段，不会收集存活对象占用率高于这个百分比的老年代区域。</td></tr></tbody></table><blockquote><p>注意：<code>&lt;ergo&gt;</code>意味着实际值是根据环境确定的。</p></blockquote><h3 id="与其他收集器的对比"><a href="#与其他收集器的对比" class="headerlink" title="与其他收集器的对比"></a>与其他收集器的对比</h3><p>这里总结一下G1和其他收集齐之间主要区别:</p><ul><li>并行收集器将老年代空间作为一个整体来压缩和回收。G1逐渐将这项工作分解为多个更小的垃圾收集工作。这大大缩短了暂停时间，但这可能会牺牲吞吐量</li><li>和CMS收集器类似，G1并发的执行老年代空间的收集。然而除非进行完整垃圾收集，CMS不能整理老年代的碎片。</li><li>由于其并发性，G1的开销可能高于上述收集器，进而影响吞吐量。</li><li>ZGC的目标是特大型堆，旨在牺牲更高的吞吐量来提供更短的暂停时间。</li></ul><p>由于其工作原理，G1有一些独特的机制来提高垃圾收集效率:</p><ul><li>在任何收集过程中，G1都可以回收一些空的老年代空间。这可以避免许多其他不必要的垃圾收集，轻易就可以释放大量空间。</li><li>G1可以选择性的消除堆上的重复字符串。</li></ul><p>从老一代回收空的大对象默认是启用的。您可以使用选项<code>-XX:-G1EagerReclaimHumongousObjects</code>禁用此功能。默认情况下，字符串重复数据消除处于禁用状态。您可以使用选项<code>-XX:+G1EnableStringDeduplication</code>来启用它。</p><h2 id="10-垃圾优先垃圾收集器优化"><a href="#10-垃圾优先垃圾收集器优化" class="headerlink" title="10 垃圾优先垃圾收集器优化"></a>10 垃圾优先垃圾收集器优化</h2><p>本节描述了如何在垃圾优先垃圾收集器(G1垃圾收集器)不符合您的要求的情况下调整它的行为。</p><p>本节主题：</p><ul><li>对G1的一般性建议</li><li>从其他收集器迁移到G1</li><li>改进G1的性能<ul><li>观察完整垃圾收集</li><li>大对象碎片</li><li>时延优化<ul><li>异常系统或实时使用</li><li>引用对象处理时间过长</li><li>纯年轻阶段纯新生代垃圾收集时间过长</li><li>混合收集时间过长</li><li>更新记忆集和扫描记忆集时间过高</li></ul></li><li>吞吐量优化</li><li>堆的大小优化</li><li>默认值优化</li></ul></li></ul><h3 id="对G1的一般性建议"><a href="#对G1的一般性建议" class="headerlink" title="对G1的一般性建议"></a>对G1的一般性建议</h3><p>一般建议使用G1的默认设置即可，然后给它一个不同的暂停时间设置，并根据需要使用<code>-Xmx</code>设置最大的Java堆大小。</p><p>与其他收集器不同，G1的默认值做了不同的平衡。默认配置中，G1的目标既不是最大吞吐量，也不是最低时延，而是在高吞吐量下提供相对较小、均匀的暂停。然而，G1递增式的空间回收机制和暂停时间控制会在应用程序线程和空间回收效率方面产生一些开销。</p><p>如果您想要高吞吐量，那么可以使用<code>-XX:MaxGCPauseMillis</code>来放宽暂停时间目标，或者提供一个更大的堆。如果时延是主要要求，则修改暂停时间设置。避免使用<code>-Xmn</code>，<code>-XX:NewRatio</code>等选项将新生代的规模限制在特定值，因为新生代的规模是G1用来满足暂停时间的主要手段。将新生代的大小设置为固定值会覆盖并实际上禁用暂停时间控制。</p><h3 id="从其他收集器迁移到G1"><a href="#从其他收集器迁移到G1" class="headerlink" title="从其他收集器迁移到G1"></a>从其他收集器迁移到G1</h3><p>通常，当从其他收集器(尤其是CMS收集器)迁移到G1时，首先要删除所有影响垃圾收集的选项，只需要设置暂停时间以及使用<code>-Xmx</code>和可选的<code>-Xms</code>设置总堆大小。</p><p>对于其他收集器，许多选项对其响应很有用，但它们对于G1起来说，要么根本不起作用，要么甚至降低吞吐量和达到暂停时间目标的可能性。一个例子是设定新生代的规模，这完全阻止了G1调整新生代的规模以达到设置的暂停时间目标。</p><h3 id="改进G1性能"><a href="#改进G1性能" class="headerlink" title="改进G1性能"></a>改进G1性能</h3><p>G1旨在提供良好的整体性能，而无需指定其他选项。然而，有些情况下，默认的启发式方法或默认配置效果可能不是最优的。本节给出了一些诊断和改善这些情况的指南。本指南仅描述了在给定一组应用程序的情况下，G1在给定指标下提高垃圾收集器性能的可能性。在具体案例上，应用程序级优化可能比试图调整虚拟机性能更好更有效，例如，通过使用寿命较短的对象完全避免一些有问题的情况。</p><p>出于诊断目的，G1提供全面的日志。一个好的开始是使用<code>-Xlog:gc*=debug</code>选项，然后在必要时从中提炼输出内容。日志提供了关于垃圾收集活动暂停期间和暂停之外的详细概述。这包括收集的类型和在暂停的特定阶段花费的时间的细节。</p><p>以下小节探讨了一些常见的性能问题。</p><h4 id="观察完整垃圾收集"><a href="#观察完整垃圾收集" class="headerlink" title="观察完整垃圾收集"></a>观察完整垃圾收集</h4><p><em>完整堆垃圾收集(Full GC)</em>通常非常耗时。老年代占用率过高导致的完整收集可以在日志中查找单词”Pause Full (Allocation Failure)”得到。完整收集通常紧跟在一个”to-space exhausted”标签标示的垃圾收集之后。</p><p>发生完整垃圾回收的原因是应用程序分配了太多无法快速回收的对象。通常并发标记不能及时完成，以开始空间回收阶段。许多大对象的分配可能会增加进入完整收集的可能性。由于这些对象在G1的分配方式，它们可能会占用比预期多得多的内存。</p><p>目标应该是确保并发标记按时完成。这可以通过降低老年代的分配率或者给并发标记更多的时间来完成。</p><p>G1给了你几个选项来更好地处理这种情况:</p><ul><li>您可以使用gc+heap=info日志来确定Java堆上大对象占据的区域数量。”Humongous regions: X-&gt;Y”行中的Y表示大对象占据的区域数量。如果与老年代的数量相比，该数较高，最好的选择是尝试减少区域的数量。您可以通过使用<code>-XX:G1HeapRegionSize</code>选项增加区域大小来实现这一点。当前选择的堆区域大小打印在日志的开头。</li><li>增加Java堆的大小。这通常会增加标记完成的时间。</li><li>通过显式设置<code>-XX:ConcGCThreads</code>，增加并发标记线程的数量。</li><li>迫使G1提前开始标记。G1根据应用程序行为自动确定IHOP阈值。如果应用程序行为改变，这些预测可能是错误的。有两种选择:通过修改<code>-XX:G1ReservePercent</code>来增加自适应IHOP计算中使用的缓冲区，从而降低何时开始空间回收的目标占用率；或者，通过使用<code>-XX:-G1UseAdaptiveIHOP</code>和<code>-XX:InitiatingHeapOccupancyPercent</code>手动设置IHOP的阈值。</li></ul><p>除了内存分配失败完整收集通常是由应用程序或某个外部工具导致的。如果原因是<code>System.gc()</code>，并且没有办法修改应用程序源码，则可以通过使用<code>-XX:+ExplicitGCInvokesConcurrent</code>或通过设置<code>-XX:+DisableExplicitGC</code>让虚拟机完全忽略它们来减轻完整收集的影响。外部工具可能仍然会强制完整垃圾收集，不用它们的时候就把它们删除。</p><h4 id="大对象碎片"><a href="#大对象碎片" class="headerlink" title="大对象碎片"></a>大对象碎片</h4><p>为了寻找连续区域，完整垃圾收集可能会在堆内存耗尽之前就进行。一个潜在的选项是提高-XX:G1HeapRegionSize的值，从而降低大对象占用的区域数，或者增加堆的整体大小。在极端情况下，即使可用内存足够G1却找不到充足的连续区域，这将会导致虚拟机退出。因此，除了前面提到的减少大对象分配或者增加堆之外，没有其他选择。</p><h4 id="时延优化"><a href="#时延优化" class="headerlink" title="时延优化"></a>时延优化</h4><p>本节讨论了在常见时延问题(即暂停时间过高)的情况下如何改善G1行为。</p><h5 id="异常系统或实时使用"><a href="#异常系统或实时使用" class="headerlink" title="异常系统或实时使用"></a>异常系统或实时使用</h5><p>对于每一次垃圾收集暂停，gc+cpu=info日志输出都包含一行包含来自操作系统的信息，并附有垃圾收集时间明细。这种输出的一个例子是<code>User=0.19s Sys=0.00s Real=0.01s</code>。</p><p>用户时间(User)是在虚拟机代码中花费的时间，系统时间(Sys)是在操作系统中花费的时间，实时(Real)是在暂停期间经过的绝对时间量。如果系统时间相对较长，那么最常见的原因是环境。</p><p>系统时间过高的常见原因：</p><ul><li>虚拟机从操作系统内存分配或返还内存可能会导致不必要的时延。通过使用选项<code>-Xms</code>和<code>-Xmx</code>将最小和最大堆大小设置为相同的值，并使用<code>-XX:+AlwaysPreTouch</code>预接触所有内存，将此工作移到虚拟机启动阶段，从而避免延迟。</li><li>特别是在Linux中，通过透明大页面(THP)功能将小页面合并成大页面往往会拖延随机进程，而不仅仅是在垃圾收集暂停期间。因为虚拟机分配并维护大量内存，所以虚拟机成为长时间停顿的进程的风险比通常情况下要高。请参考操作系统文档，了解如何禁用透明大页面功能。</li><li>日志写入输出可能会暂停一段时间，因为一些后台任务会间歇性地占用日志写入的硬盘的输入/输出带宽。考虑为日志或其他存储使用单独的磁盘，例如内存备份文件系统，以避免这种情况。</li></ul><p>另一个需要注意的情况是实时比其他情况的总和大得多，这可能表明虚拟机在可能过载的机器上没有获得足够的CPU时间。</p><h5 id="引用对象处理时间过长"><a href="#引用对象处理时间过长" class="headerlink" title="引用对象处理时间过长"></a>引用对象处理时间过长</h5><p>引用对象处理发生在引用处理阶段。在引用处理阶段，G1根据引用对象的类型更新引用。默认情况下，G1尝试使用以下启发式方法来并发进行引用处理:对于每<code>-XX:ReferencesPerThread</code>个引用对象启动一个线程，最多<code>-XX:ParallelGCThreads</code>个线程。默认情况下，可以通过将<code>-XX:ReferencesPerThread</code>设置为0来禁用此启发式算法，或者通过<code>-XX:-ParallelRefProcEnabled</code>完全禁用并行化。</p><h5 id="纯年轻阶段纯新生代垃圾收集时间过长"><a href="#纯年轻阶段纯新生代垃圾收集时间过长" class="headerlink" title="纯年轻阶段纯新生代垃圾收集时间过长"></a>纯年轻阶段纯新生代垃圾收集时间过长</h5><p>一般来说，任何新生代收集需要的时间大致与新生代的大小成比例，或者更具体地说，与其中需要复制的存活对象数量成比例。如果疏散收集(Evacuate Collection Set)花费的时间太长，特别是对象复制子阶段(Object Copy)，则减少<code>-XX:G1NewSizePercent</code>。这减少了新生代的最小尺寸，停顿的时间可能更短。</p><p>如果应用程序性能，特别是幸存的对象数量突然改变，新生代的规模可能会导致垃圾收集暂停时间激增。通过使用<code>-XX:G1MaxNewSizePercent</code>来减小新生代的规模可能是有用的。这限制了新生代的最大尺寸，因此也限制了垃圾收集需要处理的对象数量。</p><h5 id="混合收集时间过长"><a href="#混合收集时间过长" class="headerlink" title="混合收集时间过长"></a>混合收集时间过长</h5><p>混合收集用来回收老年代的空间。混合收集区域包含新生代和老年代区域。通过启用gc+ergo+cset=trace打印日志输出，您可以获得新生代或老年代区域的疏散时间对暂停时间的影响。分别查看新生代区域和老年代区域的暂停时间。</p><p>如果新生代时间太长，则查看上一节<em>纯年轻阶段纯新生代垃圾收集时间过长</em>。否则，为了减少老年代对暂停时间的贡献，G1提供了三种选择:</p><ul><li>增加-XX:G1MixedGCCountTarget将垃圾收集扩散到更多的老年代区域</li><li>通过使用-XX:G1MixedGCLiveThresholdPercent，避面将占用率高的区域放入候选收集集合中。在许多情况下，高占用率的区域需要大量时间来收集。</li><li>尽早停止老年代的空间回收，这样G1就不会收集那么多高度占用的区域。在这种情况下，增加<code>-XX:G1HeapWastePercent</code>百分比。</li></ul><p>请注意，后两个选项减少了当前空间回收阶段可回收空间候选区域的数量。这可能意味着G1可能无法在老年代中回收足够的空间用于持续运营。然而，稍后的空间回收阶段可能收集它们。</p><h5 id="更新记忆集和扫描记忆集时间过高"><a href="#更新记忆集和扫描记忆集时间过高" class="headerlink" title="更新记忆集和扫描记忆集时间过高"></a>更新记忆集和扫描记忆集时间过高</h5><p>为了使G1能够疏散单个老年代区域，G1跟踪<em>跨区域引用(cross-region references)</em>的位置，即从一个区域指向另一个区域的引用。指向给定区域的跨区域引用集称为该区域的<em>记忆集(remembered set)</em>。移动区域内容时，必须更新记忆集。区域记忆集的维护大多是同时进行的。出于性能考虑，当应用程序的两个对象之间建立新的跨区域引用时，G1不会立即更新。记忆集更新请求会被延迟并批量处理以提高效率。</p><p>G1需要完整的记忆集进行垃圾收集，因此垃圾收集的<em>更新记忆集(Update RS)</em>阶段会处理任何未完成的更新请求。<em>扫描记忆集(Scan RS)</em>阶段会搜索记忆集中引用的对象，移动区域的内容，更新到新的引用位置。根据应用程序的不同，这两个阶段可能会花较长的时间。</p><p>使用选项<code>-XX:G1HeapRegionSize</code>调整堆区域的大小会影响跨区域引用的数量以及记忆集的大小。处理区域的记忆集可能是垃圾收集工作的一个重要部分，因此这对最大暂停时间有直接影响。较大的区域往往具有较少的跨区域引用，因此处理这些引用所花费的相对工作量会减少，尽管与此同时，较大的区域可能意味着每个区域要疏散更多的存活对象，从而增加了其他阶段的时间。</p><p>G1尝试并发处理记忆集的更新，更新阶段花费时间大概是最大暂停时间的<code>-XX:G1RSetUpdatingPauseTimePercent</code>。通过降低该值，G1通常会以更高的并发进行记忆集更新工作。</p><p>批量更新记忆集可能会导致记忆集更新与大对象分配合并在一起，从而造成虚假的更新时间过长。如果批处理正好发生在垃圾收集之前，那么就需要处理记忆集更新的所有工作。使用<code>-XX:-ReduceInitialCardMarks</code>禁用这种行为，潜在的避免这种情况。</p><p>记忆集扫描时间还取决于G1保存记忆集的压缩量。记忆集在内存中存储得越紧凑，在垃圾收集过程中检索存储值所需的时间就越长。G1自动执行这种压缩，称为记忆集粗化(coarsening)，同时根据该区域记忆集的当前大小更新记忆集。特别是在最高压缩级别，检索数据可能会非常慢。使用-XX:G1SummarizeRSetStatsPeriod选项和gc+remset=trace日志级别可以显示是否有粗化发生。如果是这样，那么在<code>Before GC Summary</code>之前部分中的<code>Did &lt;X&gt; coarsenings</code>行中X显示一个高值。增加<code>-XX:G1RSetRegionEntries</code>选项可以显著的降低粗化量。避免在生产环境中使用详细的记忆集日志记录，因为收集此数据可能会花费大量时间。</p><h4 id="吞吐量优化"><a href="#吞吐量优化" class="headerlink" title="吞吐量优化"></a>吞吐量优化</h4><p>G1的默认策略试图在吞吐量和延迟之间保持平衡；然而，有些情况下需要更高的吞吐量。除了如前所述减少总暂停时间之外，暂停的频率也可以减少。主要思想是通过使用<code>-XX:MaxGCPauseMillis</code>来增加最大暂停时间。分代大小启发式算法将自动调整新生代的大小，这直接决定暂停的频率。如果这没有导致预期的行为，特别是在空间回收阶段，使<code>用-XX:G1NewSizePercent</code>增加新生代的规模将迫使G1这样做。</p><p>在某些情况下，-XX:G1MaxNewSizePercent：允许的新生代最大规模，可以通过限制新生代规模来限制吞吐量。这可以通过查看gc+heap=info日志来诊断。在这种情况下，eden区域和survivor区域总的百分比接近于<code>-XX:G1MaxNewSizePercent</code>。在这种情况下，考虑增加<code>-XX:G1MaxNewSizePercent</code>的值。</p><p>增加吞吐量的另一个选择是尝试减少并发工作量。特别是，并发更新记忆集通常需要大量的CPU资源。增加<code>-XX:G1RSetUpdatingPauseTimePercent</code>将并发操作挪到垃圾收集阶段。在最糟糕的情况下，通过设置<code>-XX:-G1UseAdaptiveConcRefinement -XX:G1ConcRefinementGreenZone=2G -XX:G1ConcRefinementThreads=0</code>可以完全禁用这种机制，将记忆集更新工作挪到下一次垃圾收集。</p><p>通过使用<code>-XX:+UseLargePages</code>启用大页面也可以提高吞吐量。请参考操作系统文档，了解如何设置大页面。</p><p>将选项<code>-Xms</code>和<code>-Xmx</code>设置为相同的值，您可以通过禁用堆大小调整。此外，您可以使用<code>-XX:+AlwaysPreTouch</code>将操作系统工作放在虚拟机的启动时间，虚拟机使用物理内存支持的虚拟内存。为了使暂停时间更加一致，这两种方法都是特别理想的。</p><h4 id="堆的大小优化"><a href="#堆的大小优化" class="headerlink" title="堆的大小优化"></a>堆的大小优化</h4><p>和其他收集器一样，G1将调整堆的大小使垃圾收集所花费的时间低于<code>-XX:GCTimeRatio</code>选项所设定的比率。调整此选项，使G1符合您的要求。</p><h4 id="默认值优化"><a href="#默认值优化" class="headerlink" title="默认值优化"></a>默认值优化</h4><p>本节介绍了默认值和本主题中介绍的命令行选项的一些附加信息。</p><table><thead><tr><th style="text-align:left">选项和默认值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>-XX:+G1UseAdaptiveConcRefinement</code><br><code>-XX:G1ConcRefinementGreenZone=&lt;ergo&gt;</code><br><code>-XX:G1ConcRefinementYellowZone=&lt;ergo&gt;</code><br><code>-XX:G1ConcRefinementRedZone=&lt;ergo&gt;</code><br><code>-XX:G1ConcRefinementThreads=&lt;ergo&gt;</code></td><td style="text-align:left">并发记忆集更新使用这些选项来控制并发线程的工作分配。G1为这些选项选择符合工效学的值，使用-XX:G1RSetUpdatingPauseTimePercent设置垃圾收集暂停中剩余工作花费时间，根据需要自适应的调整。更改时务必小心，因为这可能会导致非常长的暂停时间。</td></tr><tr><td style="text-align:left"><code>-XX:+ReduceInitialCardMarks</code></td><td style="text-align:left">初始对象分配中记忆集并发修改</td></tr><tr><td style="text-align:left"><code>-XX:+ParallelRefProcEnabled</code><br><code>-XX:ReferencesPerThread=1000</code></td><td style="text-align:left"><code>-XX:ReferencesPerThread</code>决定并发的程度：每N个引用有一个线程进行引用处理，线程数最多<code>-XX:ParallelGCThreads</code>。值为0表示始终使用<code>-XX:ParallelGCThreads</code>值所指示的最大线程数。这决定了<code>java.lang.Ref.*</code>实例的处理是否应该由多个线程并发完成。</td></tr><tr><td style="text-align:left"><code>-XX:G1RSetUpdatingPauseTimePercent=10</code></td><td style="text-align:left">这决定了G1在记忆集更新时间占垃圾收集总时间的百分比。G1使用此设置控制记忆集更新并发的数量。</td></tr><tr><td style="text-align:left"><code>-XX:G1SummarizeRSetStatsPeriod=0</code></td><td style="text-align:left">控制多少次垃圾收集生成记忆集摘要报告。将此设置为零以禁用。生成记忆集摘要报告是一项成本很高的操作，因此只有在必要时才应该使用，并且要把值设的高一些。使用gc+remset=trace打印所有内容。</td></tr><tr><td style="text-align:left"><code>-XX:GCTimeRatio=12</code></td><td style="text-align:left">这是垃圾收集上的时间与应用程序的时间之比。用于确定垃圾收集中可以花费的时间的目标分数的实际公式是1 / (1 + GCTimeRatio)。该默认值将会导致有大约8%的时间用于垃圾收集。</td></tr><tr><td style="text-align:left"><code>-XX:G1PeriodicGCInterval=0</code></td><td style="text-align:left">检查G1是否应该触发定期垃圾收集的时间间隔(毫秒)。设置为零禁用。</td></tr><tr><td style="text-align:left"><code>-XX:+G1PeriodicGCInvokesConcurrent</code></td><td style="text-align:left">如果设置，定期垃圾收集会触发并发标记或继续现有收集周期，否则会触发完整垃圾收集。</td></tr><tr><td style="text-align:left"><code>-XX:G1PeriodicGCSystemLoadThreshold=0.0</code></td><td style="text-align:left">触发定期垃圾收集的系统负载阈值，当前系统负载可以通过调用<code>getloadavg()</code>获得。高于此值的系统负载不会进行定期垃圾收集。零值表示此阈值检查被禁用。</td></tr></tbody></table><blockquote><p>注意：<code>&lt;ergo&gt;</code>意味着实际值是根据环境确定的。</p></blockquote><h2 id="11-Z收集器"><a href="#11-Z收集器" class="headerlink" title="11 Z收集器"></a>11 Z收集器</h2><p>Z垃圾收集器(ZGC)是一个可扩展的低延迟垃圾收集器。ZGC并发执行所有代价高昂的工作，停止应用程序线程的时间不会超过10ms，这使得它适用于需要低时延和/或特大堆(几T字节)的应用程序。</p><p>Z垃圾收集器是一个实验特性，并通过命令行选项<code>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code>启用。</p><h3 id="设置堆大小"><a href="#设置堆大小" class="headerlink" title="设置堆大小"></a>设置堆大小</h3><p>ZGC最重要的调整选项是设置最大堆大小(<code>-Xmx</code>)。由于ZGC是一个并发收集器，因此必须按如下方法选择最大堆大小，1)堆可以容纳应用程序的存活对象，2)即使在垃圾收集运行时也有足够的堆空间分配给应用程序。需要多少空间在很大程度上取决于应用程序的分配速率和存活对象大小。总的来说，你给ZGC的内存越多越好。但与此同时，浪费内存是不可取的，所以这一切都是为了在内存使用和垃圾收集运行频率之间找到平衡。</p><h3 id="设置垃圾收集的并发数"><a href="#设置垃圾收集的并发数" class="headerlink" title="设置垃圾收集的并发数"></a>设置垃圾收集的并发数</h3><p>第二个可能需要考虑的调整选项是设置并发GC线程的数量(<code>-XX:ConcGCThreads</code>)。ZGC有启发式算法自动选择这个数。这种启发式方法通常运行良好，但是根据应用程序的特点，这可能需要调整。这个选项本质上决定了应该给垃圾收集多少CPU时间。给它太多，垃圾收集器会从应用程序中窃取太多的CPU时间。给它太少，应用程序产生垃圾的速度可能会比垃圾收集速度快。</p><h2 id="12-其他情况"><a href="#12-其他情况" class="headerlink" title="12 其他情况"></a>12 其他情况</h2><p>本节涵盖影响垃圾收集的其他情况。</p><p>本节主题：</p><ul><li>弱引用、软引用和幻像引用的终结</li><li>显式垃圾收集</li><li>软引用</li><li>类元数据</li></ul><h3 id="弱引用、软引用和幻像引用的终结"><a href="#弱引用、软引用和幻像引用的终结" class="headerlink" title="弱引用、软引用和幻像引用的终结"></a>弱引用、软引用和幻像引用的终结</h3><p>一些应用程序通过使用弱引用、软引用和幻像引用的终结(Finalization)来与垃圾收集交互。</p><p>这些特性可能在Java编程语言级别造成性能隐患。这方面的一个例子是依赖于终结来关闭文件描述符，这使得外部资源(描述符)依赖于垃圾收集的及时性。依靠垃圾收集来管理内存以外的资源几乎总是一个坏主意。</p><p>请参见<a href="http://www.devx.com/Java/Article/30192">如何处理Java终结的内存保留问题</a>，其中深入讨论了终结的一些陷阱以及避免它们的技术。</p><h3 id="显式垃圾收集"><a href="#显式垃圾收集" class="headerlink" title="显式垃圾收集"></a>显式垃圾收集</h3><p>应用程序与垃圾收集交互的另一种方式是使用<code>System.gc()</code>显式调用完整的垃圾收集。</p><p>这可能会在不必要的时候强制进行大规模垃圾收集(例如，当小规模收集就足够了)，因此通常应该避免。显式垃圾收集的性能影响可以通过使用标志<code>-XX:+DisableExplicitGC</code>禁用它们来衡量，这将导致虚拟机忽略对<code>System.gc()</code>的调用。</p><p>显式垃圾收集最常见的一种用途是远程方法调用(RMI)的分布式垃圾收集(DGC)。使用RMI的应用程序引用其他虚拟机中的对象。如果不偶尔进行本地堆的垃圾收集，就无法收集这些分布式应用程序中的垃圾，因此RMI会强制定期进行完整垃圾收集。这些收集的频率可以通过属性来控制，如下例所示:</p><pre><code>java -Dsun.rmi.dgc.client.gcInterval=3600000    -Dsun.rmi.dgc.server.gcInterval=3600000 ...</code></pre><p>本示例指定每小时一次显式垃圾收集，而不是默认的每分钟一次。但是，这也可能导致一些对象需要更长时间才能被回收。如果不希望对DGC活动的及时性有上限，可以将这些属性设为<code>Long.MAX_VALUE</code>，这样显式收集时间间隔实际上是无限的。</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用在服务器模式的虚拟机中保持活动的时间比在客户端模式的虚拟机长。</p><p>清除速率可以通过命令行选项<code>-XX:SoftRefLRUPolicyMSPerMB=&lt;N&gt;</code>来控制，该选项为每兆字节的可用堆空间一个软引用保持活动状态的毫秒数(ms)(一旦它不可达)。默认值为每兆字节1000毫秒，这意味着对于堆中每兆字节的可用空间，软引用将保留1秒钟(在收集到对象的最后一个强引用之后)。这是一个大概的数字，因为软引用仅在垃圾收集期间被清除，垃圾收集可能偶尔发生。</p><h3 id="类元数据"><a href="#类元数据" class="headerlink" title="类元数据"></a>类元数据</h3><p>Java类在Java Hotspot虚拟机中有一个内部表示，称为类元数据。</p><p>在先前版本的Java Hotspot虚拟机中，类元数据是在所谓的永久代(permanent generation)中分配的。从JDK 8开始，永久代被删除，类元数据被分配到本机内存中。默认情况下，可用于类元数据的本机内存量不受限制。使用选项<code>-XX:MaxMetaspaceSize</code>设置类元数据的上限。</p><p>Java Hotspot虚拟机显式地管理元数据空间。从操作系统请求空间，然后将其分成块。类加载器从其块中为元数据分配空间(块绑定到特定的类加载器)。当为类加载器卸载类时，它的块会被循环使用或返回到操作系统。元数据使用<code>mmap</code>而不是<code>malloc</code>分配的空间。</p><p>如果<code>-XX:UseCompressedOops</code>已打开，并且<code>-XX:UseCompressedClassesPointers</code>已使用，则本机内存的两个逻辑上不同的区域将用于类元数据。<code>-XX:UseCompressedClassPointers</code>使用32位偏移量来表示64位进程中的类指针，就像<code>-XX:UseCompressedOops</code>用于Java对象引用一样。这些压缩的类指针(32位偏移量)将分配一个区域。区域的大小可以用<code>-XX:CompressedClassSpaceSize</code>设置，默认为1gb。压缩类指针的空间在初始化时被保留为<code>-XX:mmap</code>分配的空间，并根据需要提交。<code>-XX:MaxMetaspaceSize</code>用于确定提交的压缩类空间和其他类元数据的空间之和。</p><p>当相应的Java类被卸载时，类元数据被回收。垃圾收集可能会导致Java类卸载和元数据被回收。当为类元数据提交的空间达到某个级别(高水位线)时，就会引发垃圾收集。垃圾收集后，高水位线可能会根据从类元数据中释放的空间量而升高或降低。高水位线可能会升高，以免过早引发另一次垃圾收集。高水位线初值为命令行选项<code>-XX:MetaspaceSize</code>的值，并根据选项<code>-XX:MaxMetaspaceFreeRatio</code>和<code>-XX:MinMetaspaceFreeRatio</code>升高或降低。如果类元数据的申请空间中可用空间百分比大于<code>-XX:MaxMetaspaceFreeRatio</code>，则高水位线将会降低。如果它小<code>-XX:MinMetaspaceFreeRatio</code>，那么高水位线将会升高。</p><p>为选项<code>-XX:MetaspaceSize</code>指定一个高一些的值，以避免引发过早的垃圾收集。为应用程序分配的类元数据的数量取决于应用程序，并且不存在选择<code>-XX:MetaspaceSize</code>的一般准则。<code>-XX:MetaspaceSize</code>的默认大小取决于平台，范围从12 MB到20 MB不等。</p><p>关于元数据所用空间的信息包含在堆的日志输出中。以下是典型输出:</p><pre><code>[0,296s][info][gc,heap,exit] Heap[0,296s][info][gc,heap,exit] garbage-first heap total 514048K, used 0K [0x00000005ca600000, 0x00000005ca8007d8, 0x00000007c0000000)[0,296s][info][gc,heap,exit] region size 2048K, 1 young (2048K), 0 survivors (0K)[0,296s][info][gc,heap,exit] Metaspace used 2575K, capacity 4480K, committed 4480K, reserved 1056768K[0,296s][info][gc,heap,exit] class space used 238K, capacity 384K, committed 384K, reserved 1048576K</code></pre><p>在以Metaspace开头的行中，used是用于加载类的空间量。capacity是当前分配块中元数据的可用空间。committed是块的可用空间量。reserved是为元数据保留(但不一定提交)的空间量。以class space开头的行包含压缩类指针的元数据相应值。</p><h2 id="附录：主要中英文名词翻译对照表"><a href="#附录：主要中英文名词翻译对照表" class="headerlink" title="附录：主要中英文名词翻译对照表"></a>附录：主要中英文名词翻译对照表</h2><table><thead><tr><th style="text-align:left">英文</th><th style="text-align:left">中文</th></tr></thead><tbody><tr><td style="text-align:left">Minor Collection</td><td style="text-align:left">小规模垃圾收集</td></tr><tr><td style="text-align:left">Major Collection</td><td style="text-align:left">大规模垃圾收集</td></tr><tr><td style="text-align:left">Young Generation</td><td style="text-align:left">新生代</td></tr><tr><td style="text-align:left">Old Generation</td><td style="text-align:left">老年代</td></tr><tr><td style="text-align:left">Ergonomics</td><td style="text-align:left">工效学</td></tr><tr><td style="text-align:left">The Mostly Concurrent Collectors</td><td style="text-align:left">主要并发收集器</td></tr><tr><td style="text-align:left">Full GC</td><td style="text-align:left">完整垃圾收集</td></tr><tr><td style="text-align:left">Young-only Phase</td><td style="text-align:left">纯年轻阶段</td></tr><tr><td style="text-align:left">Space-reclamation Phase</td><td style="text-align:left">空间回收阶段</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在不懂点虚拟机都不好意思说是Java程序员了，这方面的文章不少，但质量参差不齐。在百度谷歌上看了一圈大部分是你抄我我抄你，要不就是泛泛而谈，看完之后还是一头雾水，看到Oracle官网上有一篇将虚拟机调优的文章&lt;a href=&quot;https://www.oracle.com/
      
    
    </summary>
    
      <category term="技术人生" scheme="https://pingao777.github.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="Java" scheme="https://pingao777.github.io/tags/Java/"/>
    
      <category term="垃圾收集" scheme="https://pingao777.github.io/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"/>
    
      <category term="虚拟机" scheme="https://pingao777.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务隔离小记</title>
    <link href="https://pingao777.github.io/2019/03/31/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E5%B0%8F%E8%AE%B0/"/>
    <id>https://pingao777.github.io/2019/03/31/MySQL事务隔离小记/</id>
    <published>2019-03-31T05:28:34.000Z</published>
    <updated>2020-09-12T03:14:00.583Z</updated>
    
    <content type="html"><![CDATA[<p>大家都知道事务系统有四大特征：原子性、一致性、隔离性、持久性。隔离性是其中重要的一环，什么是隔离呢，顾名思义就是事务之间啥时候可见啥时候不可见，这就是MySQL的四个隔离级别：</p><ul><li>未提交读（read uncommited）</li><li>提交读（read commited）</li><li>可重复读（repeatable read）</li><li>串行读（serializable）</li></ul><a id="more"></a><p>其实前两种从名字上就能理解什么意思，未提交读是事务没提交呢，别的事务就读到了，也就是可以读取事务的中间状态，即常说的脏读，这违反了事务的原子性和一致性；提交读呢，只有事务提交了，其他事务才可以读取，提交读解决了脏读问题却存在如下问题，比如A事务和B事务并行执行，假设A事务第一次读取了字段name是“小明”，这个时候B事务修改了name为“小红”，接下来A事务又读取了这个字段，发现“小明”变成了“小红”，“小明”去哪了，说好的隔离呢，这种问题被称为不可重复读，所以有时候提交读也称为不可重复读。</p><p>可重复读就是为解决不可重复读问题而出现的另一个隔离级别，也是MySQL的默认事务隔离级别。但是可重复读也不是完美无缺的，比如A事务和B事务同时执行，A先查找name字段为“小红”的记录发现没有，这时候B添加name为“小红”的记录，A又执行一次查询，发现有“小红”这条记录了，即所谓的幻行，A像产生了幻觉一样，这种问题被称为幻读。</p><p>串行读就是所有的事务串行化执行，看似完美解决了所有的问题，却付出了加锁同步的代价。</p><p>总结四种级别的问题矩阵：</p><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻度</th><th style="text-align:center">加锁读</th></tr></thead><tbody><tr><td style="text-align:center">未提交读</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">提交读</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">可重复读</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">串行读</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">是</td></tr></tbody></table><p>综合来看，第一种隔离级别太低违反了原子性和一致性，最后一种串行读效率太低在实际项目中鲜见使用，第二第三种都有一个幻读的问题，接下来看看MySQL如何解决这个问题。</p><p>MySQL使用了一种称之为多版本并发控制（MVCC）的机制，通过在每行记录后面保存两个隐藏列，一个保存了行的创建时间，一个保存了行的删除时间，这里的“时间”实际上是版本号，说到版本号你可能会猜测这应该是一种类似于乐观锁的并发控制机制，没错，MySQL就是通过这两个列实现了一种乐观锁。每当开始一个事务，系统版本号自动递增，事务开始的版本号作为事务的版本号，下面分别看看各种操作下这两个版本号是如何控制并发的。</p><ul><li>查询操作（select）时，读取创建时间小于等于事务版本且删除时间未定义或大于事务版本的那些行，翻译成人话就是只读取本次事务添加或之前就存在，并且至少截止到本次事务还没有删除的那些记录。</li><li>插入时（insert），行的创建时间设置为当前系统版本号。</li><li>删除时（delete），删除时间设为系统版本号。</li><li>修改时（update），将当前版本号作为新行的创建时间和旧行的删除时间，可见修改相当于删除和插入两个动作。</li></ul><p>回过头看上面A第二次读取时如果按这种方式就不会出现幻行，因为A只会读取A之前就存在和A自身插入的行。但是MVCC如果工作在提交读的情况下，不就没法读取新提交的记录了，这与提交读的语义不是矛盾了？</p><p>带着这个疑问去看MySQL官方说明，原来MySQL有一个<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_consistent_read">consistent read</a>的概念，MySQL通过快照（snapshot）给每个事务返回结果，在可重复读的情况下快照由<strong>本事务第一次</strong>读取操作决定，也就是快照在第一次读取操作时就定了（本事务如果更新或删除其他事务提交的记录将会更新快照），而提交读<strong>事务每次</strong>读取都会更新快照。那么问题来了，快照是如何生成的呢？其实MySQL增加的两列不是上面所述的“创建时间”和“删除时间”，而是DB_TRX_ID，即最后一个对本行进行操作的事务版本号，另一个是DB_ROLL_PTR，称为滚动指针，它指向<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_undo_log">undo log</a>，undo log中包含了恢复到未修改前数据的必要信息，比方说insert了一条记录，undo log里就存上一条delete。MySQL就是利用这两个隐藏列和undo log来构建快照的，下面以一个简单的示例说明一下，假设当前隔离级别为可重复读：</p><p><img src="https://wocanmei-hexo.nos-eastchina1.126.net/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E5%B0%8F%E8%AE%B0/undo_log.png" alt="快照构建示例"></p><ol><li>事务1首先insert一条name为小红的记录，undo log里插入一条delete记录：事务：1：delete 小红，DB_TRX_ID为事务版本号：1，DB_ROLL_PTR指向undo log的第1条记录</li><li>事务2执行select name=小红操作，由于DB_TRX_ID小于当前事务版本2，所以小红这条记录对事务2可见，最终小红这条记录返回</li><li>在事务2执行过程中，事务3将小红更新成了小明，DB_TRX_ID需要更新成最新的事务版本号3，DB_ROLL_PTR指向undo log的第2条记录：事务：3：update 小明-&gt;小红</li><li>事务2又执行select name=小红操作，由于DB_TRX_ID大于2，也就是在当前事务之后修改的，所以需要借助undo log回滚构建快照（不是真正的回滚），执行DB_ROLL_PTR指向的记录：update：事务：3：update 小明-&gt;小红，name由小明变为小红，执行select语句还是返回这条记录</li></ol><p>当然MySQL真正的实现肯定比这复杂的多，这只是我根据看到的文档抽象的一个简化模型。</p><p>参考资料：</p><ul><li>高性能MySQL</li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html">Consistent Nonlocking Reads</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html">InnoDB Multi-Versioning</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家都知道事务系统有四大特征：原子性、一致性、隔离性、持久性。隔离性是其中重要的一环，什么是隔离呢，顾名思义就是事务之间啥时候可见啥时候不可见，这就是MySQL的四个隔离级别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未提交读（read uncommited）&lt;/li&gt;
&lt;li&gt;提交读（read commited）&lt;/li&gt;
&lt;li&gt;可重复读（repeatable read）&lt;/li&gt;
&lt;li&gt;串行读（serializable）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="三言两语" scheme="https://pingao777.github.io/categories/%E4%B8%89%E8%A8%80%E4%B8%A4%E8%AF%AD/"/>
    
    
      <category term="事务" scheme="https://pingao777.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="MySQL" scheme="https://pingao777.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>万锁之母AbstractQueuedSynchronizer</title>
    <link href="https://pingao777.github.io/2019/03/12/%E4%B8%87%E9%94%81%E4%B9%8B%E6%AF%8DAbstractQueuedSynchronizer/"/>
    <id>https://pingao777.github.io/2019/03/12/万锁之母AbstractQueuedSynchronizer/</id>
    <published>2019-03-12T07:55:02.000Z</published>
    <updated>2020-09-12T03:14:00.585Z</updated>
    
    <content type="html"><![CDATA[<p>翻看<a href="https://pingao777.github.io/2019/03/07/Java%E2%80%9C%E9%94%81%E2%80%9D%E8%AE%B0/">Java“锁”记</a>中提到的各种“锁”，其内部同步实现大多数都和一个类<code>AbstractQueuedSynchronizer</code>相关，这个类称得上“万锁之母”，所以今天就来扒一扒这个类。</p><a id="more"></a><h2 id="整体脉络"><a href="#整体脉络" class="headerlink" title="整体脉络"></a>整体脉络</h2><p>为了避免一头扎进去纠缠于各种细节出不来，可以先从宏观上来看一下这个类。首先大家思考一个问题：什么是同步器？假如把线程比作车辆，同步器的角色和警察叔叔差不多，警察的做的事无非是在合适的时机指挥车辆走和停，同步器呢，也是在选择合适的时间调度线程阻塞和执行。</p><p>对于车辆来说，什么时候走什么时候停呢，警察叔叔给你招手的时候啊，来来来小伙子，否则就老老实实排队，等警察叔叔给你招手；对于线程来讲也可以采用这种策略，获得许可可以执行，否则排队阻塞，等同步器给与你许可。如果前方交通比较疏松，警察可能一次会叫好几辆车一起走，如果比较拥堵，则会一辆一辆的来；同步器呢同样如此，它有两种模式：共享和独占，前者允许多个线程一起运行，后者只允许单一线程运行。</p><p>如果用伪代码表示上面的逻辑可能是这样子的：</p><pre><code class="java">// 获得许可while (不允许获得许可) &#123;    线程排队    停止执行&#125;从队伍里出来继续执行// 释放许可if (允许释放许可) &#123;    释放许可    叫醒排队的线程&#125;</code></pre><p>经过上面的分析大致可以提炼出同步器要解决这么几点：</p><ol><li>许可怎么获取和释放</li><li>线程采用什么方法停止和继续执行</li><li>对于不能立马获得许可的线程得有排队机制</li></ol><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>说是源码分析其实是自己在学习<code>AbstractQueuedSynchronizer</code>源码的一些学习笔记，并不是完整的源码分析。相信想了解<code>AbstractQueuedSynchronizer</code>运行机制的人多多少少都看过它的代码了，甚至看了一遍都不止，其实大部分代码一般人都能看懂，就是有那么几处难懂的代码，犹如芒刺在背不拔不快。本文就是为了这个目的而写的，并不是要面面俱到而是重点突破，给有心人一点启发。为了符合上下文的语义，下面描述的时候可能节点和线程交替使用，也会把阻塞停止，唤醒叫醒混用，大家留意就是了。</p><p><code>AbstractQueuedSynchronizer</code>整体是利用模板模式，通过维护一个<code>state</code>变量状态配合<code>tryAcquire</code>，<code>tryRelease</code>以及<code>tryAcquireShared</code>，<code>tryReleaseShared</code>间接的影响许可获取和释放。</p><p>同步器使用CLH队列来维护排队的线程，CLH队列说白了就是一个单向链表，特性是后一个节点的状态是由前一个节点的状态决定的，每个节点都有一个<code>pred</code>指针指向前一个节点，<code>AbstractQueuedSynchronizer</code>在原生的CLH队列基础上进行了优化，加入了一个<code>next</code>指针，指向后继节点，用于提高寻找后继节点的性能，这就形成了一个双向链表。由于没有更新两个<code>volatile</code>的变量的CAS方法，所以<code>next</code>变量为<code>null</code>的时候并不表明没有后继节点，因为有可能一个节点入列的时候更新完<code>pred</code>指针，还没来得及更新<code>next</code>指针。具体结构如下：</p><p><img src="https://wocanmei-hexo.nos-eastchina1.126.net/%E4%B8%87%E9%94%81%E4%B9%8B%E6%AF%8DAbstractQueuedSynchronizer/CLH.png" alt="CLH队列结构"></p><p><code>head</code>和<code>tail</code>分别指向队列的头和尾，<code>next</code>我这里画成了虚线，表明其不可靠性。</p><p><code>AbstractQueuedSynchronizer</code>的核心就是如何维护CLH队列的状态，所以我们把重点放在这一块。它提供了两套获取许可和释放许可的方法：<code>acquire</code>，<code>release</code>和<code>acquireShared</code>，<code>releaseShared</code>，分别对应独占和共享模式。下面分别看看这两套方法的签名：</p><pre><code class="java">// 独占模式模板方法public final void acquire(int arg) &#123;    if (!tryAcquire(arg) &amp;&amp;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();&#125;public final boolean release(int arg) &#123;    if (tryRelease(arg)) &#123;        Node h = head;        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    &#125;    return false;&#125;// 共享模式模板方法public final void acquireShared(int arg) &#123;    if (tryAcquireShared(arg) &lt; 0)        doAcquireShared(arg);&#125;public final boolean releaseShared(int arg) &#123;    if (tryReleaseShared(arg)) &#123;        doReleaseShared();        return true;    &#125;    return false;&#125;</code></pre><p>可以看到这两套方法是非常类似的，我们一个一个的看看，首先看看<code>acquire</code>方法：</p><pre><code class="java">// acquire方法的逻辑粗看起来可能是先尝试获取下许可// 如果成功，直接跳出，不用排队了；// 如果不成功就添加一个独占节点到队列中排队，如果// 有中断响应中断，细节一个方法一个方法的进入看看public final void acquire(int arg) &#123;    if (!tryAcquire(arg) &amp;&amp;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();&#125;// 尝试获取许可，成功返回true，这个方法没有实现// 而是留给子类去实现，因为不同的锁获取和释放// 许可的语义是不同的无法一概而论，所以交由// 具体的子类去实现，这是典型的模板模式// 之所以没有用抽象方法，是因为同步器// 允许只实现独占和共享的一种，如果是// 抽象方法，则需要实现两套模式的方法protected boolean tryAcquire(int arg) &#123;    throw new UnsupportedOperationException();&#125;// 从名字上也可以看出这个方法就是往队伍里添加节点进行排队private Node addWaiter(Node mode) &#123;    // 以当前线程建立一个新的节点，准备插到队伍里    Node node = new Node(Thread.currentThread(), mode);    // Try the fast path of enq; backup to full enq on failure    // 这句是原生英文注释，大意是先尝试快速的路径入队，如果失败    // 再用完整的入队方法，为什么这里是快呢？先别急，先往下看    Node pred = tail;    // pred != null 说明队伍里已有排队者    if (pred != null) &#123;        node.prev = pred;        // 使用CAS操作将当前节点插到队伍里，注意这个时候可能        // 会有多个线程在同时往里插队，但是CAS操作能确保同一        // 时间只有一个线程会成功        if (compareAndSetTail(pred, node)) &#123;            pred.next = node;            return node;        &#125;    &#125;    enq(node);    return node;&#125;// 这就是所谓的完整的入队方法private Node enq(final Node node) &#123;    for (;;) &#123;        Node t = tail;        // 也就是队列还没有初始化呢，将head和        // tail都初始化为一个哑节点        if (t == null) &#123; // Must initialize            if (compareAndSetHead(new Node()))                tail = head;        &#125; else &#123;            // 看这段代码是不是很眼熟了呢，对            // 这块和快速入队方法基本一样，对比快速和完整            // 两种入队方法，快速的没有初始化判断，            // 少了循环，不会重试，相对来说会“快”点            node.prev = t;            if (compareAndSetTail(t, node)) &#123;                t.next = node;                return t;            &#125;        &#125;    &#125;&#125;// 这个方法的大意是如果获得了许可，赶紧出队执行，否则告诉你的// 前继节点轮到你时叫你，然后老老实实排队等待final boolean acquireQueued(final Node node, int arg) &#123;    boolean failed = true;    try &#123;        boolean interrupted = false;        for (;;) &#123;            // 获得node的前继节点            final Node p = node.predecessor();            // 如果前继节点是头而且尝试获取许可成功            // 也就是轮到node出列执行了，即警察叔叔            // 给你招手了            if (p == head &amp;&amp; tryAcquire(arg)) &#123;                setHead(node);                p.next = null; // help GC                failed = false;                return interrupted;            &#125;            // 这里是判断是否需要阻塞，需要的话就要调用            // park方法将线程歇一会，等unpark叫醒线程            // 的时候会检查中断状态，如果有中断就响应            // 中断            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                interrupted = true;        &#125;    &#125; finally &#123;        // 如果tryAcquire抛出异常        if (failed)            cancelAcquire(node);    &#125;&#125;// 这段代码的大意是节点node给前面的节点pred说哥们我先睡会，到站叫我，pred// 说好（设置为SIGNAL状态），到站之后叫你，你放心睡吧private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;    int ws = pred.waitStatus;    // 如果前继节点的状态是SIGNAL，表明node已经告诉pred到站叫他，    // 而且pred也已经答应了，所以node可以放心的去睡了    if (ws == Node.SIGNAL)        return true;    if (ws &gt; 0) &#123;        // 这里是删除取消的节点，因为只有CANCEL的节点是大于0        do &#123;            node.prev = pred = pred.prev;        &#125; while (pred.waitStatus &gt; 0);        pred.next = node;    &#125; else &#123;        // node告诉pred到站叫它        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);    &#125;    return false;&#125;// 这个方法很简单，没啥好说的，就是去睡觉，醒来// 之后看看手机有没有人找你（中断）private final boolean parkAndCheckInterrupt() &#123;    LockSupport.park(this);    return Thread.interrupted();&#125;</code></pre><p><code>acquire</code>分析完了，再看看<code>release</code></p><pre><code class="java">// 如果释放许可成功，并且后面还有节点，叫醒它// 返回public final boolean release(int arg) &#123;    if (tryRelease(arg)) &#123;        Node h = head;        // 如果后面还有节点        // waitStatus会被设置成SIGNAL，忘记的话可以再        // 看看前面的shouldParkAfterFailedAcquire方法        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    &#125;    return false;&#125;// 叫醒后面的哥们一次private void unparkSuccessor(Node node) &#123;    int ws = node.waitStatus;    // 如果ws小于0，也就是没有取消，将ws置位0    // 也就是打算叫醒后面的节点，同时把提醒    // 状态复位，免得叫醒多次    if (ws &lt; 0)        compareAndSetWaitStatus(node, ws, 0);    Node s = node.next;    // 如果后面可能没节点了或者节点是取消的    // 就从后往前找，如果能找到紧随node之后    // 并且没有取消的节点就叫醒它。这里就是    // 利用next的优化了，即如果next不为空    // 且没有取消那么直接叫醒next，如果    // next为空，不能认定后面就没有节点了    // 因为next是不可靠的，要利用可靠的pred从后    // 往前找    if (s == null || s.waitStatus &gt; 0) &#123;        s = null;        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)            if (t.waitStatus &lt;= 0)                s = t;    &#125;    if (s != null)        LockSupport.unpark(s.thread);&#125;</code></pre><p>独占模式的获取和释放代码就分析完了，再来看看共享模式的。</p><pre><code class="java">public final void acquireShared(int arg) &#123;    if (tryAcquireShared(arg) &lt; 0)        doAcquireShared(arg);&#125;// 返回值小于0表示获取失败// 等于0表示获取许可成功但是后面节点无法再获取了// 大于0表示获取许可成功并且后面节点还可以再获取protected int tryAcquireShared(int arg) &#123;    throw new UnsupportedOperationException();&#125;// 粗看doAcquireShared和acquireQueued非常相似，// 主要是两点不同，一是一个添加的是独占节点，// 一个添加的是共享节点，另一点不同是// 一个是setHead，一个是setHeadAndPropagateprivate void doAcquireShared(int arg) &#123;    final Node node = addWaiter(Node.SHARED);    boolean failed = true;    try &#123;        boolean interrupted = false;        for (;;) &#123;            final Node p = node.predecessor();            if (p == head) &#123;                int r = tryAcquireShared(arg);                if (r &gt;= 0) &#123;                    setHeadAndPropagate(node, r);                    p.next = null; // help GC                    if (interrupted)                        selfInterrupt();                    failed = false;                    return;                &#125;            &#125;            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                interrupted = true;        &#125;    &#125; finally &#123;        if (failed)            cancelAcquire(node);    &#125;&#125;// 可以看到setHeadAndPropagate不光像独占模式那样修改了队列的头，// 还会在某些条件下调用一个doReleaseShared方法private void setHeadAndPropagate(Node node, int propagate) &#123;    Node h = head; // Record old head for check below    setHead(node);    // 后续节点还有获取许可的机会或者节点没有取消    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||        (h = head) == null || h.waitStatus &lt; 0) &#123;        Node s = node.next;        // 不知道s是什么类型或者s是共享节点        if (s == null || s.isShared())            doReleaseShared();    &#125;&#125;// 在并发的条件下叫醒队列头部的线程private void doReleaseShared() &#123;    for (;;) &#123;        Node h = head;        if (h != null &amp;&amp; h != tail) &#123;            // 这部分代码和独占模式的release方法几乎一样            // 也是把队列头的线程叫醒继续执行，但要注意            // 一个重要区别是这里使用的是CAS操作，上面            // 独占不是，这是为什么呢？还记得独占和共享            // 的定义吗？对于共享模式多个线程同时执行            // 同时也有可能多个线程同时释放，所以必须            // 使用CAS操作保证线程安全            int ws = h.waitStatus;            if (ws == Node.SIGNAL) &#123;                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))                    continue;            // loop to recheck cases                unparkSuccessor(h);            &#125;            // 这个分支啥时候会满足呢？根据上面的分析在入队的时候            // 会调用shouldParkAfterFailedAcquire将前继节点的状态            // 修改为SIGNAL，这里为0应该发生在头节点没有后继节点            // 或者后继节点调用shouldParkAfterFailedAcquire            // 还没返回的时候，再加上这个条件：            // !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)            // 那么就剩下了一种情况：头结点的后继节点调用            // shouldParkAfterFailedAcquire还没把头节点            // 的状态修改成SIGNAL的时候。如果没有这个分支            // 只能等待下一次的doReleaseShared的调用才能            // 将头部的线程叫醒了            else if (ws == 0 &amp;&amp;                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))                continue;                // loop on failed CAS        &#125;        // 这句意思是头没变就跳出，那头啥时候变呢，就是出队的时候        // 也就是有线程已经出队，有责任叫醒新的头节点线程        if (h == head)                   // loop if head changed            break;    &#125;&#125;// 可以看到释放许可的主逻辑就是doReleaseShared// 上文已经分析过在此不再赘述public final boolean releaseShared(int arg) &#123;    if (tryReleaseShared(arg)) &#123;        doReleaseShared();        return true;    &#125;    return false;&#125;</code></pre><h2 id="运行图景"><a href="#运行图景" class="headerlink" title="运行图景"></a>运行图景</h2><p>经过上面的源码分析，估计大部分人心里有点数了，可能还形不成清晰的运行图景或者说直觉性的认识，那么接下来说下我自己的一点理解。</p><p>整个的图景是这样子的：对于独占模式，因为只有一个线程能获取许可，进而也只有一个线程释放许可，只会叫醒队伍头部的一个线程，这样整个队列是<strong>串行出列，并行入列</strong>，有点像排队坐公交，虽然队伍后面挤作一团，队伍前面还是有序的，一个一个的上车；对于共享模式而言，由于允许多个线程一起运行，也就是多个线程获得许可，同样也会有多个线程释放许可，这就需要叫醒队伍里多个线程，整个队列的样子是<strong>并行出列，并行入列</strong>。</p><p>忽略不必要的细节，来看看独占和共享模式下主逻辑的函数调用栈：</p><p><img src="https://wocanmei-hexo.nos-eastchina1.126.net/%E4%B8%87%E9%94%81%E4%B9%8B%E6%AF%8DAbstractQueuedSynchronizer/function_stack.png" alt="函数主逻辑调用栈"></p><p>上图左边是独占模式的调用栈，右边是共享模式的调用栈。可以清晰看到为啥共享模式的可以唤醒多个节点，是因为它的调用栈形成了一个环，这样它就不会不停地叫醒后面的共享节点，就像一个连锁反应，并且获取许可和释放许可都会启动这个连锁反应；而独占模式没有形成环，叫醒一个节点就返回了，并且由于共享模式下获取和释放许可都会调用doReleaseShared，二者会形成竞争，这也是doReleaseShared内部使用CAS操作的一个原因。</p><p>参考资料：</p><ul><li>JAVA并发编程实战</li><li>Doug Lea, The java.util.concurrent Synchronizer Framework</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻看&lt;a href=&quot;https://pingao777.github.io/2019/03/07/Java%E2%80%9C%E9%94%81%E2%80%9D%E8%AE%B0/&quot;&gt;Java“锁”记&lt;/a&gt;中提到的各种“锁”，其内部同步实现大多数都和一个类&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;相关，这个类称得上“万锁之母”，所以今天就来扒一扒这个类。&lt;/p&gt;
    
    </summary>
    
      <category term="三言两语" scheme="https://pingao777.github.io/categories/%E4%B8%89%E8%A8%80%E4%B8%A4%E8%AF%AD/"/>
    
    
      <category term="并发" scheme="https://pingao777.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="分布式" scheme="https://pingao777.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Java" scheme="https://pingao777.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java“锁”记</title>
    <link href="https://pingao777.github.io/2019/03/07/Java%E2%80%9C%E9%94%81%E2%80%9D%E8%AE%B0/"/>
    <id>https://pingao777.github.io/2019/03/07/Java“锁”记/</id>
    <published>2019-03-07T06:12:29.000Z</published>
    <updated>2020-09-12T03:14:00.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内置锁和显示锁"><a href="#内置锁和显示锁" class="headerlink" title="内置锁和显示锁"></a>内置锁和显示锁</h2><p>内置锁其实是相对显示锁来说的，说白了内置锁就是<code>synchronized</code>所代表Java原生锁机制，Jdk5.0之后又引入了<code>Lock</code>及其子类<code>ReentrantLock</code>这样一种新的锁机制。从加锁和内存语义上二者一样，只不过后者添加了一些其他功能，可以实现诸如轮询锁、超时锁和中断锁的功能。<br><a id="more"></a></p><pre><code class="java">public interface Lock &#123;    void lock();    void lockInterruptibly() throw InterruptedException;    boolean tryLock();    boolean tryLock(long timeout, TimeUnit unit)        throw InterruptedException;    void unlock();    Condition newCondition();&#125;</code></pre><p>如果内置锁是一个<code>Lock</code>的话，它只有<code>lock()</code>和<code>unlock()</code>方法。从锁的基本属性上说，内置锁和显示锁都是可重入的，内置锁是非公平的，显示锁还可以设置为公平的。</p><p><code>tryLock</code>和<code>lock</code>的区别是前者获得锁返回true，获取不到返回false，都是立马返回，而后者如果获取不到将会阻塞到那里。</p><p>另外由于内置锁是自动释放，而显示锁必须手动释放，这就形成了显示锁的调用模式如下面这样：</p><pre><code class="java">Lock lock = ...;lock.lock();try &#123;    // 逻辑&#125; finally &#123;    lock.unlock();&#125;</code></pre><p>也就是锁的释放必须放在finally中，确保锁可以释放。</p><p>从<code>ReentrantLock</code>衍生出来一个<code>ReentrantReadWriteLock</code>，为啥要有读写锁呢？其实是基于这样的原则，读写和写写是会引起线程安全问题的，所以都需要同步，前者是因为可见性，后者是因为一致性，但是读读是不需要同步的，所以讲读写拆分开来以提高性能。这就好比原来大家都排一个队，现在拆成两个队，自然排队等待的时间就短了。</p><h2 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h2><p>闭锁就像一个门，等待一个“事件”开门（结束状态），在开门之前不允许任何人（线程）通过，在此之前大家只能在城门前面等待。只不过城门可以重复的开闭，闭锁只是一次性的。</p><p>具体到Java中，闭锁的实现就是<code>CountDownLatch</code>，它可以用来实现等待某种条件满足后才把线程放行的功能，比如资源就绪、服务启动、某个操作执行等等。</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量是用来控制同时访问某个资源的特定数量，或者同时执行某个操作的数量，有点像地铁中的限流。</p><p>从某种程度上讲，锁有点像一个二值的信号量，也就是初始值为1的信号量，不同之处是锁是可重入的，信号量不可。</p><h2 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h2><p>栅栏和闭锁类似，它也能阻塞一组线程直到某个事件发生。区别在于栅栏要求线程都到达栅栏位置，才能继续执行，即所谓的闭锁等待的是事件，栅栏等待的是线程。如果对比现实中的例子，闭锁犹如大家去登山，商议好早晨8点出发，无论人齐不齐，到8点大家就出发，而栅栏就类似于大家登一段就在一个歇息点等一等人，等人齐再往上登。</p><h2 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h2><p>原子变量实际上是一种乐观锁技术，即利用冲突检测来判断是否有来自其他线程的干扰，当进行修改操作时，先把变量的当前值current取出来，然后用一个原子的比较交换操作（CAS）对变量进行修改。有两种情况：如果变量的当前值还等于current说明这中间没有线程修改变量，修改变量值为新值；如果当前值不等于current了，说明中间有线程修改变量，重试。</p><p>以一个典型的count++为例，大家知道++这种操作实际上包括三步：</p><ol><li>获取count当前值current</li><li>当前值加一newvalue</li><li>将newvalue赋值给count</li></ol><p>如果两个线程同时修改count的值，假如两个线程的时序如下：</p><blockquote><p>=====1===========+1=================</p><p>=========1===========+1=============</p></blockquote><p>假设count的当前值为1，两个线程分别进行了++的操作，最后的值为2，第一个++操作被“覆盖”了。如果把上面2、3步换成一个CAS操作就不会发生上面的情况了，因为执行第二次操作时会拿count的旧值1和新值2对比，一对比发现不一样，说明其他线程修改了变量，这时候第二个线程会进入下一次的CAS操作，重新获取count值2，比较当前值2等于原来的值，修改为新值3。</p><p>原子变量作为一种非阻塞的锁技术，适用在读操作比较多、竞争不那么激烈的场景，这适用于大部分的业务场景。但同时原子变量也有其局限，原子锁只能保证单一变量的线程安全。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内置锁和显示锁&quot;&gt;&lt;a href=&quot;#内置锁和显示锁&quot; class=&quot;headerlink&quot; title=&quot;内置锁和显示锁&quot;&gt;&lt;/a&gt;内置锁和显示锁&lt;/h2&gt;&lt;p&gt;内置锁其实是相对显示锁来说的，说白了内置锁就是&lt;code&gt;synchronized&lt;/code&gt;所代表Java原生锁机制，Jdk5.0之后又引入了&lt;code&gt;Lock&lt;/code&gt;及其子类&lt;code&gt;ReentrantLock&lt;/code&gt;这样一种新的锁机制。从加锁和内存语义上二者一样，只不过后者添加了一些其他功能，可以实现诸如轮询锁、超时锁和中断锁的功能。&lt;br&gt;
    
    </summary>
    
      <category term="三言两语" scheme="https://pingao777.github.io/categories/%E4%B8%89%E8%A8%80%E4%B8%A4%E8%AF%AD/"/>
    
    
      <category term="并发" scheme="https://pingao777.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="分布式" scheme="https://pingao777.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Java" scheme="https://pingao777.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>强烈推荐Andrew Ng的机器学习课程</title>
    <link href="https://pingao777.github.io/2019/01/21/%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90Andrew-Ng%E7%9A%84%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B/"/>
    <id>https://pingao777.github.io/2019/01/21/强烈推荐Andrew-Ng的机器学习课程/</id>
    <published>2019-01-21T10:11:07.000Z</published>
    <updated>2020-09-12T03:14:00.589Z</updated>
    
    <content type="html"><![CDATA[<p>从12.30到1.17修完了Coursera上的Andrew Ng的机器学习课程，计划上又可以划掉一件事了。</p><p>课程的主要内容大致如下：</p><ul><li>监督学习：线性回归、逻辑回归、神经网络、支持向量机</li><li>非监督学习：K均值、主成分分析、异常检测</li><li>案例：垃圾邮件</li><li>特殊领域：推荐系统（协同过滤）、大规模机器学习（map-reduce）</li><li>方法论：偏差/方差问题、正则化、学习曲线、误差分析、如何收集样本数据、机器学习流水线、上限分析等等</li></ul><a id="more"></a><p>习题主要是两大类：选择题和编程题（matlab），选择题又分为单选和多选，只有答案没有解释，有些题难度还是有的。编程题自认为相对简单，只需了解简单的matlab编程和矩阵知识，上课好好听讲基本上就是满分。我的总成绩为98.4，编程题基本上100，选择题错了两个，想参考的可以戳<a href="https://github.com/pingao777/coursera-ml">这里</a>。</p><p>课程用我自己的话总结就是：不装逼，说人话，循循善诱，详略得当。</p><p>记得Andrew Ng在讲到神经网络的反向传播算法时，花了大量的篇幅来介绍这一算法，尽管如此还是害怕有些学生不会影响自信心，他这样说道：作为多年的从业者，有时候猛然想起这个算法也得想好一会，这个算法不是那么直观。在讲到svm还是哪一课的时候，记不太清了，他又鼓励同学们：原理不懂也没有关系，事实上这些算法的原理直到最近我才搞明白，事实证明不了解算法的原理也能很好的使用它们。这一点比那些一瓶子不满半瓶子晃荡的老师强多了。</p><p>抛开老师的谦虚，在初学一样东西时，适当的忽略一些底层细节是一个很重要的学习方法。我发现不少同学包括我自己在学习机器学习的时候遇到一个算法，不由自主的想了解全部的数学细节，不这样心里就不踏实，以至于还没走到机器学习的门槛就已经倒在线性代数、概率论、数值分析的汪洋大海里了，其实这是一个本末倒置的学习方法。这就好比买了一辆汽车，难道你还要去修一门内燃机原理的课程？当然这不是鼓励大家囫囵吞枣，而是让大家抓住重点，不要把面铺的太广，否则收不回来。真正好的方法是学机器学习就把重点放在机器学习上，一些底层细节就当成既有的事实，等到学有余力再重点突破。所以学习的时候一定要控制自己那种无限扣细节的冲动。</p><p>另外一个其他课程没有或者很少提到的是这门课程Andrew Ng介绍了很多的机器学习方法论，比如学习曲线、误差分析、流水线、上线分析等等，这才是真正的金玉良言，可遇不可求的。众所周知，象棋的规则很简单，难的是如何开局，如何化解对手的攻势，如何一步一步积累自己的优势达到胜利，这些都是需要在实践中摸索，如果纯靠自己摸索，新手要走不少的弯路，而如果一开始别人把这些告诉你，你就可以事半功倍。</p><p>观察课程的主要内容可以看到这门课介绍的算法并不是很全面，比如常见的决策树、随机森林、贝叶斯算法等等都没有，有人可能觉得这是课程的缺点，我倒觉得这反而是优点，有道是一招鲜吃遍天，机器学习的算法是有固定的模式的，比如监督学习，基本上都是提出一个假设函数，然后去拟合现有数据，也就是生成一个代价函数，然后用数学方法找到使代价函数最小的参数，所以学会这些典型的算法再去学其他的算法没什么难度；另一个是影响机器学习性能的关键往往并不是算法本身而是你拥有的数据量、特征的选取、如何进行误差分析、如何进行模型的调优，这一点课程也有论述，我就不班门弄斧了。总之，这是一门我强烈推荐的课程，适合入门者进阶者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从12.30到1.17修完了Coursera上的Andrew Ng的机器学习课程，计划上又可以划掉一件事了。&lt;/p&gt;
&lt;p&gt;课程的主要内容大致如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监督学习：线性回归、逻辑回归、神经网络、支持向量机&lt;/li&gt;
&lt;li&gt;非监督学习：K均值、主成分分析、异常检测&lt;/li&gt;
&lt;li&gt;案例：垃圾邮件&lt;/li&gt;
&lt;li&gt;特殊领域：推荐系统（协同过滤）、大规模机器学习（map-reduce）&lt;/li&gt;
&lt;li&gt;方法论：偏差/方差问题、正则化、学习曲线、误差分析、如何收集样本数据、机器学习流水线、上限分析等等&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术人生" scheme="https://pingao777.github.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="机器学习" scheme="https://pingao777.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Coursera" scheme="https://pingao777.github.io/tags/Coursera/"/>
    
  </entry>
  
  <entry>
    <title>2018年终总结</title>
    <link href="https://pingao777.github.io/2019/01/01/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://pingao777.github.io/2019/01/01/2018年终总结/</id>
    <published>2019-01-01T09:59:47.000Z</published>
    <updated>2020-09-12T03:14:00.580Z</updated>
    
    <content type="html"><![CDATA[<p>18年5月份的时候写了个<a href="https://pingao777.github.io/2018/05/25/2018%E4%B8%AD%E6%9C%9F%E8%AE%A1%E5%88%92/">中期计划</a>，当时主要写了四件事：</p><blockquote><ol><li>Coursera上Algorithms课程，现在已进行到上半部分第二周。</li><li>啃完计算机程序与构造，做一部分习题。</li><li>至少每隔一天跑一次步，身体革命本钱。</li><li>每周一篇博客，不限制长度。</li></ol></blockquote><a id="more"></a><p>这四件事目前看来只有1完成了，其他三件都没有完成。当时还说不要打脸，果然打脸了<code>(/ □ \)</code>。我知道借口永远是逃避问题的最好方法，所以不打算找借口，计划没完成主因确实是自控力不够，所以只好不要脸的把没完成的计划放在19年了。新的计划为：</p><ol start="0"><li>Andrew Ng的机器学习学完，1月份</li><li>计算机程序与构造，2-4月份，三个月时间，习题尽量做</li><li>每周三次跑步，周五-周日，每天晚上</li><li>博客记得写，但最好有趣，有用</li></ol><p>在执行计划的过程中，发现了一些计划太草率，所以进行了微调，比如“每周一篇博客，不限制长度”，在执行的过程中，发现想写一篇好的博客其实挺费心的，无病呻吟的文章又不想写，所以我稍微改了下，不要为了写而写。另外加了一条机器学习计划，因为人工智能确实越来越重要，自己对这方面也比较感兴趣。今年体检报告说肥胖，甘油三酯偏高，所以跑步这一条肯定需要更好的执行下去，但是在上年执行计划的时候，每隔一天的跑法受下班时间和下班状态影响比较大，所以我把时间调整到周末。</p><p>最后，祝大家新年快乐，心想事成吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;18年5月份的时候写了个&lt;a href=&quot;https://pingao777.github.io/2018/05/25/2018%E4%B8%AD%E6%9C%9F%E8%AE%A1%E5%88%92/&quot;&gt;中期计划&lt;/a&gt;，当时主要写了四件事：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Coursera上Algorithms课程，现在已进行到上半部分第二周。&lt;/li&gt;
&lt;li&gt;啃完计算机程序与构造，做一部分习题。&lt;/li&gt;
&lt;li&gt;至少每隔一天跑一次步，身体革命本钱。&lt;/li&gt;
&lt;li&gt;每周一篇博客，不限制长度。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="生活生活" scheme="https://pingao777.github.io/categories/%E7%94%9F%E6%B4%BB%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="2018" scheme="https://pingao777.github.io/tags/2018/"/>
    
      <category term="计划" scheme="https://pingao777.github.io/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="2019" scheme="https://pingao777.github.io/tags/2019/"/>
    
  </entry>
  
  <entry>
    <title>终于修完Algorithm了</title>
    <link href="https://pingao777.github.io/2018/12/16/%E7%BB%88%E4%BA%8E%E4%BF%AE%E5%AE%8CAlgorithm%E4%BA%86/"/>
    <id>https://pingao777.github.io/2018/12/16/终于修完Algorithm了/</id>
    <published>2018-12-16T12:11:32.000Z</published>
    <updated>2020-09-12T03:14:00.591Z</updated>
    
    <content type="html"><![CDATA[<p>磕磕绊绊，终于把Coursera上的Algorithm课修完了，中间有段时间中断了，因为工作太累，下班或者周末实在不愿意面对电脑了。Algorithm这门课整体难度不大，但是课时较长，所以需要能坚持下来。老师在理论和应用上做了比较好的平衡，不会太枯燥，不少习题也都是为了解决现实中的实际问题设计的，这点我非常喜欢，技术最终是为实际应用服务的，纯理论的东西确实提不起兴趣。</p><a id="more"></a><p>下面是本次课程的10次作业，</p><ul><li><a href="https://github.com/pingao777/Algorithms/tree/master/src/main/java/com/pingao/assignment/week1">Percolation</a></li><li><a href="https://github.com/pingao777/Algorithms/tree/master/src/main/java/com/pingao/assignment/week2">Deques and Randomized Queues</a></li><li><a href="https://github.com/pingao777/Algorithms/tree/master/src/main/java/com/pingao/assignment/week3">Collinear Points</a></li><li><a href="https://github.com/pingao777/Algorithms/tree/master/src/main/java/com/pingao/assignment/week4">8 Puzzle</a></li><li><a href="https://github.com/pingao777/Algorithms/tree/master/src/main/java/com/pingao/assignment/week5">Kd-Trees</a></li><li><a href="https://github.com/pingao777/Algorithms/tree/master/src/main/java/com/pingao/assignment/week6">WordNet</a></li><li><a href="https://github.com/pingao777/Algorithms/tree/master/src/main/java/com/pingao/assignment/week7">Seam Carving</a></li><li><a href="https://github.com/pingao777/Algorithms/tree/master/src/main/java/com/pingao/assignment/week8">Baseball Elimination</a></li><li><a href="https://github.com/pingao777/Algorithms/tree/master/src/main/java/com/pingao/assignment/week9">Boggle</a></li><li><a href="https://github.com/pingao777/Algorithms/tree/master/src/main/java/com/pingao/assignment/week10">Burrows–Wheeler</a></li></ul><p>给我印象最深刻的是第八周的Baseball Elimination，这个作业的大概意思是根据棒球联赛积分表找出哪些球队已经被淘汰，说实话看过体育比赛的对这一点都是有感触的，有时候找出这样的球队不是那么容易，没想到在这里可以使用这么巧妙的一种方法解决，具体方法我就不剧透了。</p><p>这门课虽说修完了，但是自我感觉并不是里面的东西都理解了，甚至可以说是大部分都没有理解，或者说理解的不够深刻，那是不是白学了？肯定不是，我觉得最大的收获就是学到了一些问题有更好的解决方法这个事实，而不是解决方法本身，在上课之前可能某些问题我也知道一些方法，但都是一些笨办法，上完这门课相当于给了我一个更低的上界。总之，用大白话说就是增长了眼界。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;磕磕绊绊，终于把Coursera上的Algorithm课修完了，中间有段时间中断了，因为工作太累，下班或者周末实在不愿意面对电脑了。Algorithm这门课整体难度不大，但是课时较长，所以需要能坚持下来。老师在理论和应用上做了比较好的平衡，不会太枯燥，不少习题也都是为了解决现实中的实际问题设计的，这点我非常喜欢，技术最终是为实际应用服务的，纯理论的东西确实提不起兴趣。&lt;/p&gt;
    
    </summary>
    
      <category term="技术人生" scheme="https://pingao777.github.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="Coursera" scheme="https://pingao777.github.io/tags/Coursera/"/>
    
      <category term="算法" scheme="https://pingao777.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>DrRacket使用技巧总结</title>
    <link href="https://pingao777.github.io/2018/12/03/DrRacket%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    <id>https://pingao777.github.io/2018/12/03/DrRacket使用技巧总结/</id>
    <published>2018-12-03T06:27:03.000Z</published>
    <updated>2020-09-12T03:14:00.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用其他文件的函数"><a href="#引用其他文件的函数" class="headerlink" title="引用其他文件的函数"></a>引用其他文件的函数</h2><p>假设test.scm想引用max-two.scm中的一个函数max-two，可以这样，</p><p>test.scm</p><pre><code class="scheme">#lang sicp(#%require rackunit)(#%require &quot;max-two.scm&quot;)(max-two 2 3 4)</code></pre><a id="more"></a><p>max-two.scm</p><pre><code class="scheme">#lang sicp;; 千万别忘了这一句(#%provide (all-defined))(define (max-two x y z)  (define (min-three x y z)    (cond ((&gt;= x y) (if (&gt;= y z) z y))          (else (if (&gt;= x z) z x))))  (- (+ x y z) (min-three x y z)))</code></pre><h2 id="Window10安装sicp包"><a href="#Window10安装sicp包" class="headerlink" title="Window10安装sicp包"></a>Window10安装sicp包</h2><p>7.1版本ui界面安装pkg报错cadr: contract violation，可以使用命令行安装，命令如下：</p><pre><code class="scheme">raco pkg install --auto sicp</code></pre><h2 id="从Vim中运行scheme程序"><a href="#从Vim中运行scheme程序" class="headerlink" title="从Vim中运行scheme程序"></a>从Vim中运行scheme程序</h2><p>可以做如下配置：</p><pre><code class="scheme">augroup scheme    autocmd!    &quot; 加上&lt;esc&gt;可以避免弹出命令行必须按两次enter才能回到代码    autocmd filetype scheme nnoremap &lt;F9&gt; :w&lt;cr&gt;:! racket %&lt;cr&gt;&lt;esc&gt;augroup end</code></pre><p>这样直接按下<code>F9</code>就能运行了</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引用其他文件的函数&quot;&gt;&lt;a href=&quot;#引用其他文件的函数&quot; class=&quot;headerlink&quot; title=&quot;引用其他文件的函数&quot;&gt;&lt;/a&gt;引用其他文件的函数&lt;/h2&gt;&lt;p&gt;假设test.scm想引用max-two.scm中的一个函数max-two，可以这样，&lt;/p&gt;
&lt;p&gt;test.scm&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scheme&quot;&gt;#lang sicp

(#%require rackunit)
(#%require &amp;quot;max-two.scm&amp;quot;)

(max-two 2 3 4)
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="技术人生" scheme="https://pingao777.github.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="DrRacket" scheme="https://pingao777.github.io/tags/DrRacket/"/>
    
      <category term="Lisp" scheme="https://pingao777.github.io/tags/Lisp/"/>
    
  </entry>
  
  <entry>
    <title>Jsonp到底是个什么东西</title>
    <link href="https://pingao777.github.io/2018/11/22/JSONP%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF/"/>
    <id>https://pingao777.github.io/2018/11/22/JSONP到底是个什么东西/</id>
    <published>2018-11-22T10:43:44.000Z</published>
    <updated>2020-09-12T03:14:00.581Z</updated>
    
    <content type="html"><![CDATA[<p>这个世界上有好多事对你来说是模棱两可，可能是这样或者那样的原因你没有动力去了解它，以至于它久久萦绕在你的心头，Jsonp就是这么一件事。今天终于有动力想了解一番，经过一番热火朝天的谷歌百度后，发现Jsonp这东西说起来简单的很啊，我自己用一句话总结就是：<strong>使用script标签进行跨域访问</strong>。由于跨域请求返回的数据和JSON相关，故而得名Jsonp。</p><a id="more"></a><p>众所周知，javascript有同源策略的限制，是不允许跨域访问的，比如位于a.xxx.com下面的js代码，</p><pre><code class="javascript">function print_log(json) &#123;    console.log(json.name);&#125;var xhr = new XMLHttpRequest();xhr.open(&#39;GET&#39;, &#39;http://b.xxx.com/test?callback=print_log&#39;, true);</code></pre><p>假设/test?callback=print_log接口的返回值为：</p><pre><code class="javascript">print_log(&#123;&quot;name&quot;: &quot;小明&quot;, &quot;id&quot; : 1823, &quot;rank&quot;: 7&#125;)</code></pre><p>/test接口返回了一段js代码，这段代码如果正常执行的话将会打印出“小明”，但是由于同源策略，位于a.xxx.com上的js想请求b.xxx.com上的test接口是无法通过的，这就是常说的“js无法跨域”。有没有办法实现跨域呢，大神们想了各种各样的办法，其中之一就是Jsonp，具体来说就是虽说js不能跨域，但是有个例外，那就是script标签可以，利用script标签的跨域特性访问其他域名上的接口，动态生成一段js代码，这样就绕过了同源策略，实现了跨域访问。具体代码如下，</p><pre><code class="javascript">var script = document.createElement(&#39;script&#39;);script.setAttribute(&#39;src&#39;, &#39;http://b.xxx.com/test?callback=print_log&#39;);</code></pre><p>这实际上相当于执行下面的代码，</p><pre><code class="javascript">function print_log(json) &#123;    console.log(json.name);&#125;print_log(&#123;&quot;name&quot;: &quot;小明&quot;, &quot;id&quot; : 1823, &quot;rank&quot;: 7&#125;)</code></pre><p>不出意外的话可以看到打印出的“小明”了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个世界上有好多事对你来说是模棱两可，可能是这样或者那样的原因你没有动力去了解它，以至于它久久萦绕在你的心头，Jsonp就是这么一件事。今天终于有动力想了解一番，经过一番热火朝天的谷歌百度后，发现Jsonp这东西说起来简单的很啊，我自己用一句话总结就是：&lt;strong&gt;使用script标签进行跨域访问&lt;/strong&gt;。由于跨域请求返回的数据和JSON相关，故而得名Jsonp。&lt;/p&gt;
    
    </summary>
    
      <category term="技术人生" scheme="https://pingao777.github.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="Jsonp" scheme="https://pingao777.github.io/tags/Jsonp/"/>
    
      <category term="Javascript" scheme="https://pingao777.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>阿汤哥不减当年啊</title>
    <link href="https://pingao777.github.io/2018/09/16/%E9%98%BF%E6%B1%A4%E5%93%A5%E4%B8%8D%E5%87%8F%E5%BD%93%E5%B9%B4%E5%95%8A/"/>
    <id>https://pingao777.github.io/2018/09/16/阿汤哥不减当年啊/</id>
    <published>2018-09-16T04:55:23.000Z</published>
    <updated>2020-09-12T03:14:00.592Z</updated>
    
    <content type="html"><![CDATA[<p>阿汤哥老了啊，昔日的小鲜肉也是满脸褶子了，岁月真是杀猪刀啊。两张活动送的电影券，晚上10点的场，里面总共6个人，碟中谍的套路没变，剧情也没怎么变，演员也没怎么变，只是时间变了，为情怀支持一波！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;阿汤哥老了啊，昔日的小鲜肉也是满脸褶子了，岁月真是杀猪刀啊。两张活动送的电影券，晚上10点的场，里面总共6个人，碟中谍的套路没变，剧情也没怎么变，演员也没怎么变，只是时间变了，为情怀支持一波！&lt;/p&gt;

      
    
    </summary>
    
      <category term="七七八八" scheme="https://pingao777.github.io/categories/%E4%B8%83%E4%B8%83%E5%85%AB%E5%85%AB/"/>
    
    
      <category term="碟中谍" scheme="https://pingao777.github.io/tags/%E7%A2%9F%E4%B8%AD%E8%B0%8D/"/>
    
      <category term="电影" scheme="https://pingao777.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>马上TI了，有一起玩的道友吗</title>
    <link href="https://pingao777.github.io/2018/08/10/%E9%A9%AC%E4%B8%8ATI%E4%BA%86%EF%BC%8C%E6%9C%89%E4%B8%80%E8%B5%B7%E7%8E%A9%E7%9A%84%E9%81%93%E5%8F%8B%E5%90%97/"/>
    <id>https://pingao777.github.io/2018/08/10/马上TI了，有一起玩的道友吗/</id>
    <published>2018-08-10T13:35:49.000Z</published>
    <updated>2020-09-12T03:14:00.592Z</updated>
    
    <content type="html"><![CDATA[<p>马上TI了，又到了神奇的偶数年，希望中国军团如愿以偿。老年dota玩家不能亲临现场加油助威，只能在家多玩几场游戏贡献点人气，求一起玩的d友，分数2000左右吧，娱乐局，主要周末玩。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;马上TI了，又到了神奇的偶数年，希望中国军团如愿以偿。老年dota玩家不能亲临现场加油助威，只能在家多玩几场游戏贡献点人气，求一起玩的d友，分数2000左右吧，娱乐局，主要周末玩。&lt;/p&gt;

      
    
    </summary>
    
      <category term="七七八八" scheme="https://pingao777.github.io/categories/%E4%B8%83%E4%B8%83%E5%85%AB%E5%85%AB/"/>
    
    
      <category term="Dota" scheme="https://pingao777.github.io/tags/Dota/"/>
    
  </entry>
  
  <entry>
    <title>谁说大象不能跳舞：基于Java的Markdown预览插件</title>
    <link href="https://pingao777.github.io/2018/08/04/%E8%B0%81%E8%AF%B4%E5%A4%A7%E8%B1%A1%E4%B8%8D%E8%83%BD%E8%B7%B3%E8%88%9E%EF%BC%9A%E5%9F%BA%E4%BA%8EJava%E7%9A%84Markdown%E9%A2%84%E8%A7%88%E6%8F%92%E4%BB%B6/"/>
    <id>https://pingao777.github.io/2018/08/04/谁说大象不能跳舞：基于Java的Markdown预览插件/</id>
    <published>2018-08-04T03:49:59.000Z</published>
    <updated>2020-09-12T03:14:00.592Z</updated>
    
    <content type="html"><![CDATA[<p>Java一直以来都给人留下了笨重的印象，按说插件这种轻量的任务根本和Java没啥关系，但是这次我要霸王硬上弓，让大象跳次舞。</p><p>跳什么舞呢？这是个问题，突然想起写博客一直困扰自己的一个问题：我一直使用Vim编写Markdown，有时候难免想看看效果，欣赏下文字跳动的样子，但是Vim不支持预览，自己一直用Chrome一款插件<a href="https://chrome.google.com/webstore/detail/markdown-viewer/ckkdlimhmcjmikdlpkmbgfkaikojcbjk">Markdown Viewer</a>进行预览，遗憾的是这款插件不支持动态刷新也不支持同步滚动，所以如果你没有一下点出十个信号的手速，这个操作是比较尴尬的。既然这样，能不能用Java整个插件呢？</p><a id="more"></a><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><p>既然现在Markdown Viewer只能显示不能滚动，那么通过程序将Vim的某种位置信息传给浏览器，然后调用js滚动到这个位置不就可以了吗？想让浏览器显示网页而且网页的内容还得不停的变，需要一个Web服务器，这正是Java的强项。从浏览器到Java的路走通了，但是Vim到Java的路怎么走呢？由于Vim不支持Java，二者怎么通信呢，这时看到著名的胶水语言，编程语言界的媒婆Python是被Vim支持的，方案有了：让Python与Java通信。好，这样整个流程就通了。整体框架如下所示：</p><p><img src="https://wocanmei-hexo.nos-eastchina1.126.net/%E8%B0%81%E8%AF%B4%E5%A4%A7%E8%B1%A1%E4%B8%8D%E8%83%BD%E8%B7%B3%E8%88%9E%EF%BC%9A%E5%9F%BA%E4%BA%8EJava%E7%9A%84Markdown%E9%A2%84%E8%A7%88%E6%8F%92%E4%BB%B6/architecture.png" alt="architecture"></p><h2 id="Java服务器"><a href="#Java服务器" class="headerlink" title="Java服务器"></a>Java服务器</h2><p>Web这片领域简直就是Java的主场，自然一点问题没有。以前学过Netty，一直没有派上用场，这次终于可以小试牛刀了。</p><pre><code class="java">public class HttpRequestHandler extends SimpleChannelInboundHandler&lt;FullHttpRequest&gt; &#123;    private MarkDownServer server;    public HttpRequestHandler(MarkDownServer server) &#123;        this.server = server;    &#125;    @Override    public void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) &#123;        String uri = request.uri();        if (uri.startsWith(&quot;/index&quot;)) &#123;            index(ctx, request);        &#125; else if (uri.startsWith(&quot;/ws&quot;)) &#123;            ctx.fireChannelRead(request.retain());        &#125; else if (uri.startsWith(&quot;/js&quot;) || uri.startsWith(&quot;/css&quot;)) &#123;            transferStaticFile(ctx, request);        &#125; else if (uri.startsWith(&quot;/image&quot;)) &#123;            image(ctx, request);        &#125; else &#123;            commonResponse(ctx, request, FileUtils.getBytes(&quot;How do you do&quot;), MiMeType.PLAIN);        &#125;    &#125;&#125;</code></pre><p>上面即是Web服务的框架程序，细节就不贴了。但是有几个问题大家要注意：</p><ul><li>服务器怎么和浏览器通信？</li><li>网页里的js和css怎么返回？</li><li>Python怎么和Java通信？</li></ul><p>上面的程序处理的正是前两个问题。</p><p>先说服务器怎么和浏览器通信，最初定的是ajax，但是后来找到一种更好的方案WebSocket，WebSocket可以让浏览器和服务器保持长连接，有更好的流畅性和速度，这就是上面/ws所处理的内容。</p><p>第二个问题，网页中的静态文件js和css需要让服务器返回，就像tomcat这些通用服务器做的那样，这里没什么复杂的，就是一个简单的文件读写，只有一点需要注意：文件的编码，否则页面会乱码。</p><p>第三个问题，Python怎么和Java通信，最初采用的是<a href="https://www.py4j.org/">py4j</a>，优点是这个库可以直接在Python里调用Java程序，缺点是需要安装额外的库，对于有着代码洁癖的我不是一个完美的方案，后来一想既然已经有了Web服务器，直接使用Http不就可以了，所以将方案又改为使用Http与Java通信，经过实验，这个方案虽然不用安装额外的库了，但是由于Python的原装urllib库不能保持长连接，随着连接的增多，速度会慢慢降下来，看来还得另寻出路。</p><pre><code class="java">private class SocketServerHandler extends ChannelInboundHandlerAdapter &#123;    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;        ByteBuf in = (ByteBuf) msg;        String string = in.toString(CharsetUtil.UTF_8);        LOGGER.info(&quot;Server received: &quot; + string);        String[] data = string.split(SEP);        switch (data[0]) &#123;            case &quot;start&quot;:                server = MarkDownServer.getInstance();                server.setTheme(data[2]);                server.start(Integer.parseInt(data[1]));                break;            case &quot;sync&quot;:                server.broadcast(&quot;sync&quot;, data[1], Base64Utils.decode2String(data[2]), Integer.parseInt(data[3]));                break;            case &quot;close&quot;:                server.broadcast(&quot;close&quot;, data[1], &quot;&quot;, 1);                break;            case &quot;stop&quot;:                server.destroy();                System.exit(0);                break;            default:                LOGGER.info(&quot;Command &#123;&#125; is unknown&quot;, data[0]);        &#125;    &#125;&#125;</code></pre><p>这就是最终的解决方案：返璞归真，直接使用最底层的Socket与Java通信。经过实验，速度提升明显，而且由于Socket客户端和服务端可以保持长连接，没有运行一段时间，速度变慢的缺点。</p><p>通信主要包含四种情况：</p><ul><li>start：启动Http服务器</li><li>sync：同步内容和位置</li><li>close：关闭预览窗口</li><li>stop：停止Http服务器，退出系统</li></ul><h2 id="Java-gt-浏览器"><a href="#Java-gt-浏览器" class="headerlink" title="Java-&gt;浏览器"></a>Java-&gt;浏览器</h2><pre><code class="javascript">var url = &#39;ws://127.0.0.1:&#39; + window.location.port + &#39;/ws&#39;;if (!WebSocket) &#123;    console.warn(&#39;WebSocket is not support&#39;);&#125; else &#123;    console.log(&#39;Try to connect &#39; + url);    var ws = new WebSocket(url);    ws.onclose = function () &#123;        console.log(&#39;Disconnected&#39;);        close();    &#125;;    ws.onmessage = function (d) &#123;        console.log(&#39;Response : &#39; + d.data.length);        var data = JSON.parse(d.data);        var path = $(&#39;#path&#39;);        if (path.val() === &#39;&#39;) &#123;            init(data);        &#125; else &#123;            if (path.val() === data.path) &#123;                if (data.command === &#39;close&#39;) &#123;                    close()                &#125; else if (data.command === &#39;sync&#39;) &#123;                    sync(data);                &#125;            &#125;        &#125;    &#125;;&#125;var init = function (data) &#123;    $(&#39;title&#39;).html(data.path);    $(&#39;#path&#39;).val(data.path);    $(&#39;.markdown-body&#39;).html(&#39;&#39;);    markdown_refresh(data.units);    highlight_code();    scroll_if_possible();&#125;;var sync = function (data) &#123;    markdown_refresh(data.units);    highlight_code();    scroll_if_possible();&#125;;</code></pre><p>前端就是一个WebSoket客户端，接受两种指令：close和sync，前者用于关闭页面，后者用于同步信息。</p><p>大致的流程是浏览器第一次收到服务器消息调用<code>init</code>进行初始化，它会将网页的title和页面元素#path置为文件的路径，将.markdown-body清空，因为浏览器刚启动时会启动一个index介绍页面，需要将其清空，然后调用<code>markdown_refresh</code>刷新显示新的内容，内容显示后<code>hightlight_code</code>负责高亮其中的代码，最后用<code>scroll_if_possible</code>滚动到指定位置。往后浏览器每收到服务器消息都会调用<code>sync</code>同步信息和位置，<code>sync</code>和<code>init</code>内部代码差不多，我就不再赘述了。</p><h2 id="Vim-gt-Java"><a href="#Vim-gt-Java" class="headerlink" title="Vim-&gt;Java"></a>Vim-&gt;Java</h2><p>以上走通了Java到浏览器的路，下面看看如何走Vim到Java的路，在整体思路中提到Vim支持Python，所以这条路的主角就是Python，最初是发送Http请求与Java交互，后来又改为使用Socket，原因参看Java服务器那一节。最终的代码如下：</p><pre><code class="python">SEP = &#39;\r\n\r\n&#39;EOF = &#39;$_@&#39;s = Nonedef start(port, theme):    global s    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((&#39;127.0.0.1&#39;, 23789))    s.send(&#39;start&#39; + SEP + str(port) + SEP + theme + EOF)def sync(path, content, bottom):    s.send(&#39;sync&#39; + SEP + path + SEP + base64.b64encode(content) + SEP + str(bottom) + EOF)def close(path):    s.send(&#39;close&#39; + SEP + path + EOF)def stop():    s.send(&#39;stop&#39; + EOF)    s.close()</code></pre><p>变量解释：<code>path</code>表示打开文件的路径，<code>content</code>为buffer内容，<code>bottom</code>为当前窗口的末行。</p><p>这里的函数和Java Socket服务器那一节里处理的四种情况一一对应，想不起来的可以回去再看下。你可能注意到每次发送消息后面都加了一个<code>EOF</code>，这是因为Tcp是基于流的通信协议，需要一种策略告诉接受方什么时候是一条完整的消息，这里采用的是终结符的形式，即每条消息后面都加了一个<code>EOF</code>告知接收方已经接受了一条完整的消息。另外需要对<code>content</code>进行base64编码，因为<code>content</code>里可能包含一些特殊字符，传输过程中对这些字符处理不一致会导致出错。</p><p>下一步就是在Vimscript里调用Python，我就不贴代码了。</p><h2 id="一步之遥"><a href="#一步之遥" class="headerlink" title="一步之遥"></a>一步之遥</h2><p>至此，插件就基本编写完成了，似乎离成功只有一步之遥了，但成功往往没那么简单。运行一下，乍看起来效果还可以，但是存在两个比较严重的问题：</p><h3 id="MathJax抖动"><a href="#MathJax抖动" class="headerlink" title="MathJax抖动"></a>MathJax抖动</h3><p>每次滚动时，如果页面里包含MathJax表达式，页面就会一抖一抖的。这是因为所有的内容都存在一个<code>&lt;article&gt;&lt;/article&gt;</code>标签里，前端每次加载内容，都要刷新内容里所有的MathJax表达式，表达式加载需要时间，未加载完成时有一个空的占位，加载完成使用真正的元素替换，类似网页中的图片加载流程，占位和真正的元素大小不一致，这样给人的感觉就是页面一抖一抖的，最初用的代码如下：</p><pre><code class="javascript">MathJax.Hub.Config(&#123;extensions: [&quot;tex2jax.js&quot;],    jax: [&quot;input/TeX&quot;, &quot;output/SVG&quot;],    tex2jax: &#123;        inlineMath: [ [&#39;$&#39;,&#39;$&#39;], [&quot;\\(&quot;,&quot;\\)&quot;] ],        displayMath: [ [&#39;$$&#39;,&#39;$$&#39;], [&quot;\\[&quot;,&quot;\\]&quot;] ]    &#125;,    messageStyle: &quot;none&quot;&#125;);MathJax.Hub.Queue([&quot;Typeset&quot;, MathJax.Hub]);</code></pre><p>那怎么解决呢？既然是因为刷新全部的MathJax表达式，那么不让它刷新全部，让它刷新的内容越少抖动不就越小了？查阅MathJax的文档，找到一个函数<code>MathJax.Hub.Queue([&#39;Typeset&#39;, MathJax.Hub, element])</code>，它只会刷新页面元素element里的表达式，修改服务器同步信息代码，改全量同步为增量同步，如果里面包含MathJax表达式就调用上述命令刷新。</p><p>新的前端代码如下：</p><pre><code class="javascript">$.each(units, function (i, u) &#123;    if (u.operate === &#39;REPLACE&#39;) &#123;        if (u.id === &#39;toc_container&#39;) &#123;            $(&#39;.markdown-body&#39;).css(&#39;padding-left&#39;, &#39;200px&#39;);            var toc = $(&#39;#&#39; + u.id);            toc.html(u.content);            toc.show();        &#125; else &#123;            $(&#39;#&#39; + u.id).replaceWith(u.content);        &#125;    &#125; else if (u.operate === &#39;APPEND&#39;) &#123;        $(&#39;.markdown-body&#39;).append(u.content);    &#125; else if (u.operate === &#39;REMOVE&#39;) &#123;        if (u.id === &#39;toc_container&#39;) &#123;            $(&#39;.markdown-body&#39;).css(&#39;padding-left&#39;, &#39;45px&#39;);            var cot = $(&#39;#&#39; + u.id);            cot.html(&#39;&#39;);            cot.hide();        &#125; else &#123;            $(&#39;#&#39; + u.id).remove();        &#125;    &#125;    if (u.isMathJax === 1) &#123;        MathJax.Hub.Queue([&#39;Typeset&#39;, MathJax.Hub, u.id]);    &#125;&#125;)</code></pre><h3 id="本地图片不显示"><a href="#本地图片不显示" class="headerlink" title="本地图片不显示"></a>本地图片不显示</h3><p>由于浏览器安全策略的限制，页面的img标签不能打开本地图片，即形如<code>&lt;img src=&#39;D:\path-to-img.jpg&#39;/&gt;</code>这种写法浏览器不会加载图片，而是提示“Not allowed to load local resource”。一般在文章未发布到网上时，图片地址往往写一个本地的绝对路径，如果不能显示本地图片的话将会大大影响方便性。那么该怎么办呢，第一种方法是写相对路径，即<code>&lt;img src=&#39;/path-to-img.jpg&#39;/&gt;</code>，这种方式有很大的局限性，即必须将图片放在一个位置，与网页呈一种相对关系；另一种是写的时候还是写绝对路径，经过程序转成服务器地址，然后通过服务器将图片返给浏览器。显然第二种方式更加灵活，核心代码如下：</p><pre><code class="java">private static void transformLocalImgSrc(Element element) &#123;    Elements images = element.select(&quot;img&quot;);    for (Element img : images) &#123;        String src = img.attr(&quot;src&quot;);        if (!src.startsWith(&quot;http&quot;)) &#123;            if (isWindows()) &#123;                img.attr(&quot;src&quot;, &quot;/image?path=&quot; + src.replace(&quot;\\&quot;, &quot;\\\\&quot;));            &#125; else &#123;                img.attr(&quot;src&quot;, &quot;/image?path=&quot; + src);            &#125;        &#125;    &#125;&#125;</code></pre><p>上面的代码将形如<code>D:\path-to-img.jpg</code>的本地路径转成<code>http://127.0.0.1:7788/image?path=D:\\path-to-img.jpg</code>(windows系统，其他系统路径与此略有不同)，然后由服务器将图片内容返回。这样就绕过了浏览器的安全策略，实现本地图片的加载了。</p><h2 id="阳光总在风雨后"><a href="#阳光总在风雨后" class="headerlink" title="阳光总在风雨后"></a>阳光总在风雨后</h2><p>尽管经过了一些风雨，最后还是看到胜利的曙光了。这个项目够小，涵盖的语言和知识并不少，作为一个练手的项目还是不错的，如果碰巧还能给生活提供点便利，何乐而不为呢？想了解大象跳舞的更多细节请戳<a href="https://github.com/pingao777/markdown-preview-sync">github</a>。</p><p>参考资料：</p><ul><li>Netty in action</li><li><a href="http://candidtim.github.io/vim/2017/08/11/write-vim-plugin-in-python.html">write vim plugin in python</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java一直以来都给人留下了笨重的印象，按说插件这种轻量的任务根本和Java没啥关系，但是这次我要霸王硬上弓，让大象跳次舞。&lt;/p&gt;
&lt;p&gt;跳什么舞呢？这是个问题，突然想起写博客一直困扰自己的一个问题：我一直使用Vim编写Markdown，有时候难免想看看效果，欣赏下文字跳动的样子，但是Vim不支持预览，自己一直用Chrome一款插件&lt;a href=&quot;https://chrome.google.com/webstore/detail/markdown-viewer/ckkdlimhmcjmikdlpkmbgfkaikojcbjk&quot;&gt;Markdown Viewer&lt;/a&gt;进行预览，遗憾的是这款插件不支持动态刷新也不支持同步滚动，所以如果你没有一下点出十个信号的手速，这个操作是比较尴尬的。既然这样，能不能用Java整个插件呢？&lt;/p&gt;
    
    </summary>
    
      <category term="技术人生" scheme="https://pingao777.github.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="Java" scheme="https://pingao777.github.io/tags/Java/"/>
    
      <category term="Vim" scheme="https://pingao777.github.io/tags/Vim/"/>
    
      <category term="Markdown" scheme="https://pingao777.github.io/tags/Markdown/"/>
    
      <category term="Python" scheme="https://pingao777.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Vim Markdown预览插件markdown-preview-sync</title>
    <link href="https://pingao777.github.io/2018/07/29/Vim%20Markdown%E9%A2%84%E8%A7%88%E6%8F%92%E4%BB%B6markdown-preview-sync/"/>
    <id>https://pingao777.github.io/2018/07/29/Vim Markdown预览插件markdown-preview-sync/</id>
    <published>2018-07-29T02:24:06.000Z</published>
    <updated>2020-09-12T03:14:00.584Z</updated>
    
    <content type="html"><![CDATA[<p>花了大概两个星期整了个Vim预览插件<a href="https://github.com/pingao777/markdown-preview-sync">markdown-preview-sync</a>，主要参考了<a href="https://chrome.google.com/webstore/detail/markdown-viewer/ckkdlimhmcjmikdlpkmbgfkaikojcbjk">Markdown Viewer</a>和<a href="https://github.com/iamcco/markdown-preview.vim">markdown-preview.vim</a>这两款插件，感谢这两款插件的作者。</p><p>支持如下特性：</p><ul><li>代码高亮</li><li>MathJax</li><li>自定义CSS</li><li>GFM-TABLE</li><li>目录TOC</li></ul><p>运行效果如图：</p><a id="more"></a><p><img src="https://wocanmei-hexo.nos-eastchina1.126.net/markdown-preview-sync/mpsync-snapshot.png" alt="效果图"></p><p><strong>为了用户体验，预览并不是实时显示的，而是在换行时或保存时</strong>。这一点是有意为之的，毕竟大家对Markdown语法都了如指掌了，只是想偶尔看下效果。相信大家都有这样的体验，眼睛不停的在编辑屏和预览屏来回切换，眼睛很累，同时思路也很容易被打断，而且根据我个人的实验，同步频率太快会影响Vim的流畅性。</p><p>最后再啰嗦一句，欢迎大家使用并提出宝贵意见！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;花了大概两个星期整了个Vim预览插件&lt;a href=&quot;https://github.com/pingao777/markdown-preview-sync&quot;&gt;markdown-preview-sync&lt;/a&gt;，主要参考了&lt;a href=&quot;https://chrome.google.com/webstore/detail/markdown-viewer/ckkdlimhmcjmikdlpkmbgfkaikojcbjk&quot;&gt;Markdown Viewer&lt;/a&gt;和&lt;a href=&quot;https://github.com/iamcco/markdown-preview.vim&quot;&gt;markdown-preview.vim&lt;/a&gt;这两款插件，感谢这两款插件的作者。&lt;/p&gt;
&lt;p&gt;支持如下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码高亮&lt;/li&gt;
&lt;li&gt;MathJax&lt;/li&gt;
&lt;li&gt;自定义CSS&lt;/li&gt;
&lt;li&gt;GFM-TABLE&lt;/li&gt;
&lt;li&gt;目录TOC&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;运行效果如图：&lt;/p&gt;
    
    </summary>
    
      <category term="七七八八" scheme="https://pingao777.github.io/categories/%E4%B8%83%E4%B8%83%E5%85%AB%E5%85%AB/"/>
    
    
      <category term="Vim" scheme="https://pingao777.github.io/tags/Vim/"/>
    
      <category term="Markdown" scheme="https://pingao777.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Java的equals和hashCode方法浅谈</title>
    <link href="https://pingao777.github.io/2018/07/02/Java%E7%9A%84equals%E5%92%8ChashCode%E6%96%B9%E6%B3%95%E6%B5%85%E8%B0%88/"/>
    <id>https://pingao777.github.io/2018/07/02/Java的equals和hashCode方法浅谈/</id>
    <published>2018-07-02T08:20:39.000Z</published>
    <updated>2020-09-12T03:14:00.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p><code>equals</code>和<code>hashCode</code>作为Java基础经常在面试中提到，比如下面几个问题：</p><ol><li><code>equals</code>和<code>==</code>有什么区别？</li><li><code>equals</code>和<code>hashCode</code>有什么关系？</li><li><code>equals</code>和<code>hashCode</code>如何编写？</li></ol><p>对于第一个问题不少人只停留在字符串<code>equals</code>比较的是内容，<code>==</code>比较的是内存地址，而对<code>equals</code>的本质极少过问。第二个问题，大多数都知道答案，也有不少记反了，但是更进一步为什么是那样的关系，就不知道了。对于第三个问题，大部分人一上手就把方法签名写错了，就别谈正确的写出实现了。带着这些问题，接下来谈谈自己的一点理解。</p><a id="more"></a><h2 id="二、equals方法"><a href="#二、equals方法" class="headerlink" title="二、equals方法"></a>二、equals方法</h2><p>先来看见<code>equals</code>方法的签名，</p><pre><code class="java">public boolean equals(Object obj) &#123;  return (this == obj);&#125;</code></pre><p>可以看到入参是<code>Object</code>，很多人没有注意到这一点，上来就写错了。equals方法顾名思义就判断对象的相等性，默认实现就是<code>==</code>，那么说到二者的区别，个人理解，<code>equals</code>方法是一种用户定义的“逻辑等”，而<code>==</code>是一种“物理等”，用俗语解释就是，<code>equals</code>判断是否相同，<code>==</code>判断是否一样。</p><p><code>equals</code>方法在编写的时候需要遵循以下原则：</p><ul><li>自反性</li><li>对称性</li><li>传递性</li><li>一致性</li></ul><p>下面展开说一下，</p><ol><li>自反性的意思是，对于一个非<code>null</code>的对象x，<code>x.equals(x)</code>一定为<code>true</code>，这是显而易见的，无须赘述。</li><li><p>对称性，对于非<code>null</code>对象x、y，<code>x.equals(y) == true</code>，当且仅当<code>y.equals(x) == true</code>。来看一个来自《Effective Java》的例子，</p><pre><code class="java"> // Broken - violates symmetry! public final class CaseInsensitiveString &#123;   private final String s;   public CaseInsensitiveString(String s) &#123;     this.s = Objects.requireNonNull(s);   &#125;   // Broken - violates symmetry!   @Override public boolean equals(Object o) &#123;     if (o instanceof CaseInsensitiveString)       return s.equalsIgnoreCase(           ((CaseInsensitiveString) o).s);     if (o instanceof String)  // One-way interoperability!       return s.equalsIgnoreCase((String) o);     return false;   &#125;   ...  // Remainder omitted &#125; CaseInsensitiveString cis = new CaseInsensitiveString(&quot;Polish&quot;); String s = &quot;polish&quot;; List&lt;CaseInsensitiveString&gt; list = new ArrayList&lt;&gt;(); list.add(cis); // true or false list.contains(s);</code></pre><p> 在JDK8运行<code>list.contains(s)</code>返回<code>false</code>，但是有的JDK可能会返回<code>true</code>，甚至直接崩溃，所以如果违反了对称性，程序的行为是不可预测的。</p></li><li><p>传递性，对于非<code>null</code>对象x、y、z，如果<code>x.equals(y) == true</code>且<code>y.equals(z) == true</code>，那么<code>x.equals(z) == true</code>。同样是来自《Effective Java》的一个例子，</p><pre><code class="java"> public class Point &#123;   private final int x;   private final int y;   public Point(int x, int y) &#123;     this.x = x;     this.y = y;   &#125;   @Override public boolean equals(Object o) &#123;     if (!(o instanceof Point))       return false;     Point p = (Point)o;     return p.x == x &amp;&amp; p.y == y;   &#125;   ...  // Remainder omitted &#125; public class ColorPoint extends Point &#123;   private final Color color;   public ColorPoint(int x, int y, Color color) &#123;     super(x, y);     this.color = color;   &#125;   // Broken - violates transitivity!   @Override public boolean equals(Object o) &#123;     if (!(o instanceof Point))       return false;     // If o is a normal Point, do a color-blind comparison     if (!(o instanceof ColorPoint))       return o.equals(this);     // o is a ColorPoint; do a full comparison     return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color;   &#125;   ...  // Remainder omitted &#125; ColorPoint p1 = new ColorPoint(1, 2, Color.RED); Point p2 = new Point(1, 2); ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);</code></pre><p> 显然<code>ColorPoint</code>的<code>equals</code>实现违反了传递性，<code>p1.equals(p2) == p2.equals(p3) != p1.equals(p3)</code>。假如<code>Point</code>有两个子类<code>ColorPoint</code>和<code>SmellPoint</code>，<code>colorPoint.equals(smellPoint)</code>将会导致无限递归，最终导致内存耗尽。引用《Effective Java》的说法，</p><blockquote><p>There is no way to extend an instantiable class and add a value component while preserving the equals contract, unless you’re willing to forgo the benefits of object-oriented abstraction.</p></blockquote><p> 这句话的大意是如果你继承扩展一个类，就没法再保持<code>equals</code>的原则了，除非放弃使用继承。放弃继承？这不是让我们因噎废食嘛，咦，别说，还真能放弃继承，那就是组合，因为本文的重点是<code>equals</code>和<code>hashCode</code>就不展开了。</p></li><li><p>一致性，对于非<code>null</code>对象x、y，多次调用<code>x.equals(y)</code>返回一致。一致性意味着<code>equals</code>方法不要依赖不可靠的变量，这里“可靠”的意思不光意味着“不该变时不变”，还意味着“想获取时能获取到”，比如<code>java.net.URL</code>的<code>equals</code>实现依赖了ip地址，而网络故障时无法获取ip，这是一个不好的实现。</p></li></ol><p>说了那么多，有人可能会说，哎呀这么多原则顾头不顾尾，都要满足，太难了吧，下面列出实现<code>equals</code>的一些tips，照着做实现起来就易如反掌，</p><ol><li>使用<code>==</code>判断是否为<code>null</code>或<code>this</code>，如果是前者返回<code>false</code>，后者就返回<code>true</code>。</li><li>使用<code>instanceof</code>检测是否是正确的类型，如果不是直接返回<code>false</code>，如果是，强制转换为正确的类型，然后比较与“逻辑等”相关的变量。</li></ol><h2 id="三、hashCode方法"><a href="#三、hashCode方法" class="headerlink" title="三、hashCode方法"></a>三、hashCode方法</h2><p><code>hashCode</code>主要用来在Java中哈希数据结构<code>HashMap</code>、<code>HashSet</code>生成哈希值，<code>hashCode</code>的方法签名，</p><pre><code class="java">public native int hashCode();</code></pre><p>默认实现会将对象的内存地址转化为一个整数，因此只有同一个对象<code>hashCode</code>才一样，即使两个<code>equals</code>返回<code>true</code>的对象<code>hashCode</code>也不一样，如果不进行重写。和<code>equals</code>一样，<code>hashCode</code>也需要满足一些原则：</p><ol><li><p>一致性，和<code>equals</code>相关的变量没有变化，<code>hashCode</code>返回值也不能变化。</p></li><li><p>两个对象<code>equals</code>返回<code>true</code>，<code>hashCode</code>返回值应该相等。由上面得知，<code>hashCode</code>默认实现不满足这一条件，因此任何类如果实现了<code>equals</code>就必须实现<code>hashCode</code>，确保二者的步调一致，下面来看一个反例，</p><pre><code class="java"> public class Person &#123;   private int age;   private String name;   public Person(int age, String name) &#123;     this.age = age;     this.name = name;   &#125;   @Override     public boolean equals(Object obj) &#123;       if (obj == null) &#123;         return false;       &#125;       if (obj == this) &#123;         return true;       &#125;       if (obj instanceof Person) &#123;         Person that = (Person) obj;         return age == that.age &amp;&amp; Objects.equals(name, that.name);       &#125;       return false;     &#125; &#125; Map&lt;Person, Integer&gt; map = new HashMap&lt;&gt;(); map.put(new Person(10, &quot;小明&quot;), 1); map.get(new Person(10, &quot;小明&quot;));</code></pre><p> 初学者可能觉得最后一条语句会返回1，事实上返回的是<code>null</code>，为什么会这样呢？明明将数据放进去了，而数据却像被黑洞吞噬一样，要解释得从<code>HashMap</code>的数据结构说起，<code>HashMap</code>是由数组和链表组成的一种组合结构，如下图，往里存放时，<code>hashCode</code>决定数组的下标，而<code>equals</code>用于查找值是否已存在，存在的话替换，否则插入；往外取时，先用<code>hashCode</code>找到对应数组下标，然后用<code>equals</code>挨个比较直到链表的尾部，找到返回相应值，找不到返回null。再回过头看刚才的问题，先放进去一个<code>new Person(10, &quot;小明&quot;)</code>，然后取的时候又新建了一个<code>new Person(10, &quot;小明&quot;)</code>，由于没有重写<code>hashCode</code>，这两个对象的<code>hashCode</code>是不一样的，存和取的数组下标也就不一样，自然取不出来了。</p><p> <img src="https://wocanmei-hexo.nos-eastchina1.126.net/Java%E7%9A%84equals%E5%92%8ChashCode%E6%96%B9%E6%B3%95%E6%B5%85%E8%B0%88/hashmap.png" alt="HashMap数据结构"></p></li><li><p>两个对象<code>equals</code>返回<code>false</code>，<code>hashCode</code>返回值可以相等，但是如果不等的话，可以改进哈希数据结构的性能。这条原则也可以用<code>HashMap</code>的数据结构解释，举一个极端的例子，假如<code>Person</code>所有对象的<code>hashCode</code>都一样，那么<code>HashMap</code>内部数组的下标都一样，数据就会进到同一张链表里，这张链表比正常情况下要长的多，而遍历链表是一项耗时的工作，性能也就下来了。</p></li></ol><p>那么如何写一个好的<code>hashCode</code>呢？</p><ol><li>声明一个变量<code>int</code>的变量<code>result</code>，将第一个和<code>equals</code>相关的实例变量的<code>hashCode</code>赋值给它。</li><li>然后按照下列规则依次计算剩下的实例变量的<code>hashCode</code>值<code>c</code>。<ol><li>如果是null，设置一个常数，通常为0</li><li>如果是原始类型，使用<code>Type.hashCode(f)</code>，<code>Type</code>为它们的装箱类型</li><li>如果是数组，如果每一个元素都是相关的，可以使用<code>Arrays.hashCode</code>；否则将相关元素看作独立的变量计算</li></ol></li><li>使用<code>result = 31 * result + c</code>的形式将每个变量的哈希值组合起来，最后返回<code>result</code>。</li></ol><p>参考资料：《Effective Java》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;equals&lt;/code&gt;和&lt;code&gt;hashCode&lt;/code&gt;作为Java基础经常在面试中提到，比如下面几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;equals&lt;/code&gt;和&lt;code&gt;==&lt;/code&gt;有什么区别？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;equals&lt;/code&gt;和&lt;code&gt;hashCode&lt;/code&gt;有什么关系？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;equals&lt;/code&gt;和&lt;code&gt;hashCode&lt;/code&gt;如何编写？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于第一个问题不少人只停留在字符串&lt;code&gt;equals&lt;/code&gt;比较的是内容，&lt;code&gt;==&lt;/code&gt;比较的是内存地址，而对&lt;code&gt;equals&lt;/code&gt;的本质极少过问。第二个问题，大多数都知道答案，也有不少记反了，但是更进一步为什么是那样的关系，就不知道了。对于第三个问题，大部分人一上手就把方法签名写错了，就别谈正确的写出实现了。带着这些问题，接下来谈谈自己的一点理解。&lt;/p&gt;
    
    </summary>
    
      <category term="技术人生" scheme="https://pingao777.github.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="Java" scheme="https://pingao777.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
