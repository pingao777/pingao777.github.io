<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>简明Java反射教程1：类（Classes） - 扯淡有理</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=Java,反射>
  
    <meta name="description" content="Java Python R 机器学习 统计 扯淡">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="扯淡有理" type="application/atom+xml">
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=default"></script>
  <script>
      hljs.initHighlightingOnLoad();
  </script>
  <script type='text/x-mathjax-config'>
        MathJax.Hub.Config({
            extensions: ["tex2jax.js"],
            jax: ["input/TeX", "output/SVG"],
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
            },
            messageStyle: "none"
        });
    </script>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-44085500-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-44085500-1');
    </script>

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.1.1"></head>

  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">扯淡有理</a>
    <div class="subtitle"></div>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">主页</a>
        </li>
      
        <li class="menu-item">
          <a href="/tags" class="menu-item-link">标签</a>
        </li>
      
        <li class="menu-item">
          <a href="/about" class="menu-item-link">关于</a>
        </li>
      
        <li class="menu-item">
          <a href="/atom.xml" class="menu-item-link">订阅</a>
        </li>
      
    </ul>
  </nav>
</header>
<article class="post">
  <div class="post-title">
    <h1 class="article-title">简明Java反射教程1：类（Classes）</h1>
  </div>
   <div class="post-meta">
    <span class="post-time">2020-03-07</span>
  </div>
  <div class="post-content">
    <p>Java反射历来是迈入高级Java开发者的必备科目，网上教程是五花八门，有的失于不够全面，有的失于谬误百出。看过之后不懂的更不懂了，懂得也有点蒙了，偶然看到Oracle的官方教程页面，仿佛打开了新的世界，里面的教程不仅简明易懂而且非常权威，毕竟是官方出品，里面有篇<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/reflect/index.html">反射</a>教程，非常不错，翻译一下，推荐给大家。由于篇幅相对于一篇博客来说还是有点长了，我将其分为三个部分：类､成员以及数组和枚举类型。本篇是第一篇，类的反射。</p>
<h2 id="反射用途"><a href="#反射用途" class="headerlink" title="反射用途"></a>反射用途</h2><p>反射通常用来修改Java虚拟机应用程序的运行时行为。这是一个相对高级的功能，只应由对语言基础有很深了解的开发人员使用。考虑到这一点，反射是一种强大的技术，可以使应用程序执行原本不可能的操作。</p>
<h3 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h3><p>应用程序可以通过使用其完全限定名创建外部用户定义类的实例。</p>
<h3 id="类浏览器和可视化开发环境"><a href="#类浏览器和可视化开发环境" class="headerlink" title="类浏览器和可视化开发环境"></a>类浏览器和可视化开发环境</h3><p>类浏览器需要枚举类的成员。可视化开发环境可以利用反射中可用的类型信息来帮助开发人员编写正确的代码。</p>
<h3 id="调试和测试工具"><a href="#调试和测试工具" class="headerlink" title="调试和测试工具"></a>调试和测试工具</h3><p>调试工具需要检查类的私有成员。测试工具可以利用反射来系统地调用在类上定义的可发现的API集合，以确保代码的高覆盖率。</p>
<h2 id="反射弊端"><a href="#反射弊端" class="headerlink" title="反射弊端"></a>反射弊端</h2><p>反射功能强大，但不应任意使用。如果可以在不使用反射的情况下实现需要的操作，那么最好避免使用它。通过反射访问代码时应牢记以下问题。</p>
<h3 id="性能开销"><a href="#性能开销" class="headerlink" title="性能开销"></a>性能开销</h3><p>由于反射涉及动态解析的类型，因此无法执行某些Java虚拟机优化。因此，反射操作的性能要比非反射操作慢，因此，在性能敏感的应用程序中经常调用的代码段中，应避免使用反射。</p>
<h3 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h3><p>反射需要运行时许可，而在安全管理器下运行时可能不存在这种许可。对于必须在受限的安全上下文（例如Applet）中运行的代码，这是一个重要的考虑因素。</p>
<h3 id="内部暴露"><a href="#内部暴露" class="headerlink" title="内部暴露"></a>内部暴露</h3><p>由于反射允许执行在非反射代码中非法的操作，例如访问私有字段和方法，因此使用反射可能会导致意外的副作用，这可能会使代码无法正常工作并可能破坏可移植性。反射代码破坏了抽象，因此可能会随着平台的升级而改变行为。</p>
<h2 id="教程章节"><a href="#教程章节" class="headerlink" title="教程章节"></a>教程章节</h2><p>本教程涵盖了反射在访问和操作类、字段、方法和构造函数方面的常见用法。每节课均包含代码示例，技巧和故障排除信息。</p>
<p>主要章节为：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/reflect/class/index.html"><strong>类</strong></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/reflect/member/index.html"><strong>成员</strong></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/reflect/special/index.html"><strong>数组和枚举类型</strong></a></li>
</ul>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>本课说明了获取<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>对象并使用它检查类的属性的各种方法，包括其声明和内容。</p>
<p>类型要么是引用类型，要么是原始类型。类，枚举和数组（都继承自<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html"><code>java.lang.Object</code></a>）以及接口都是引用类型。引用类型包括<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html"><code>java.lang.String</code></a>，原始类型的所有包装器类，例如<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html"><code>java.lang.Double</code></a>，接口 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html"><code>java.io.Serializable</code></a>和枚举<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/javax/swing/SortOrder.html"><code>javax.swing.SortOrder</code></a>。原始类型有：布尔值(<code>boolean</code>)，字节(<code>byte</code>)，短型(<code>short</code>)，整数(<code>int</code>)，长型(<code>long</code>)，字符(<code>char</code>)，浮点型(<code>float</code>)和双精度型(<code>double</code>)。</p>
<p>对于每种类型的对象，Java虚拟机都会实例化一个不可变的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>java.lang.Class</code></a>实例，该实例提供检查对象的运行时属性（包括其成员和类型信息）的方法。<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>还提供了创建类和对象的能力。最重要的是，它是所有反射API的入口点。本课涵盖了涉及类的最常见的反射操作：</p>
<ul>
<li>获取类对象描述了获取类的方式。</li>
<li>检查类修饰符和类型显示如何访问类声明信息。</li>
<li>发现类成员说明了如何在类中列出构造函数，字段，方法和嵌套类。</li>
<li>故障排除描述了使用类时遇到的常见错误。</li>
</ul>
<h4 id="获取类对象"><a href="#获取类对象" class="headerlink" title="获取类对象"></a>获取类对象</h4><p>所有反射操作的入口点是<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>java.lang.Class</code></a>。除了<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/ReflectPermission.html"><code>java.lang.reflect.ReflectPermission</code></a>之外，<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html"><code>java.lang.reflect</code></a>包下的所有类都没有公共构造函数。要获得这些类，必须在<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>上调用相应的方法。根据代码是否可以访问对象，类的名称，类型或现有的类，有几种获取类的方法。</p>
<h5 id="Object-getClass"><a href="#Object-getClass" class="headerlink" title="Object.getClass()"></a><code>Object.getClass()</code></h5><p>如果对象的实例可用，则获取其类的最简单方法是调用<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass--"><code>Object.getClass()</code></a>。当然，这仅适用于全部继承自<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html"><code>Object</code></a>的引用类型。以下是一些示例。</p>
<pre><code class="java">Class c = &quot;foo&quot;.getClass();
</code></pre>
<p>返回字符串(<code>String</code>)的类(<code>Class</code>)</p>
<pre><code class="java">Class c = System.console().getClass();
</code></pre>
<p>与虚拟机关联的唯一控制台由静态方法<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#console--"><code>System.console()</code></a>返回。<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass--"><code>getClass()</code></a>返回的值是与<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass--"><code>getClass()</code></a>对应的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>。</p>
<pre><code class="java">enum E &#123; A, B &#125;
Class c = A.getClass();
</code></pre>
<p><code>A</code>是枚举<code>E</code>的实例；因此，<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass--"><code>getClass()</code></a>返回与枚举类型<code>E</code>相对应的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>。</p>
<pre><code class="java">byte[] bytes = new byte[1024];
Class c = bytes.getClass();
</code></pre>
<p>由于数组是对象(<code>Object</code>)，因此也可以在数组的实例上调用<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass--"><code>getClass()</code></a>。返回的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>对应于组件类型为<code>byte</code>的数组。</p>
<pre><code class="java">import java.util.HashSet;
import java.util.Set;

Set&lt;String&gt; s = new HashSet&lt;String&gt;();
Class c = s.getClass();
</code></pre>
<p>在这种情况下，<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html"><code>java.util.Set</code></a>是类型为<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html"><code>java.util.HashSet</code></a>的对象的接口。<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass--"><code>getClass()</code></a>返回的值是对应于<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html"><code>java.util.HashSet</code></a>的类。</p>
<h5 id="class"><a href="#class" class="headerlink" title=".class"></a><code>.class</code></h5><p>如果类的实例不可用，那么可以使用<code>.class</code>的方式获取<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>。这也是基本类型获取<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>最简单的方式。</p>
<pre><code class="java">boolean b;
Class c = b.getClass();   // compile-time error

Class c = boolean.class;  // correct
</code></pre>
<p>请注意，语句<code>boolean.getClass()</code>会产生编译时错误，因为布尔值是基本类型且无法取消引用。<code>.class</code>语法返回与布尔类型相对应的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>。</p>
<pre><code class="java">Class c = java.io.PrintStream.class;
</code></pre>
<p>变量<code>c</code>是与类型<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html"><code>java.io.PrintStream</code></a>对应的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>。</p>
<pre><code class="java">Class c = int[][][].class;
</code></pre>
<p><code>.class</code>语法可用于获取多维数组相对应的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>。</p>
<h5 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName()"></a><code>Class.forName()</code></h5><p>如果一个类的完全限定名可用，可以使用静态方法<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#forName-java.lang.String-"><code>Class.forName()</code></a>获取相应的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>。数组的完全限定名不能用于基本类型。数组的限定名可以使用<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getName--"><code>Class.getName()</code></a>获取。<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getName--"><code>Class.getName()</code></a>适用于引用和基本类型。</p>
<pre><code class="java">Class c = Class.forName(&quot;com.duke.MyLocaleServiceProvider&quot;);
</code></pre>
<p>该语句将从给定的完全限定名称创建一个类。</p>
<pre><code class="java">Class cDoubleArray = Class.forName(&quot;[D&quot;);

Class cStringArray = Class.forName(&quot;[[Ljava.lang.String;&quot;);
</code></pre>
<p>变量<code>cDoubleArray</code>对应于基本类型为<code>double</code>的数组的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>（即与<code>double[].class</code>相同）。变量<code>cStringArray</code>对应<code>String</code>二维数组的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>（和<code>String[][].class</code>一样）。</p>
<h5 id="基本类型包装类的类型"><a href="#基本类型包装类的类型" class="headerlink" title="基本类型包装类的类型"></a>基本类型包装类的类型</h5><p>对于基本类型，<code>.class</code>是最容易的一种方式，不过还有一种方式可以获取<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>。每个基本类型和<code>void</code>在<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/package-summary.html"><code>java.lang</code></a>中都有一个包装器类，用于将原始类型装箱到引用类型。每个包装器类都包含一个名为<code>TYPE</code>的字段，该字段对应于包装的基本类型的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a>。</p>
<pre><code class="java">Class c = Double.TYPE;
</code></pre>
<p>有一个类<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html"><code>java.lang.Double</code></a>，用于在需要<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html"><code>Object</code></a>时包装基本类型<code>double</code>。 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#TYPE"><code>Double.TYPE</code></a>的值与<code>double.class</code>的值相同。</p>
<pre><code class="java">Class c = Void.TYPE;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Void.html#TYPE"><code>Void.TYPE</code></a>与<code>void.class</code>相同。</p>
<h5 id="返回Class的方法"><a href="#返回Class的方法" class="headerlink" title="返回Class的方法"></a>返回<code>Class</code>的方法</h5><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getSuperclass--"><code>Class.getSuperclass()</code></a></p>
<p>返回给定类的超类。</p>
<pre><code class="java">Class c = javax.swing.JButton.class.getSuperclass();
</code></pre>
<p><code>javax.swing.JButton</code>的超类是<code>javax.swing.AbstractButton</code>。</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getClasses--"><code>Class.getClasses()</code></a></p>
<p>返回属于该类成员的所有公共类，接口和枚举，包括继承的成员。</p>
<pre><code class="java">Class&lt;?&gt;[] c = Character.class.getClasses();
</code></pre>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html"><code>Character</code></a> 包含两个成员类 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.Subset.html"><code>Character.Subset</code></a> 和<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.UnicodeBlock.html"><code>Character.UnicodeBlock</code></a>。</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredClasses--"><code>Class.getDeclaredClasses()</code></a></p>
<p>返回所有类接口，以及在该类中显式声明的枚举。</p>
<pre><code class="java">Class&lt;?&gt;[] c = Character.class.getDeclaredClasses();
</code></pre>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html"><code>Character</code></a>包含两个公共成员类： <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.Subset.html"><code>Character.Subset</code></a>和<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.UnicodeBlock.html"><code>Character.UnicodeBlock</code></a>，一个私有类：<code>Character.CharacterCache</code>。</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaringClass--"><code>Class.getDeclaringClass()</code></a><br><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html#getDeclaringClass--"><code>java.lang.reflect.Field.getDeclaringClass()</code></a><br><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#getDeclaringClass--"><code>java.lang.reflect.Method.getDeclaringClass()</code></a><br><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Constructor.html#getDeclaringClass--"><code>java.lang.reflect.Constructor.getDeclaringClass()</code></a></p>
<p>返回这些成员的声明类。 匿名类没有声明类但但有封闭类。</p>
<pre><code class="java">import java.lang.reflect.Field;

Field f = System.class.getField(&quot;out&quot;);
Class c = f.getDeclaringClass(); // System
</code></pre>
<p>字段 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#out"><code>out</code></a>是在<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html"><code>System</code></a>中声明的。</p>
<pre><code class="java">public class MyClass &#123;
    static Object o = new Object() &#123;
        public void m() &#123;&#125; 
    &#125;;
    static Class&lt;c&gt; = o.getClass().getEnclosingClass();
&#125;
</code></pre>
<p><code>o</code>代表的匿名类的声明类为<code>null</code>。</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getEnclosingClass--"><code>Class.getEnclosingClass()</code></a></p>
<p>返回该类的直接封闭类。</p>
<pre><code class="java">Class c = Thread.State.class().getEnclosingClass();
</code></pre>
<p>枚举<code>Thread.State</code>的封闭类是<code>Thread</code>。</p>
<pre><code class="java">public class MyClass &#123;
    static Object o = new Object() &#123; 
        public void m() &#123;&#125; 
    &#125;;
    static Class&lt;c&gt; = o.getClass().getEnclosingClass();
&#125;
</code></pre>
<p><code>o</code>定义的匿名类包含在<code>MyClass</code>中。</p>
<h4 id="检查类的修饰符和类型"><a href="#检查类的修饰符和类型" class="headerlink" title="检查类的修饰符和类型"></a>检查类的修饰符和类型</h4><p>一个类在声明时可能会有一个或多个修饰符影响它的运行时行为：</p>
<ul>
<li>访问修饰符：<code>public</code>,<code>protected</code>,<code>private</code></li>
<li>需要覆盖的修饰符：<code>abstract</code></li>
<li>仅限一个实例的修饰符：<code>static</code></li>
<li>禁止修改值的修饰符：<code>final</code></li>
<li>执行严格浮点行为的修饰符：<code>strictfp</code></li>
<li>注解</li>
</ul>
<p>并非所有类都允许使用所有修饰符，例如，接口不能为<code>final</code>，而枚举不能为<code>abstract</code>。<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Modifier.html"><code>java.lang.reflect.Modifier</code></a>包含所有可能的修饰符的声明。它还包含用于解码<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getModifiers--"><code>Class.getModifiers()</code></a>返回的修饰符集的方法。</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/reflect/class/example/ClassDeclarationSpy.java"><code>ClassDeclarationSpy</code></a>示例演示如何获取类的声明组件，包括修饰符，泛型类型参数，已实现的接口和继承路径。由于<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>Class</code></a> 实现了<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html"><code>java.lang.reflect.AnnotatedElement</code></a>接口，因此也可以查询运行时注解。</p>
<pre><code class="java">import java.lang.annotation.Annotation;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;
import static java.lang.System.out;

public class ClassDeclarationSpy &#123;
    public static void main(String... args) &#123;
        try &#123;
            Class&lt;?&gt; c = Class.forName(args[0]);
            out.format(&quot;Class:%n  %s%n%n&quot;, c.getCanonicalName());
            out.format(&quot;Modifiers:%n  %s%n%n&quot;,
                   Modifier.toString(c.getModifiers()));

            out.format(&quot;Type Parameters:%n&quot;);
            TypeVariable[] tv = c.getTypeParameters();
            if (tv.length != 0) &#123;
            out.format(&quot;  &quot;);
            for (TypeVariable t : tv)
                out.format(&quot;%s &quot;, t.getName());
            out.format(&quot;%n%n&quot;);
            &#125; else &#123;
            out.format(&quot;  -- No Type Parameters --%n%n&quot;);
            &#125;

            out.format(&quot;Implemented Interfaces:%n&quot;);
            Type[] intfs = c.getGenericInterfaces();
            if (intfs.length != 0) &#123;
            for (Type intf : intfs)
                out.format(&quot;  %s%n&quot;, intf.toString());
            out.format(&quot;%n&quot;);
            &#125; else &#123;
            out.format(&quot;  -- No Implemented Interfaces --%n%n&quot;);
            &#125;

            out.format(&quot;Inheritance Path:%n&quot;);
            List&lt;Class&gt; l = new ArrayList&lt;Class&gt;();
            printAncestor(c, l);
            if (l.size() != 0) &#123;
            for (Class&lt;?&gt; cl : l)
                out.format(&quot;  %s%n&quot;, cl.getCanonicalName());
            out.format(&quot;%n&quot;);
            &#125; else &#123;
            out.format(&quot;  -- No Super Classes --%n%n&quot;);
            &#125;

            out.format(&quot;Annotations:%n&quot;);
            Annotation[] ann = c.getAnnotations();
            if (ann.length != 0) &#123;
            for (Annotation a : ann)
                out.format(&quot;  %s%n&quot;, a.toString());
            out.format(&quot;%n&quot;);
            &#125; else &#123;
            out.format(&quot;  -- No Annotations --%n%n&quot;);
            &#125;

            // production code should handle this exception more gracefully
        &#125; catch (ClassNotFoundException x) &#123;
            x.printStackTrace();
        &#125;
    &#125;

    private static void printAncestor(Class&lt;?&gt; c, List&lt;Class&gt; l) &#123;
        Class&lt;?&gt; ancestor = c.getSuperclass();
        if (ancestor != null) &#123;
            l.add(ancestor);
            printAncestor(ancestor, l);
        &#125;
    &#125;
&#125;
</code></pre>
<p>下面是输出的一些样本。用户输入以斜体显示。</p>
<p>$ <em><code>java ClassDeclarationSpy java.util.concurrent.ConcurrentNavigableMap</code></em></p>
<pre><code>Class:
  java.util.concurrent.ConcurrentNavigableMap

Modifiers:
  public abstract interface

Type Parameters:
  K V

Implemented Interfaces:
  java.util.concurrent.ConcurrentMap&lt;K, V&gt;
  java.util.NavigableMap&lt;K, V&gt;

Inheritance Path:
  -- No Super Classes --

Annotations:
  -- No Annotations --
</code></pre><p>这是实际的源代码 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentNavigableMap.html"><code>java.util.concurrent.ConcurrentNavigableMap</code></a>中的实际声明：</p>
<pre><code class="java">public interface ConcurrentNavigableMap&lt;K,V&gt;
    extends ConcurrentMap&lt;K,V&gt;, NavigableMap&lt;K,V&gt;
</code></pre>
<p>注意，由于这是一个接口，因此它是隐式<code>abstract</code>的。编译器为每个接口添加此修饰符。另外，此声明包含两个泛型参数K和V。示例代码仅打印这些参数的名称，但是可以使用<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/TypeVariable.html"><code>java.lang.reflect.TypeVariable</code></a>中的方法获取有关它们的其他信息。接口也可以实现其他接口，如上所示。</p>
<p>$ <em><code>java ClassDeclarationSpy &quot;[Ljava.lang.String;&quot;</code></em></p>
<pre><code>Class:
  java.lang.String[]

Modifiers:
  public abstract final

Type Parameters:
  -- No Type Parameters --

Implemented Interfaces:
  interface java.lang.Cloneable
  interface java.io.Serializable

Inheritance Path:
  java.lang.Object

Annotations:
  -- No Annotations --
</code></pre><p>由于数组是运行时对象，因此所有类型信息均由Java虚拟机定义。特别是，数组实现 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Cloneable.html"><code>Cloneable</code></a>和 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html"><code>java.io.Serializable</code></a> ，其直接超类始终是<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html"><code>Object</code></a>。</p>
<p>$ <em><code>java ClassDeclarationSpy java.io.InterruptedIOException</code></em></p>
<pre><code>Class:
  java.io.InterruptedIOException

Modifiers:
  public

Type Parameters:
  -- No Type Parameters --

Implemented Interfaces:
  -- No Implemented Interfaces --

Inheritance Path:
  java.io.IOException
  java.lang.Exception
  java.lang.Throwable
  java.lang.Object

Annotations:
  -- No Annotations --
</code></pre><p>从继承路径可以推断出<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/io/InterruptedIOException.html"><code>java.io.InterruptedIOException</code></a>是一个检查的异常，因为<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html"><code>RuntimeException</code></a> 没有出现。</p>
<p>$ <em><code>java ClassDeclarationSpy java.security.Identity</code></em></p>
<pre><code>Class:
  java.security.Identity

Modifiers:
  public abstract

Type Parameters:
  -- No Type Parameters --

Implemented Interfaces:
  interface java.security.Principal
  interface java.io.Serializable

Inheritance Path:
  java.lang.Object

Annotations:
  @java.lang.Deprecated()
</code></pre><p>输出表明<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/security/Identity.html"><code>java.security.Identity</code></a>拥有注释<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html"><code>java.lang.Deprecated</code></a>是一个不推荐使用的API。反射代码可以使用它来检测已弃用的API。</p>
<p>注意：并非所有注释都可以通过反射获得。只有具有<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/RetentionPolicy.html#RUNTIME"><code>RUNTIME</code></a>的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/RetentionPolicy.html"><code>java.lang.annotation.RetentionPolicy</code></a>的那些注解才可访问。在 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html"><code>@Deprecated</code></a>，<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Override.html"><code>@Override</code></a>和<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/SuppressWarnings.html"><code>@SuppressWarnings</code></a>语言中预定义的三个注释中，只有<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html"><code>@Deprecated</code></a>在运行时可用。</p>
<h4 id="发现类成员"><a href="#发现类成员" class="headerlink" title="发现类成员"></a>发现类成员</h4><p>类提供了用于访问字段，方法和构造函数的两类方法：枚举这些成员的方法和搜索特定成员的方法。与在超接口和超类中搜索继承的成员的方法相比，直接在类上访问成员方法不太一样。下表总结了所有成员定位方法及其特点。</p>
<p>定位字段的类方法</p>
<table>
<thead>
<tr>
<th>Class API</th>
<th>是否成员列表？</th>
<th>是否包含继承成员？</th>
<th>是否包含私有成员？</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredField-java.lang.String-"><code>getDeclaredField()</code></a></td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getField-java.lang.String-"><code>getField()</code></a></td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredFields--"><code>getDeclaredFields()</code></a></td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getFields--"><code>getFields()</code></a></td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>定位方法的类方法</p>
<table>
<thead>
<tr>
<th>Class API</th>
<th>是否成员列表？</th>
<th>是否包含继承成员？</th>
<th>是否包含私有成员？</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredMethod-java.lang.String-java.lang.Class...-"><code>getDeclaredMethod()</code></a></td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getMethod-java.lang.String-java.lang.Class...-"><code>getMethod()</code></a></td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredMethods--"><code>getDeclaredMethods()</code></a></td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getMethods--"><code>getMethods()</code></a></td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>定位构造方法的类方法</p>
<table>
<thead>
<tr>
<th>Class API</th>
<th>是否成员列表？</th>
<th>是否包含继承成员？</th>
<th>是否包含私有成员？</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredConstructor-java.lang.Class...-"><code>getDeclaredConstructor()</code></a></td>
<td>否</td>
<td>N/A</td>
<td>是</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getConstructor-java.lang.Class...-"><code>getConstructor()</code></a></td>
<td>否</td>
<td>N/A</td>
<td>否</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredConstructors--"><code>getDeclaredConstructors()</code></a></td>
<td>是</td>
<td>N/A</td>
<td>是</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getConstructors--"><code>getConstructors()</code></a></td>
<td>是</td>
<td>N/A</td>
<td>否</td>
</tr>
</tbody>
</table>
<blockquote>
<p>N/A：构造函数不能继承。</p>
</blockquote>
<p>给定一个类名并指出感兴趣的成员，<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/reflect/class/example/ClassSpy.java"><code>ClassSpy</code></a>示例使用<code>get*s()</code>方法确定所有公共成员的列表，包括任何继承的成员。</p>
<pre><code class="java">import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Member;
import static java.lang.System.out;

enum ClassMember &#123; CONSTRUCTOR, FIELD, METHOD, CLASS, ALL &#125;

public class ClassSpy &#123;
    public static void main(String... args) &#123;
    try &#123;
        Class&lt;?&gt; c = Class.forName(args[0]);
        out.format(&quot;Class:%n  %s%n%n&quot;, c.getCanonicalName());

        Package p = c.getPackage();
        out.format(&quot;Package:%n  %s%n%n&quot;,
               (p != null ? p.getName() : &quot;-- No Package --&quot;));

        for (int i = 1; i &lt; args.length; i++) &#123;
        switch (ClassMember.valueOf(args[i])) &#123;
        case CONSTRUCTOR:
            printMembers(c.getConstructors(), &quot;Constructor&quot;);
            break;
        case FIELD:
            printMembers(c.getFields(), &quot;Fields&quot;);
            break;
        case METHOD:
            printMembers(c.getMethods(), &quot;Methods&quot;);
            break;
        case CLASS:
            printClasses(c);
            break;
        case ALL:
            printMembers(c.getConstructors(), &quot;Constuctors&quot;);
            printMembers(c.getFields(), &quot;Fields&quot;);
            printMembers(c.getMethods(), &quot;Methods&quot;);
            printClasses(c);
            break;
        default:
            assert false;
        &#125;
        &#125;

        // production code should handle these exceptions more gracefully
    &#125; catch (ClassNotFoundException x) &#123;
        x.printStackTrace();
    &#125;
    &#125;

    private static void printMembers(Member[] mbrs, String s) &#123;
        out.format(&quot;%s:%n&quot;, s);
        for (Member mbr : mbrs) &#123;
            if (mbr instanceof Field)
            out.format(&quot;  %s%n&quot;, ((Field)mbr).toGenericString());
            else if (mbr instanceof Constructor)
            out.format(&quot;  %s%n&quot;, ((Constructor)mbr).toGenericString());
            else if (mbr instanceof Method)
            out.format(&quot;  %s%n&quot;, ((Method)mbr).toGenericString());
        &#125;
        if (mbrs.length == 0)
            out.format(&quot;  -- No %s --%n&quot;, s);
        out.format(&quot;%n&quot;);
    &#125;

    private static void printClasses(Class&lt;?&gt; c) &#123;
        out.format(&quot;Classes:%n&quot;);
        Class&lt;?&gt;[] clss = c.getClasses();
        for (Class&lt;?&gt; cls : clss)
            out.format(&quot;  %s%n&quot;, cls.getCanonicalName());
        if (clss.length == 0)
            out.format(&quot;  -- No member interfaces, classes, or enums --%n&quot;);
        out.format(&quot;%n&quot;);
    &#125;
&#125;
</code></pre>
<p>这个例子比较紧凑。但是<code>printMembers()</code>方法有点尴尬，因为反射最早的实现中就存在<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Member.html"><code>java.lang.reflect.Member</code></a>接口了，所以后来引入泛型时无法对其进行修改以包含更有用的<code>getGenericString()</code>方法。唯一的选择就是如上面那样进行测试和转换，使用独立的方法如<code>printConstructors()</code>、<code>printFields()</code>、<code>printMethods()</code>进行打印。</p>
<p>输出样本及其解释如下。用户输入以斜体显示。</p>
<p>$ <em><code>java ClassSpy java.lang.ClassCastException CONSTRUCTOR</code></em></p>
<pre><code>Class:
  java.lang.ClassCastException

Package:
  java.lang

Constructor:
  public java.lang.ClassCastException()
  public java.lang.ClassCastException(java.lang.String)
</code></pre><p>由于构造函数不能继承，因此找不到在直接超类<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html"><code>RuntimeException</code></a>和其他超类中定义的异常链接机制构造函数（具有 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html"><code>Throwable</code></a>参数的那些）。</p>
<p>$ <em><code>java ClassSpy java.nio.channels.ReadableByteChannel METHOD</code></em></p>
<pre><code>Class:
  java.nio.channels.ReadableByteChannel

Package:
  java.nio.channels

Methods:
  public abstract int java.nio.channels.ReadableByteChannel.read
    (java.nio.ByteBuffer) throws java.io.IOException
  public abstract void java.nio.channels.Channel.close() throws
    java.io.IOException
  public abstract boolean java.nio.channels.Channel.isOpen()
</code></pre><p> <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/ReadableByteChannel.html"><code>java.nio.channels.ReadableByteChannel</code></a>定义了<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/ReadableByteChannel.html#read-java.nio.ByteBuffer-"><code>read()</code></a>方法。其余方法是从超接口继承的。通过将<code>get * s()</code>替换为<code>getDeclared * s()</code>，这个代码稍作修改，就可以只列出那些在类中实际声明的方法。</p>
<p>$ <em><code>java ClassSpy ClassMember FIELD METHOD</code></em></p>
<pre><code>Class:
  ClassMember

Package:
  -- No Package --

Fields:
  public static final ClassMember ClassMember.CONSTRUCTOR
  public static final ClassMember ClassMember.FIELD
  public static final ClassMember ClassMember.METHOD
  public static final ClassMember ClassMember.CLASS
  public static final ClassMember ClassMember.ALL

Methods:
  public static ClassMember ClassMember.valueOf(java.lang.String)
  public static ClassMember[] ClassMember.values()
  public final int java.lang.Enum.hashCode()
  public final int java.lang.Enum.compareTo(E)
  public int java.lang.Enum.compareTo(java.lang.Object)
  public final java.lang.String java.lang.Enum.name()
  public final boolean java.lang.Enum.equals(java.lang.Object)
  public java.lang.String java.lang.Enum.toString()
  public static &lt;T&gt; T java.lang.Enum.valueOf
    (java.lang.Class&lt;T&gt;,java.lang.String)
  public final java.lang.Class&lt;E&gt; java.lang.Enum.getDeclaringClass()
  public final int java.lang.Enum.ordinal()
  public final native java.lang.Class&lt;?&gt; java.lang.Object.getClass()
  public final native void java.lang.Object.wait(long) throws
    java.lang.InterruptedException
  public final void java.lang.Object.wait(long,int) throws
    java.lang.InterruptedException
  public final void java.lang.Object.wait() hrows java.lang.InterruptedException
  public final native void java.lang.Object.notify()
  public final native void java.lang.Object.notifyAll()
</code></pre><p>在上面结果的field部分中，枚举的常量值都列了出来。While these are technically fields, it might be useful to distinguish them from other fields.可以使用<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html#isEnumConstant--"><code>java.lang.reflect.Field.isEnumConstant()</code></a>达到这个木得。本教程的后续部分<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/reflect/special/enumMembers.html">Examining Enums</a>中示例<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/reflect/special/example/EnumSpy.java"><code>EnumSpy</code></a>给出了一个可能的实现。</p>
<p>在结果的method部分，包含声明类的方法名。因此方法<code>toString()</code>是在<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html#toString--"><code>Enum</code></a>中实现的，而不是继承自<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html"><code>Object</code></a>。通过使用<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html#getDeclaringClass--"><code>Field.getDeclaringClass()</code></a>，可以对代码进行修改以使其更加明显。以下片段说明了潜在解决方案的一部分。</p>
<pre><code class="java">if (mbr instanceof Field) &#123;
    Field f = (Field)mbr;
    out.format(&quot;  %s%n&quot;, f.toGenericString());
    out.format(&quot;  -- declared in: %s%n&quot;, f.getDeclaringClass());
&#125;
</code></pre>
<h4 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h4><p>以下示例显示了在类上使用反射时可能会遇到的典型错误。</p>
<h5 id="编译器警告：”Note-…-uses-unchecked-or-unsafe-operations”"><a href="#编译器警告：”Note-…-uses-unchecked-or-unsafe-operations”" class="headerlink" title="编译器警告：”Note: … uses unchecked or unsafe operations”"></a>编译器警告：”Note: … uses unchecked or unsafe operations”</h5><p>调用方法时，将检查并可能转换参数值的类型。 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/reflect/class/example/ClassWarning.java"><code>ClassWarning</code></a> 调用<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getMethod-java.lang.String-java.lang.Class...-"><code>getMethod()</code></a>会造成一个未受检异常。</p>
<pre><code class="java">import java.lang.reflect.Method;

public class ClassWarning &#123;
    void m() &#123;
        try &#123;
            Class c = ClassWarning.class;
            Method m = c.getMethod(&quot;m&quot;);  // warning

            // production code should handle this exception more gracefully
        &#125; catch (NoSuchMethodException x) &#123;
            x.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>$ <em><code>javac ClassWarning.java</code></em></p>
<pre><code>Note: ClassWarning.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
</code></pre><p>$ <em><code>javac -Xlint:unchecked ClassWarning.java</code></em></p>
<pre><code>ClassWarning.java:6: warning: [unchecked] unchecked call to getMethod
  (String,Class&lt;?&gt;...) as a member of the raw type Class
Method m = c.getMethod(&quot;m&quot;);  // warning
                      ^
1 warning
</code></pre><p>很多库的方法已经使用泛型声明进行了改进。由于<code>c</code>被声明为原始类型（没有类型参数），而<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getMethod-java.lang.String-java.lang.Class...-"><code>getMethod()</code></a>的相应参数是参数化类型，因此发生了未经检查的转换。需要编译器生成警告（参见<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se7/html/index.html"><em>The Java Language Specification, Java SE 7 Edition</em></a>的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.9">Unchecked Conversion</a> 和 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.3">Method Invocation Conversion</a>部分）</p>
<p>有两种可能的解决方案。最好修改c的声明以包含适当的泛型类型。在这种情况下，声明应为：</p>
<pre><code class="java">Class&lt;?&gt; c = warn.getClass();
</code></pre>
<p>或者，可以使用预定义的注解<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/SuppressWarnings.html"><code>@SuppressWarnings</code></a>放置在问题语句的前面来明确禁止警告。</p>
<pre><code class="java">Class c = ClassWarning.class;
@SuppressWarnings(&quot;unchecked&quot;)
Method m = c.getMethod(&quot;m&quot;);  
// warning gone
</code></pre>
<blockquote>
<p>Tip：作为一般原则，不应忽略警告，因为警告可能表明存在错误。应适当使用参数化的声明。如果这是不可能的（也许是因为应用程序必须与库供应商的代码进行交互），请使用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/SuppressWarnings.html"><code>@SuppressWarnings</code></a>注释违规行。</p>
</blockquote>
<h5 id="构造函数不可访问时的InstantiationException"><a href="#构造函数不可访问时的InstantiationException" class="headerlink" title="构造函数不可访问时的InstantiationException"></a>构造函数不可访问时的InstantiationException</h5><p>如果尝试创建该类的新实例并且零参数构造函数不可见，则<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#newInstance--"><code>Class.newInstance()</code></a>将引发<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/InstantiationException.html"><code>InstantiationException</code></a>。 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/reflect/class/example/ClassTrouble.java"><code>ClassTrouble</code></a>示例说明了生成的堆栈记录。</p>
<pre><code class="java">class Cls &#123;
    private Cls() &#123;&#125;
&#125;

public class ClassTrouble &#123;
    public static void main(String... args) &#123;
    try &#123;
        Class&lt;?&gt; c = Class.forName(&quot;Cls&quot;);
        c.newInstance();  // InstantiationException

        // production code should handle these exceptions more gracefully
    &#125; catch (InstantiationException x) &#123;
        x.printStackTrace();
    &#125; catch (IllegalAccessException x) &#123;
        x.printStackTrace();
    &#125; catch (ClassNotFoundException x) &#123;
        x.printStackTrace();
    &#125;
    &#125;
&#125;
</code></pre>
<p>$ <em><code>java ClassTrouble</code></em></p>
<pre><code>java.lang.IllegalAccessException: Class ClassTrouble can not access a member of
  class Cls with modifiers &quot;private&quot;
        at sun.reflect.Reflection.ensureMemberAccess(Reflection.java:65)
        at java.lang.Class.newInstance0(Class.java:349)
        at java.lang.Class.newInstance(Class.java:308)
        at ClassTrouble.main(ClassTrouble.java:9)
</code></pre><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#newInstance--"><code>Class.newInstance()</code></a>行为非常类似于new关键字，new失败方法也会失败。反射中的典型解决方案是利用<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AccessibleObject.html"><code>java.lang.reflect.AccessibleObject</code></a>类，该类提供了抑制访问控制检查的功能。但是这种方法不适用于本例，因为<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><code>java.lang.Class</code></a>没有继承<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AccessibleObject.html"><code>AccessibleObject</code></a>。唯一的解决方式就是修改代码使用继承<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AccessibleObject.html"><code>AccessibleObject</code></a>的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Constructor.html#newInstance-java.lang.Object...-"><code>Constructor.newInstance()</code></a>方法。</p>
<blockquote>
<p>Tip：由于本教程<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/reflect/member/index.html">成员</a>章节<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/reflect/member/ctorInstance.html">创建新的类实例</a> 部分所说的原因，一般情况下，使用<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Constructor.html#newInstance-java.lang.Object...-"><code>Constructor.newInstance()</code></a>会好一些。</p>
</blockquote>
<p>更多的栗子参见本教程<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/reflect/member/index.html">成员</a>章节<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/reflect/member/ctorInstance.html">创建新的类实例</a> 部分。</p>

  </div>
  <div class="post-footer">
    
      <ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E5%8F%8D%E5%B0%84/" rel="tag">反射</a></li></ul>
    

    <a href="#top" class="top">返回顶部</a>
  </div>
</article>
<footer>
    &copy; 2021
    <span class="author">
        nonsense
    </span>

     
        <span class="motto">
            世上无难事，只要肯登攀
        </span>
     
     
        <div id="disqus_thread">
        <script>
        /**
        *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
        *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
        var disqus_config = function () {
        this.page.url = 'https://pingao777.github.io/2020/03/07/简明Java反射教程1：类（Classes/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '2020/03/07/简明Java反射教程1：类（Classes/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        this.page.title = '简明Java反射教程1：类（Classes）';
        };

        (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://pingao777.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
        })();
        </script>
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
     
    </div>
</footer>


    </div>
  </body>
</html>